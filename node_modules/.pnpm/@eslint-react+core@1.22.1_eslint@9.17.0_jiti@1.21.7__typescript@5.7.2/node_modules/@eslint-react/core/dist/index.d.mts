import * as AST from '@eslint-react/ast';
import { O } from '@eslint-react/eff';
import { TSESTree } from '@typescript-eslint/types';
import * as _eslint_react_types from '@eslint-react/types';
import { RuleContext } from '@eslint-react/types';
import { TSESTree as TSESTree$1 } from '@typescript-eslint/utils';
import * as _typescript_eslint_utils_ts_eslint from '@typescript-eslint/utils/ts-eslint';
import * as birecord from 'birecord';
import { ESLintReactSettings } from '@eslint-react/shared';
import { Scope } from '@typescript-eslint/scope-manager';
import { SyntaxKind } from 'typescript';

interface ERSemanticNode {
    _: string;
    id: O.Option<TSESTree.Identifier | TSESTree.Identifier[]>;
    kind: string;
    name: O.Option<string>;
    node: TSESTree.Node;
    flag: bigint;
    hint: bigint;
}

type ERComponentHint = bigint;
/**
 * hints for component collector
 */
declare const ERComponentHint: {
    readonly SkipMemo: bigint;
    readonly SkipForwardRef: bigint;
    readonly SkipMapCallback: bigint;
    readonly SkipObjectMethod: bigint;
    readonly SkipClassMethod: bigint;
    readonly SkipClassProperty: bigint;
    readonly None: 0n;
    readonly SkipNullLiteral: bigint;
    readonly SkipUndefinedLiteral: bigint;
    readonly SkipBooleanLiteral: bigint;
    readonly SkipStringLiteral: bigint;
    readonly SkipNumberLiteral: bigint;
    readonly SkipCreateElement: bigint;
    readonly SkipEmptyArray: bigint;
    readonly StrictArray: bigint;
    readonly StrictLogical: bigint;
    readonly StrictConditional: bigint;
};
declare const DEFAULT_COMPONENT_HINT: bigint;

type ERClassComponentFlag = bigint;
declare const ERClassComponentFlag: {
    None: bigint;
    PureComponent: bigint;
};
type ERFunctionComponentFlag = bigint;
declare const ERFunctionComponentFlag: {
    None: bigint;
    Memo: bigint;
    ForwardRef: bigint;
};

interface ERFunctionComponent extends ERSemanticNode {
    id: O.Option<TSESTree.Identifier | TSESTree.Identifier[]>;
    kind: "function";
    node: AST.TSESTreeFunction;
    flag: ERFunctionComponentFlag;
    hint: ERComponentHint;
    initPath: O.Option<AST.FunctionInitPath>;
    hookCalls: TSESTree.CallExpression[];
    displayName: O.Option<TSESTree.Expression>;
}
interface ERClassComponent extends ERSemanticNode {
    id: O.Option<TSESTree.Identifier>;
    kind: "class";
    node: AST.TSESTreeClass;
    flag: ERClassComponentFlag;
    hint: ERComponentHint;
    methods: (TSESTree.MethodDefinition | TSESTree.PropertyDefinition)[];
    displayName: O.Option<TSESTree.Expression>;
}
type ERComponent = ERClassComponent | ERFunctionComponent;

declare function useComponentCollector(context: RuleContext, hint?: bigint): {
    readonly ctx: {
        readonly getAllComponents: (_: TSESTree.Program) => Map<string, ERFunctionComponent>;
        readonly getCurrentComponents: () => Map<string, ERFunctionComponent>;
        readonly getCurrentFunction: () => O.Option<[key: string, node: AST.TSESTreeFunction, isComponent: boolean, hookCalls: TSESTree.CallExpression[]]>;
        readonly getCurrentFunctionStack: () => [key: string, node: AST.TSESTreeFunction, isComponent: boolean, hookCalls: TSESTree.CallExpression[]][];
    };
    readonly listeners: {
        readonly ":function[type]": (node: AST.TSESTreeFunction) => number;
        readonly ":function[type]:exit": () => [key: string, node: AST.TSESTreeFunction, isComponent: boolean, hookCalls: TSESTree.CallExpression[]] | undefined;
        readonly "ArrowFunctionExpression[type][body.type!='BlockStatement']": () => void;
        readonly "AssignmentExpression[type][operator='='][left.type='MemberExpression'][left.property.name='displayName']": (node: TSESTree.Node) => void;
        readonly "CallExpression[type]:exit": (node: TSESTree.CallExpression) => void;
        readonly "ReturnStatement[type]": (node: TSESTree.ReturnStatement) => void;
    };
};

/**
 * Check if a node is a React class component
 * @param node The AST node to check
 * @returns `true` if the node is a class component, `false` otherwise
 */
declare function isClassComponent(node: TSESTree$1.Node): node is AST.TSESTreeClass;
/**
 * Check if a node is a React PureComponent
 * @param node The AST node to check
 * @returns `true` if the node is a pure component, `false` otherwise
 */
declare function isPureComponent(node: TSESTree$1.Node): boolean;
declare function isComponentDidMount(node: TSESTree$1.Node): node is TSESTree$1.MethodDefinition | TSESTree$1.PropertyDefinition;
declare function isComponentWillUnmount(node: TSESTree$1.Node): node is TSESTree$1.MethodDefinition | TSESTree$1.PropertyDefinition;
declare function isComponentDidMountFunction(node: TSESTree$1.Node): boolean;
declare function isComponentWillUnmountFunction(node: TSESTree$1.Node): boolean;
declare function useComponentCollectorLegacy(): {
    readonly ctx: {
        readonly getAllComponents: (_: TSESTree$1.Program) => Map<string, ERClassComponent>;
        readonly getCurrentComponents: () => Map<string, ERClassComponent>;
    };
    readonly listeners: {
        readonly "ClassDeclaration[type]": (node: AST.TSESTreeClass) => void;
        readonly "ClassExpression[type]": (node: AST.TSESTreeClass) => void;
    };
};

declare function getFunctionComponentIdentifier(node: AST.TSESTreeFunction, context: RuleContext): O.Option<TSESTree.Identifier | TSESTree.Identifier[]>;

type ERComponentKind = "classComponent" | "functionComponent";

type EREffectMethodKind = "useEffect" | "useInsertionEffect" | "useLayoutEffect";
type ERLifecycleMethodKind = "componentDidMount" | "componentWillUnmount";

declare const RE_COMPONENT_NAME: RegExp;
declare function getComponentNameFromIdentifier(node: TSESTree.Identifier | TSESTree.Identifier[]): string;
declare function isComponentName(name: string): boolean;

declare function isFunctionOfRenderMethod(node: AST.TSESTreeFunction): boolean;
/**
 * Check whether given node is declared inside class component's render block
 * ```jsx
 * class Component extends React.Component {
 *   render() {
 *     class NestedClassComponent extends React.Component {
 *      render() { return <div />; }
 *     }
 *     const nestedFunctionComponent = () => <div />;
 *  }
 * }
 * ```
 * @param node The AST node being checked
 * @returns `true` if node is inside class component's render block, `false` if not
 */
declare function isInsideRenderMethod(node: TSESTree$1.Node): boolean;

declare function hasNoneOrValidComponentName(node: AST.TSESTreeFunction, context: RuleContext): boolean;

type EREffectKind = "effect" | "insertionEffect" | "layoutEffect";

declare function isSetupFunction(node: TSESTree.Node): boolean;
declare function isCleanupFunction(node: TSESTree.Node): boolean;

declare function getElementRepresentName(node: TSESTree.JSXOpeningElement, context: RuleContext): string;

/**
 * Determines whether inside createElement's props.
 * @param node The AST node to check
 * @param context The rule context
 * @returns `true` if the node is inside createElement's props
 */
declare function isInsideCreateElementProps(node: TSESTree.Node, context: RuleContext): boolean;
declare function isChildrenOfCreateElement(node: TSESTree.Node, context: RuleContext): boolean;

/**
 * Check if a node is `<Fragment></Fragment>` or `<Pragma.Fragment></Pragma.Fragment>`
 * @param node The JSX element node to check
 * @param context The rule context
 * @returns `true` if the node is a fragment element, `false` otherwise
 */
declare function isFragmentElement(node: TSESTree.JSXElement, context: RuleContext): boolean;

declare function isInsideReactHook(node: TSESTree.Node): boolean;
declare function isInsideReactHookCall(node: TSESTree.Node): boolean;

interface ERHook extends ERSemanticNode {
    id: O.Some<TSESTree.Identifier>;
    node: AST.TSESTreeFunction;
    name: O.Some<string>;
    hookCalls: TSESTree.CallExpression[];
}

declare function useHookCollector(): {
    readonly ctx: {
        readonly getAllHooks: (_: TSESTree$1.Program) => Map<string, ERHook>;
        readonly getCurrentHooks: () => Map<string, ERHook>;
    };
    readonly listeners: {
        readonly ":function[type]": (node: AST.TSESTreeFunction) => void;
        readonly ":function[type]:exit": () => void;
        readonly "CallExpression[type]": (node: never) => void;
    };
};

type ERHookKind = "custom" | "useActionState" | "useCallback" | "useContext" | "useDebugValue" | "useDeferredValue" | "useEffect" | "useId" | "useImperativeHandle" | "useInsertionEffect" | "useLayoutEffect" | "useMemo" | "useOptimistic" | "useReducer" | "useRef" | "useState" | "useSyncExternalStore" | "useTransition";

declare const RE_HOOK_NAME: RegExp;
declare function isReactHookName(name: string): boolean;

declare function isReactHook(node: AST.TSESTreeFunction): boolean;
/**
 * Check if the given node is a React Hook call by its name.
 * @param node The node to check.
 * @returns `true` if the node is a React Hook call, `false` otherwise.
 */
declare function isReactHookCall(node: TSESTree.CallExpression): boolean;
declare function isReactHookCallWithName(node: TSESTree.CallExpression, context: RuleContext): (name: string) => boolean;
declare function isReactHookCallWithNameLoose(node: TSESTree.CallExpression): (name: string) => boolean;
declare function isReactHookCallWithNameAlias(name: string, context: RuleContext, alias: string[]): (node: TSESTree.CallExpression) => boolean;
declare function isUseEffectCallLoose(node: TSESTree.Node): boolean;
declare const isUseCallbackCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseContextCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseDebugValueCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseDeferredValueCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseEffectCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseIdCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseImperativeHandleCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseInsertionEffectCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseLayoutEffectCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseMemoCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseReducerCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseRefCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseStateCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseSyncExternalStoreCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;
declare const isUseTransitionCall: (node: TSESTree.CallExpression, context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>) => boolean;

declare const ERPhaseRelevance: birecord.BiRecord<{
    readonly mount: "unmount";
    readonly setup: "cleanup";
}>;

type EREffectPhaseKind = "cleanup" | "setup";
type ERLifecyclePhaseKind = "mount" | "unmount";
type ERPhaseKind = EREffectPhaseKind | ERLifecyclePhaseKind;

declare const isInversePhase: {
    (a: ERPhaseKind): (b: ERPhaseKind) => boolean;
    (a: ERPhaseKind, b: ERPhaseKind): boolean;
};

/**
 * Unsafe check whether given node is declared directly inside a render property
 * ```jsx
 * const rows = { render: () => <div /> }
 * `                      ^^^^^^^^^^^^^ `
 * _ = <Component rows={ [{ render: () => <div /> }] } />
 * `                                ^^^^^^^^^^^^^       `
 *  ```
 * @internal
 * @param node The AST node to check
 * @returns `true` if component is declared inside a render property, `false` if not
 */
declare function isDirectValueOfRenderPropertyLoose(node: TSESTree.Node): boolean;
/**
 * Unsafe check whether given node is declared inside a render prop
 * ```jsx
 * _ = <Component renderRow={"node"} />
 * `                         ^^^^^^   `
 * _ = <Component rows={ [{ render: "node" }] } />
 * `                                ^^^^^^       `
 * ```
 * @param node The AST node to check
 * @returns `true` if component is declared inside a render prop, `false` if not
 */
declare function isDeclaredInRenderPropLoose(node: TSESTree.Node): boolean;

/**
 * Unsafe check whether given node is a render function
 * ```jsx
 * const renderRow = () => <div />
 * `                 ^^^^^^^^^^^^`
 * _ = <Component renderRow={() => <div />} />
 * `                         ^^^^^^^^^^^^^   `
 * ```
 * @param node The AST node to check
 * @param context The rule context
 * @returns `true` if node is a render function, `false` if not
 */
declare function isRenderFunctionLoose(node: AST.TSESTreeFunction, context: RuleContext): boolean;
/**
 * Unsafe check whether given JSXAttribute is a render prop
 * ```jsx
 * _ = <Component renderRow={() => <div />} />
 * `              ^^^^^^^^^^^^^^^^^^^^^^^^^  `
 * ```
 * @param node The AST node to check
 * @param context The rule context
 * @returns `true` if node is a render prop, `false` if not
 */
declare function isRenderPropLoose(node: TSESTree.JSXAttribute, context: RuleContext): boolean;

interface ERSemanticEntry {
    node: TSESTree.Node;
    phase: ERPhaseKind;
}

declare function isThisSetState(node: TSESTree.CallExpression): boolean;

type ERStateKind = "actionState" | "state";

/**
 * Checks if the given node is a call expression to the given function or method of the pragma
 * @param name The name of the function or method to check
 * @returns A predicate that checks if the given node is a call expression to the given function or method
 */
declare function isFromReact(name: string): (node: TSESTree.Identifier | TSESTree.MemberExpression, context: RuleContext) => boolean;
/**
 * @internal
 * @param memberName The name of the member object
 * @param name The name of the member property
 * @returns A function that checks if a given node is a member expression of a Pragma member.
 */
declare function isFromReactMember(memberName: string, name: string): (node: TSESTree.MemberExpression, context: RuleContext) => boolean;
declare function isCallFromReact(name: string): (node: TSESTree.CallExpression, context: RuleContext) => boolean;
declare function isCallFromReactMember(pragmaMemberName: string, name: string): (node: TSESTree.CallExpression, context: RuleContext) => boolean;

/**
 * Check if an identifier is initialized from React
 * @param name The top-level identifier's name
 * @param initialScope Initial scope to search for the identifier
 * @param settings ESLint React settings
 * @returns Whether the identifier is initialized from React
 */
declare function isInitializedFromReact(name: string, initialScope: Scope, settings: ESLintReactSettings): boolean;

/**********************************************
 *      DO NOT MODIFY THIS FILE MANUALLY      *
 *                                            *
 *  THIS FILE HAS BEEN COPIED FROM ast-spec.  *
 * ANY CHANGES WILL BE LOST ON THE NEXT BUILD *
 *                                            *
 *   MAKE CHANGES TO ast-spec AND THEN RUN    *
 *                 yarn build                 *
 **********************************************/

declare type Accessibility = 'private' | 'protected' | 'public';
declare type AccessorProperty = AccessorPropertyComputedName | AccessorPropertyNonComputedName;
declare interface AccessorPropertyComputedName extends PropertyDefinitionComputedNameBase {
    type: AST_NODE_TYPES.AccessorProperty;
}
declare interface AccessorPropertyNonComputedName extends PropertyDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.AccessorProperty;
}
declare interface ArrayExpression extends BaseNode {
    type: AST_NODE_TYPES.ArrayExpression;
    /**
     * an element will be `null` in the case of a sparse array: `[1, ,3]`
     */
    elements: (Expression | SpreadElement | null)[];
}
declare interface ArrayPattern extends BaseNode {
    type: AST_NODE_TYPES.ArrayPattern;
    decorators: Decorator[];
    elements: (DestructuringPattern | null)[];
    optional: boolean;
    typeAnnotation: TSTypeAnnotation | undefined;
}
declare interface ArrowFunctionExpression extends BaseNode {
    type: AST_NODE_TYPES.ArrowFunctionExpression;
    async: boolean;
    body: BlockStatement | Expression;
    expression: boolean;
    generator: boolean;
    id: null;
    params: Parameter[];
    returnType: TSTypeAnnotation | undefined;
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare interface AssignmentExpression extends BaseNode {
    type: AST_NODE_TYPES.AssignmentExpression;
    left: Expression;
    operator: ValueOf<AssignmentOperatorToText>;
    right: Expression;
}
declare interface AssignmentOperatorToText {
    [SyntaxKind.AmpersandAmpersandEqualsToken]: '&&=';
    [SyntaxKind.AmpersandEqualsToken]: '&=';
    [SyntaxKind.AsteriskAsteriskEqualsToken]: '**=';
    [SyntaxKind.AsteriskEqualsToken]: '*=';
    [SyntaxKind.BarBarEqualsToken]: '||=';
    [SyntaxKind.BarEqualsToken]: '|=';
    [SyntaxKind.CaretEqualsToken]: '^=';
    [SyntaxKind.EqualsToken]: '=';
    [SyntaxKind.GreaterThanGreaterThanEqualsToken]: '>>=';
    [SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken]: '>>>=';
    [SyntaxKind.LessThanLessThanEqualsToken]: '<<=';
    [SyntaxKind.MinusEqualsToken]: '-=';
    [SyntaxKind.PercentEqualsToken]: '%=';
    [SyntaxKind.PlusEqualsToken]: '+=';
    [SyntaxKind.QuestionQuestionEqualsToken]: '??=';
    [SyntaxKind.SlashEqualsToken]: '/=';
}
declare interface AssignmentPattern extends BaseNode {
    type: AST_NODE_TYPES.AssignmentPattern;
    decorators: Decorator[];
    left: BindingName;
    optional: boolean;
    right: Expression;
    typeAnnotation: TSTypeAnnotation | undefined;
}
declare enum AST_NODE_TYPES {
    AccessorProperty = "AccessorProperty",
    ArrayExpression = "ArrayExpression",
    ArrayPattern = "ArrayPattern",
    ArrowFunctionExpression = "ArrowFunctionExpression",
    AssignmentExpression = "AssignmentExpression",
    AssignmentPattern = "AssignmentPattern",
    AwaitExpression = "AwaitExpression",
    BinaryExpression = "BinaryExpression",
    BlockStatement = "BlockStatement",
    BreakStatement = "BreakStatement",
    CallExpression = "CallExpression",
    CatchClause = "CatchClause",
    ChainExpression = "ChainExpression",
    ClassBody = "ClassBody",
    ClassDeclaration = "ClassDeclaration",
    ClassExpression = "ClassExpression",
    ConditionalExpression = "ConditionalExpression",
    ContinueStatement = "ContinueStatement",
    DebuggerStatement = "DebuggerStatement",
    Decorator = "Decorator",
    DoWhileStatement = "DoWhileStatement",
    EmptyStatement = "EmptyStatement",
    ExportAllDeclaration = "ExportAllDeclaration",
    ExportDefaultDeclaration = "ExportDefaultDeclaration",
    ExportNamedDeclaration = "ExportNamedDeclaration",
    ExportSpecifier = "ExportSpecifier",
    ExpressionStatement = "ExpressionStatement",
    ForInStatement = "ForInStatement",
    ForOfStatement = "ForOfStatement",
    ForStatement = "ForStatement",
    FunctionDeclaration = "FunctionDeclaration",
    FunctionExpression = "FunctionExpression",
    Identifier = "Identifier",
    IfStatement = "IfStatement",
    ImportAttribute = "ImportAttribute",
    ImportDeclaration = "ImportDeclaration",
    ImportDefaultSpecifier = "ImportDefaultSpecifier",
    ImportExpression = "ImportExpression",
    ImportNamespaceSpecifier = "ImportNamespaceSpecifier",
    ImportSpecifier = "ImportSpecifier",
    JSXAttribute = "JSXAttribute",
    JSXClosingElement = "JSXClosingElement",
    JSXClosingFragment = "JSXClosingFragment",
    JSXElement = "JSXElement",
    JSXEmptyExpression = "JSXEmptyExpression",
    JSXExpressionContainer = "JSXExpressionContainer",
    JSXFragment = "JSXFragment",
    JSXIdentifier = "JSXIdentifier",
    JSXMemberExpression = "JSXMemberExpression",
    JSXNamespacedName = "JSXNamespacedName",
    JSXOpeningElement = "JSXOpeningElement",
    JSXOpeningFragment = "JSXOpeningFragment",
    JSXSpreadAttribute = "JSXSpreadAttribute",
    JSXSpreadChild = "JSXSpreadChild",
    JSXText = "JSXText",
    LabeledStatement = "LabeledStatement",
    Literal = "Literal",
    LogicalExpression = "LogicalExpression",
    MemberExpression = "MemberExpression",
    MetaProperty = "MetaProperty",
    MethodDefinition = "MethodDefinition",
    NewExpression = "NewExpression",
    ObjectExpression = "ObjectExpression",
    ObjectPattern = "ObjectPattern",
    PrivateIdentifier = "PrivateIdentifier",
    Program = "Program",
    Property = "Property",
    PropertyDefinition = "PropertyDefinition",
    RestElement = "RestElement",
    ReturnStatement = "ReturnStatement",
    SequenceExpression = "SequenceExpression",
    SpreadElement = "SpreadElement",
    StaticBlock = "StaticBlock",
    Super = "Super",
    SwitchCase = "SwitchCase",
    SwitchStatement = "SwitchStatement",
    TaggedTemplateExpression = "TaggedTemplateExpression",
    TemplateElement = "TemplateElement",
    TemplateLiteral = "TemplateLiteral",
    ThisExpression = "ThisExpression",
    ThrowStatement = "ThrowStatement",
    TryStatement = "TryStatement",
    UnaryExpression = "UnaryExpression",
    UpdateExpression = "UpdateExpression",
    VariableDeclaration = "VariableDeclaration",
    VariableDeclarator = "VariableDeclarator",
    WhileStatement = "WhileStatement",
    WithStatement = "WithStatement",
    YieldExpression = "YieldExpression",
    TSAbstractAccessorProperty = "TSAbstractAccessorProperty",
    TSAbstractKeyword = "TSAbstractKeyword",
    TSAbstractMethodDefinition = "TSAbstractMethodDefinition",
    TSAbstractPropertyDefinition = "TSAbstractPropertyDefinition",
    TSAnyKeyword = "TSAnyKeyword",
    TSArrayType = "TSArrayType",
    TSAsExpression = "TSAsExpression",
    TSAsyncKeyword = "TSAsyncKeyword",
    TSBigIntKeyword = "TSBigIntKeyword",
    TSBooleanKeyword = "TSBooleanKeyword",
    TSCallSignatureDeclaration = "TSCallSignatureDeclaration",
    TSClassImplements = "TSClassImplements",
    TSConditionalType = "TSConditionalType",
    TSConstructorType = "TSConstructorType",
    TSConstructSignatureDeclaration = "TSConstructSignatureDeclaration",
    TSDeclareFunction = "TSDeclareFunction",
    TSDeclareKeyword = "TSDeclareKeyword",
    TSEmptyBodyFunctionExpression = "TSEmptyBodyFunctionExpression",
    TSEnumBody = "TSEnumBody",
    TSEnumDeclaration = "TSEnumDeclaration",
    TSEnumMember = "TSEnumMember",
    TSExportAssignment = "TSExportAssignment",
    TSExportKeyword = "TSExportKeyword",
    TSExternalModuleReference = "TSExternalModuleReference",
    TSFunctionType = "TSFunctionType",
    TSImportEqualsDeclaration = "TSImportEqualsDeclaration",
    TSImportType = "TSImportType",
    TSIndexedAccessType = "TSIndexedAccessType",
    TSIndexSignature = "TSIndexSignature",
    TSInferType = "TSInferType",
    TSInstantiationExpression = "TSInstantiationExpression",
    TSInterfaceBody = "TSInterfaceBody",
    TSInterfaceDeclaration = "TSInterfaceDeclaration",
    TSInterfaceHeritage = "TSInterfaceHeritage",
    TSIntersectionType = "TSIntersectionType",
    TSIntrinsicKeyword = "TSIntrinsicKeyword",
    TSLiteralType = "TSLiteralType",
    TSMappedType = "TSMappedType",
    TSMethodSignature = "TSMethodSignature",
    TSModuleBlock = "TSModuleBlock",
    TSModuleDeclaration = "TSModuleDeclaration",
    TSNamedTupleMember = "TSNamedTupleMember",
    TSNamespaceExportDeclaration = "TSNamespaceExportDeclaration",
    TSNeverKeyword = "TSNeverKeyword",
    TSNonNullExpression = "TSNonNullExpression",
    TSNullKeyword = "TSNullKeyword",
    TSNumberKeyword = "TSNumberKeyword",
    TSObjectKeyword = "TSObjectKeyword",
    TSOptionalType = "TSOptionalType",
    TSParameterProperty = "TSParameterProperty",
    TSPrivateKeyword = "TSPrivateKeyword",
    TSPropertySignature = "TSPropertySignature",
    TSProtectedKeyword = "TSProtectedKeyword",
    TSPublicKeyword = "TSPublicKeyword",
    TSQualifiedName = "TSQualifiedName",
    TSReadonlyKeyword = "TSReadonlyKeyword",
    TSRestType = "TSRestType",
    TSSatisfiesExpression = "TSSatisfiesExpression",
    TSStaticKeyword = "TSStaticKeyword",
    TSStringKeyword = "TSStringKeyword",
    TSSymbolKeyword = "TSSymbolKeyword",
    TSTemplateLiteralType = "TSTemplateLiteralType",
    TSThisType = "TSThisType",
    TSTupleType = "TSTupleType",
    TSTypeAliasDeclaration = "TSTypeAliasDeclaration",
    TSTypeAnnotation = "TSTypeAnnotation",
    TSTypeAssertion = "TSTypeAssertion",
    TSTypeLiteral = "TSTypeLiteral",
    TSTypeOperator = "TSTypeOperator",
    TSTypeParameter = "TSTypeParameter",
    TSTypeParameterDeclaration = "TSTypeParameterDeclaration",
    TSTypeParameterInstantiation = "TSTypeParameterInstantiation",
    TSTypePredicate = "TSTypePredicate",
    TSTypeQuery = "TSTypeQuery",
    TSTypeReference = "TSTypeReference",
    TSUndefinedKeyword = "TSUndefinedKeyword",
    TSUnionType = "TSUnionType",
    TSUnknownKeyword = "TSUnknownKeyword",
    TSVoidKeyword = "TSVoidKeyword"
}
declare interface AwaitExpression extends BaseNode {
    type: AST_NODE_TYPES.AwaitExpression;
    argument: Expression;
}
declare interface BaseNode extends NodeOrTokenData {
    type: AST_NODE_TYPES;
}
declare interface BigIntLiteral extends LiteralBase {
    bigint: string;
    value: bigint | null;
}
declare interface BinaryExpression extends BaseNode {
    type: AST_NODE_TYPES.BinaryExpression;
    left: Expression | PrivateIdentifier;
    operator: ValueOf<BinaryOperatorToText>;
    right: Expression;
}
declare interface BinaryOperatorToText {
    [SyntaxKind.AmpersandAmpersandToken]: '&&';
    [SyntaxKind.AmpersandToken]: '&';
    [SyntaxKind.AsteriskAsteriskToken]: '**';
    [SyntaxKind.AsteriskToken]: '*';
    [SyntaxKind.BarBarToken]: '||';
    [SyntaxKind.BarToken]: '|';
    [SyntaxKind.CaretToken]: '^';
    [SyntaxKind.EqualsEqualsEqualsToken]: '===';
    [SyntaxKind.EqualsEqualsToken]: '==';
    [SyntaxKind.ExclamationEqualsEqualsToken]: '!==';
    [SyntaxKind.ExclamationEqualsToken]: '!=';
    [SyntaxKind.GreaterThanEqualsToken]: '>=';
    [SyntaxKind.GreaterThanGreaterThanGreaterThanToken]: '>>>';
    [SyntaxKind.GreaterThanGreaterThanToken]: '>>';
    [SyntaxKind.GreaterThanToken]: '>';
    [SyntaxKind.InKeyword]: 'in';
    [SyntaxKind.InstanceOfKeyword]: 'instanceof';
    [SyntaxKind.LessThanEqualsToken]: '<=';
    [SyntaxKind.LessThanLessThanToken]: '<<';
    [SyntaxKind.LessThanToken]: '<';
    [SyntaxKind.MinusToken]: '-';
    [SyntaxKind.PercentToken]: '%';
    [SyntaxKind.PlusToken]: '+';
    [SyntaxKind.SlashToken]: '/';
}
declare type BindingName = BindingPattern | Identifier;
declare type BindingPattern = ArrayPattern | ObjectPattern;
declare interface BlockStatement extends BaseNode {
    type: AST_NODE_TYPES.BlockStatement;
    body: Statement[];
}
declare interface BooleanLiteral extends LiteralBase {
    raw: 'false' | 'true';
    value: boolean;
}
declare interface BreakStatement extends BaseNode {
    type: AST_NODE_TYPES.BreakStatement;
    label: Identifier | null;
}
declare interface CallExpression extends BaseNode {
    type: AST_NODE_TYPES.CallExpression;
    arguments: CallExpressionArgument[];
    callee: Expression;
    optional: boolean;
    typeArguments: TSTypeParameterInstantiation | undefined;
}
declare type CallExpressionArgument = Expression | SpreadElement;
declare interface CatchClause extends BaseNode {
    type: AST_NODE_TYPES.CatchClause;
    body: BlockStatement;
    param: BindingName | null;
}
declare type ChainElement = CallExpression | MemberExpression | TSNonNullExpression;
declare interface ChainExpression extends BaseNode {
    type: AST_NODE_TYPES.ChainExpression;
    expression: ChainElement;
}
declare interface ClassBase extends BaseNode {
    /**
     * Whether the class is an abstract class.
     * @example
     * ```ts
     * abstract class Foo {}
     * ```
     */
    abstract: boolean;
    /**
     * The class body.
     */
    body: ClassBody;
    /**
     * Whether the class has been `declare`d:
     * @example
     * ```ts
     * declare class Foo {}
     * ```
     */
    declare: boolean;
    /**
     * The decorators declared for the class.
     * @example
     * ```ts
     * @deco
     * class Foo {}
     * ```
     */
    decorators: Decorator[];
    /**
     * The class's name.
     * - For a `ClassExpression` this may be `null` if the name is omitted.
     * - For a `ClassDeclaration` this may be `null` if and only if the parent is
     *   an `ExportDefaultDeclaration`.
     */
    id: Identifier | null;
    /**
     * The implemented interfaces for the class.
     */
    implements: TSClassImplements[];
    /**
     * The super class this class extends.
     */
    superClass: LeftHandSideExpression | null;
    /**
     * The generic type parameters passed to the superClass.
     */
    superTypeArguments: TSTypeParameterInstantiation | undefined;
    /**
     * The generic type parameters declared for the class.
     */
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare interface ClassBody extends BaseNode {
    type: AST_NODE_TYPES.ClassBody;
    body: ClassElement[];
}
declare interface ClassDeclarationBase extends ClassBase {
    type: AST_NODE_TYPES.ClassDeclaration;
}
/**
 * A normal class declaration:
 * ```
 * class A {}
 * ```
 */
declare interface ClassDeclarationWithName extends ClassDeclarationBase {
    id: Identifier;
}
/**
 * Default-exported class declarations have optional names:
 * ```
 * export default class {}
 * ```
 */
declare interface ClassDeclarationWithOptionalName extends ClassDeclarationBase {
    id: Identifier | null;
}
declare type ClassElement = AccessorProperty | MethodDefinition | PropertyDefinition | StaticBlock | TSAbstractAccessorProperty | TSAbstractMethodDefinition | TSAbstractPropertyDefinition | TSIndexSignature;
declare interface ClassExpression extends ClassBase {
    type: AST_NODE_TYPES.ClassExpression;
    abstract: false;
    declare: false;
}
declare interface ClassMethodDefinitionNonComputedNameBase extends MethodDefinitionBase {
    computed: false;
    key: ClassPropertyNameNonComputed;
}
declare interface ClassPropertyDefinitionNonComputedNameBase extends PropertyDefinitionBase {
    computed: false;
    key: ClassPropertyNameNonComputed;
}
declare type ClassPropertyNameNonComputed = PrivateIdentifier | PropertyNameNonComputed;
declare interface ConditionalExpression extends BaseNode {
    type: AST_NODE_TYPES.ConditionalExpression;
    alternate: Expression;
    consequent: Expression;
    test: Expression;
}
declare interface ConstDeclaration extends LetOrConstOrVarDeclarationBase {
    /**
     * In a `declare const` declaration, the declarators may have initializers, but
     * not definite assignment assertions. Each declarator cannot have both an
     * initializer and a type annotation.
     *
     * Even if the declaration has no `declare`, it may still be ambient and have
     * no initializer.
     */
    declarations: VariableDeclaratorMaybeInit[];
    kind: 'const';
}
declare interface ContinueStatement extends BaseNode {
    type: AST_NODE_TYPES.ContinueStatement;
    label: Identifier | null;
}
declare interface DebuggerStatement extends BaseNode {
    type: AST_NODE_TYPES.DebuggerStatement;
}
declare interface Decorator extends BaseNode {
    type: AST_NODE_TYPES.Decorator;
    expression: LeftHandSideExpression;
}
declare type DefaultExportDeclarations = ClassDeclarationWithOptionalName | Expression | FunctionDeclarationWithName | FunctionDeclarationWithOptionalName | TSDeclareFunction | TSEnumDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSTypeAliasDeclaration | VariableDeclaration;
declare type DestructuringPattern = ArrayPattern | AssignmentPattern | Identifier | MemberExpression | ObjectPattern | RestElement;
declare interface DoWhileStatement extends BaseNode {
    type: AST_NODE_TYPES.DoWhileStatement;
    body: Statement;
    test: Expression;
}
declare interface EmptyStatement extends BaseNode {
    type: AST_NODE_TYPES.EmptyStatement;
}
declare type EntityName = Identifier | ThisExpression | TSQualifiedName;
declare interface ExportAllDeclaration extends BaseNode {
    type: AST_NODE_TYPES.ExportAllDeclaration;
    /**
     * The assertions declared for the export.
     * @example
     * ```ts
     * export * from 'mod' assert \{ type: 'json' \};
     * ```
     * @deprecated Replaced with {@link `attributes`}.
     */
    assertions: ImportAttribute[];
    /**
     * The attributes declared for the export.
     * @example
     * ```ts
     * export * from 'mod' with \{ type: 'json' \};
     * ```
     */
    attributes: ImportAttribute[];
    /**
     * The name for the exported items (`as X`). `null` if no name is assigned.
     */
    exported: Identifier | null;
    /**
     * The kind of the export.
     */
    exportKind: ExportKind;
    /**
     * The source module being exported from.
     */
    source: StringLiteral;
}
declare type ExportAndImportKind = 'type' | 'value';
declare interface ExportDefaultDeclaration extends BaseNode {
    type: AST_NODE_TYPES.ExportDefaultDeclaration;
    /**
     * The declaration being exported.
     */
    declaration: DefaultExportDeclarations;
    /**
     * The kind of the export. Always `value` for default exports.
     */
    exportKind: 'value';
}
declare type ExportKind = ExportAndImportKind;
declare type ExportNamedDeclaration = ExportNamedDeclarationWithoutSourceWithMultiple | ExportNamedDeclarationWithoutSourceWithSingle | ExportNamedDeclarationWithSource;
declare interface ExportNamedDeclarationBase extends BaseNode {
    type: AST_NODE_TYPES.ExportNamedDeclaration;
    /**
     * The assertions declared for the export.
     * @example
     * ```ts
     * export { foo } from 'mod' assert \{ type: 'json' \};
     * ```
     * This will be an empty array if `source` is `null`
     * @deprecated Replaced with {@link `attributes`}.
     */
    assertions: ImportAttribute[];
    /**
     * The attributes declared for the export.
     * @example
     * ```ts
     * export { foo } from 'mod' with \{ type: 'json' \};
     * ```
     * This will be an empty array if `source` is `null`
     */
    attributes: ImportAttribute[];
    /**
     * The exported declaration.
     * @example
     * ```ts
     * export const x = 1;
     * ```
     * This will be `null` if `source` is not `null`, or if there are `specifiers`
     */
    declaration: NamedExportDeclarations | null;
    /**
     * The kind of the export.
     */
    exportKind: ExportKind;
    /**
     * The source module being exported from.
     */
    source: StringLiteral | null;
    /**
     * The specifiers being exported.
     * @example
     * ```ts
     * export { a, b };
     * ```
     * This will be an empty array if `declaration` is not `null`
     */
    specifiers: ExportSpecifier[];
}
/**
 * Exporting names from the current module.
 * ```
 * export {};
 * export { a, b };
 * ```
 */
declare interface ExportNamedDeclarationWithoutSourceWithMultiple extends ExportNamedDeclarationBase {
    /**
     * This will always be an empty array.
     * @deprecated Replaced with {@link `attributes`}.
     */
    assertions: ImportAttribute[];
    /**
     * This will always be an empty array.
     */
    attributes: ImportAttribute[];
    declaration: null;
    source: null;
    specifiers: ExportSpecifierWithIdentifierLocal[];
}
/**
 * Exporting a single named declaration.
 * ```
 * export const x = 1;
 * ```
 */
declare interface ExportNamedDeclarationWithoutSourceWithSingle extends ExportNamedDeclarationBase {
    /**
     * This will always be an empty array.
     * @deprecated Replaced with {@link `attributes`}.
     */
    assertions: ImportAttribute[];
    /**
     * This will always be an empty array.
     */
    attributes: ImportAttribute[];
    declaration: NamedExportDeclarations;
    source: null;
    /**
     * This will always be an empty array.
     */
    specifiers: ExportSpecifierWithIdentifierLocal[];
}
/**
 * Export names from another module.
 * ```
 * export { a, b } from 'mod';
 * ```
 */
declare interface ExportNamedDeclarationWithSource extends ExportNamedDeclarationBase {
    declaration: null;
    source: StringLiteral;
}
declare type ExportSpecifier = ExportSpecifierWithIdentifierLocal | ExportSpecifierWithStringOrLiteralLocal;
declare interface ExportSpecifierBase extends BaseNode {
    type: AST_NODE_TYPES.ExportSpecifier;
    exported: Identifier | StringLiteral;
    exportKind: ExportKind;
    local: Identifier | StringLiteral;
}
declare interface ExportSpecifierWithIdentifierLocal extends ExportSpecifierBase {
    local: Identifier;
}
declare interface ExportSpecifierWithStringOrLiteralLocal extends ExportSpecifierBase {
    local: Identifier | StringLiteral;
}
declare type Expression = ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AwaitExpression | BinaryExpression | CallExpression | ChainExpression | ClassExpression | ConditionalExpression | FunctionExpression | Identifier | ImportExpression | JSXElement | JSXFragment | LiteralExpression | LogicalExpression | MemberExpression | MetaProperty | NewExpression | ObjectExpression | ObjectPattern | SequenceExpression | Super | TaggedTemplateExpression | TemplateLiteral | ThisExpression | TSAsExpression | TSInstantiationExpression | TSNonNullExpression | TSSatisfiesExpression | TSTypeAssertion | UnaryExpression | UpdateExpression | YieldExpression;
declare interface ExpressionStatement extends BaseNode {
    type: AST_NODE_TYPES.ExpressionStatement;
    directive: string | undefined;
    expression: Expression;
}
declare type ForInitialiser = Expression | LetOrConstOrVarDeclaration;
declare interface ForInStatement extends BaseNode {
    type: AST_NODE_TYPES.ForInStatement;
    body: Statement;
    left: ForInitialiser;
    right: Expression;
}
declare type ForOfInitialiser = Expression | LetOrConstOrVarDeclaration | UsingInForOfDeclaration;
declare interface ForOfStatement extends BaseNode {
    type: AST_NODE_TYPES.ForOfStatement;
    await: boolean;
    body: Statement;
    left: ForOfInitialiser;
    right: Expression;
}
declare interface ForStatement extends BaseNode {
    type: AST_NODE_TYPES.ForStatement;
    body: Statement;
    init: Expression | ForInitialiser | null;
    test: Expression | null;
    update: Expression | null;
}
declare interface FunctionBase extends BaseNode {
    /**
     * Whether the function is async:
     * ```
     * async function foo() {}
     * const x = async function () {}
     * const x = async () => {}
     * ```
     */
    async: boolean;
    /**
     * The body of the function.
     * - For an `ArrowFunctionExpression` this may be an `Expression` or `BlockStatement`.
     * - For a `FunctionDeclaration` or `FunctionExpression` this is always a `BlockStatement`.
     * - For a `TSDeclareFunction` this is always `undefined`.
     * - For a `TSEmptyBodyFunctionExpression` this is always `null`.
     */
    body: BlockStatement | Expression | null | undefined;
    /**
     * This is only `true` if and only if the node is a `TSDeclareFunction` and it has `declare`:
     * ```
     * declare function foo() {}
     * ```
     */
    declare: boolean;
    /**
     * This is only ever `true` if and only the node is an `ArrowFunctionExpression` and the body
     * is an expression:
     * ```
     * (() => 1)
     * ```
     */
    expression: boolean;
    /**
     * Whether the function is a generator function:
     * ```
     * function *foo() {}
     * const x = function *() {}
     * ```
     * This is always `false` for arrow functions as they cannot be generators.
     */
    generator: boolean;
    /**
     * The function's name.
     * - For an `ArrowFunctionExpression` this is always `null`.
     * - For a `FunctionExpression` this may be `null` if the name is omitted.
     * - For a `FunctionDeclaration` or `TSDeclareFunction` this may be `null` if
     *   and only if the parent is an `ExportDefaultDeclaration`.
     */
    id: Identifier | null;
    /**
     * The list of parameters declared for the function.
     */
    params: Parameter[];
    /**
     * The return type annotation for the function.
     */
    returnType: TSTypeAnnotation | undefined;
    /**
     * The generic type parameter declaration for the function.
     */
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare interface FunctionDeclarationBase extends FunctionBase {
    type: AST_NODE_TYPES.FunctionDeclaration;
    body: BlockStatement;
    declare: false;
    expression: false;
}
/**
 * A normal function declaration:
 * ```
 * function f() {}
 * ```
 */
declare interface FunctionDeclarationWithName extends FunctionDeclarationBase {
    id: Identifier;
}
/**
 * Default-exported function declarations have optional names:
 * ```
 * export default function () {}
 * ```
 */
declare interface FunctionDeclarationWithOptionalName extends FunctionDeclarationBase {
    id: Identifier | null;
}
declare interface FunctionExpression extends FunctionBase {
    type: AST_NODE_TYPES.FunctionExpression;
    body: BlockStatement;
    expression: false;
}
declare interface Identifier extends BaseNode {
    type: AST_NODE_TYPES.Identifier;
    decorators: Decorator[];
    name: string;
    optional: boolean;
    typeAnnotation: TSTypeAnnotation | undefined;
}
declare interface IfStatement extends BaseNode {
    type: AST_NODE_TYPES.IfStatement;
    alternate: Statement | null;
    consequent: Statement;
    test: Expression;
}
declare interface ImportAttribute extends BaseNode {
    type: AST_NODE_TYPES.ImportAttribute;
    key: Identifier | Literal;
    value: Literal;
}
declare type ImportClause = ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier;
declare interface ImportDeclaration extends BaseNode {
    type: AST_NODE_TYPES.ImportDeclaration;
    /**
     * The assertions declared for the export.
     * @example
     * ```ts
     * import * from 'mod' assert \{ type: 'json' \};
     * ```
     * @deprecated Replaced with {@link `attributes`}.
     */
    assertions: ImportAttribute[];
    /**
     * The attributes declared for the export.
     * @example
     * ```ts
     * import * from 'mod' with \{ type: 'json' \};
     * ```
     */
    attributes: ImportAttribute[];
    /**
     * The kind of the import.
     */
    importKind: ImportKind;
    /**
     * The source module being imported from.
     */
    source: StringLiteral;
    /**
     * The specifiers being imported.
     * If this is an empty array then either there are no specifiers:
     * ```
     * import {} from 'mod';
     * ```
     * Or it is a side-effect import:
     * ```
     * import 'mod';
     * ```
     */
    specifiers: ImportClause[];
}
declare interface ImportDefaultSpecifier extends BaseNode {
    type: AST_NODE_TYPES.ImportDefaultSpecifier;
    local: Identifier;
}
declare interface ImportExpression extends BaseNode {
    type: AST_NODE_TYPES.ImportExpression;
    /**
     * The attributes declared for the dynamic import.
     * @example
     * ```ts
     * import('mod', \{ assert: \{ type: 'json' \} \});
     * ```
     * @deprecated Replaced with {@link `options`}.
     */
    attributes: Expression | null;
    /**
     * The options bag declared for the dynamic import.
     * @example
     * ```ts
     * import('mod', \{ assert: \{ type: 'json' \} \});
     * ```
     */
    options: Expression | null;
    source: Expression;
}
declare type ImportKind = ExportAndImportKind;
declare interface ImportNamespaceSpecifier extends BaseNode {
    type: AST_NODE_TYPES.ImportNamespaceSpecifier;
    local: Identifier;
}
declare interface ImportSpecifier extends BaseNode {
    type: AST_NODE_TYPES.ImportSpecifier;
    imported: Identifier | StringLiteral;
    importKind: ImportKind;
    local: Identifier;
}
declare interface JSXAttribute extends BaseNode {
    type: AST_NODE_TYPES.JSXAttribute;
    name: JSXIdentifier | JSXNamespacedName;
    value: JSXElement | JSXExpression | Literal | null;
}
declare type JSXChild = JSXElement | JSXExpression | JSXFragment | JSXText;
declare interface JSXClosingElement extends BaseNode {
    type: AST_NODE_TYPES.JSXClosingElement;
    name: JSXTagNameExpression;
}
declare interface JSXClosingFragment extends BaseNode {
    type: AST_NODE_TYPES.JSXClosingFragment;
}
declare interface JSXElement extends BaseNode {
    type: AST_NODE_TYPES.JSXElement;
    children: JSXChild[];
    closingElement: JSXClosingElement | null;
    openingElement: JSXOpeningElement;
}
declare interface JSXEmptyExpression extends BaseNode {
    type: AST_NODE_TYPES.JSXEmptyExpression;
}
declare type JSXExpression = JSXExpressionContainer | JSXSpreadChild;
declare interface JSXExpressionContainer extends BaseNode {
    type: AST_NODE_TYPES.JSXExpressionContainer;
    expression: Expression | JSXEmptyExpression;
}
declare interface JSXFragment extends BaseNode {
    type: AST_NODE_TYPES.JSXFragment;
    children: JSXChild[];
    closingFragment: JSXClosingFragment;
    openingFragment: JSXOpeningFragment;
}
declare interface JSXIdentifier extends BaseNode {
    type: AST_NODE_TYPES.JSXIdentifier;
    name: string;
}
declare interface JSXMemberExpression extends BaseNode {
    type: AST_NODE_TYPES.JSXMemberExpression;
    object: JSXTagNameExpression;
    property: JSXIdentifier;
}
declare interface JSXNamespacedName extends BaseNode {
    type: AST_NODE_TYPES.JSXNamespacedName;
    name: JSXIdentifier;
    namespace: JSXIdentifier;
}
declare interface JSXOpeningElement extends BaseNode {
    type: AST_NODE_TYPES.JSXOpeningElement;
    attributes: (JSXAttribute | JSXSpreadAttribute)[];
    name: JSXTagNameExpression;
    selfClosing: boolean;
    typeArguments: TSTypeParameterInstantiation | undefined;
}
declare interface JSXOpeningFragment extends BaseNode {
    type: AST_NODE_TYPES.JSXOpeningFragment;
}
declare interface JSXSpreadAttribute extends BaseNode {
    type: AST_NODE_TYPES.JSXSpreadAttribute;
    argument: Expression;
}
declare interface JSXSpreadChild extends BaseNode {
    type: AST_NODE_TYPES.JSXSpreadChild;
    expression: Expression | JSXEmptyExpression;
}
declare type JSXTagNameExpression = JSXIdentifier | JSXMemberExpression | JSXNamespacedName;
declare interface JSXText extends BaseNode {
    type: AST_NODE_TYPES.JSXText;
    raw: string;
    value: string;
}
declare interface LabeledStatement extends BaseNode {
    type: AST_NODE_TYPES.LabeledStatement;
    body: Statement;
    label: Identifier;
}
declare type LeftHandSideExpression = ArrayExpression | ArrayPattern | ArrowFunctionExpression | CallExpression | ClassExpression | FunctionExpression | Identifier | JSXElement | JSXFragment | LiteralExpression | MemberExpression | MetaProperty | ObjectExpression | ObjectPattern | SequenceExpression | Super | TaggedTemplateExpression | ThisExpression | TSAsExpression | TSNonNullExpression | TSTypeAssertion;
declare type LetOrConstOrVarDeclaration = ConstDeclaration | LetOrVarDeclaredDeclaration | LetOrVarNonDeclaredDeclaration;
declare interface LetOrConstOrVarDeclarationBase extends BaseNode {
    type: AST_NODE_TYPES.VariableDeclaration;
    /**
     * The variables declared by this declaration.
     * Always non-empty.
     * @example
     * ```ts
     * let x;
     * let y, z;
     * ```
     */
    declarations: LetOrConstOrVarDeclarator[];
    /**
     * Whether the declaration is `declare`d
     * @example
     * ```ts
     * declare const x = 1;
     * ```
     */
    declare: boolean;
    /**
     * The keyword used to declare the variable(s)
     * @example
     * ```ts
     * const x = 1;
     * let y = 2;
     * var z = 3;
     * ```
     */
    kind: 'const' | 'let' | 'var';
}
declare type LetOrConstOrVarDeclarator = VariableDeclaratorDefiniteAssignment | VariableDeclaratorMaybeInit | VariableDeclaratorNoInit;
declare interface LetOrVarDeclaredDeclaration extends LetOrConstOrVarDeclarationBase {
    /**
     * In a `declare let` declaration, the declarators must not have definite assignment
     * assertions or initializers.
     *
     * @example
     * ```ts
     * using x = 1;
     * using y =1, z = 2;
     * ```
     */
    declarations: VariableDeclaratorNoInit[];
    declare: true;
    kind: 'let' | 'var';
}
declare interface LetOrVarNonDeclaredDeclaration extends LetOrConstOrVarDeclarationBase {
    /**
     * In a `let`/`var` declaration, the declarators may have definite assignment
     * assertions or initializers, but not both.
     */
    declarations: (VariableDeclaratorDefiniteAssignment | VariableDeclaratorMaybeInit)[];
    declare: false;
    kind: 'let' | 'var';
}
declare type Literal = BigIntLiteral | BooleanLiteral | NullLiteral | NumberLiteral | RegExpLiteral | StringLiteral;
declare interface LiteralBase extends BaseNode {
    type: AST_NODE_TYPES.Literal;
    raw: string;
    value: bigint | boolean | number | string | RegExp | null;
}
declare type LiteralExpression = Literal | TemplateLiteral;
declare interface LogicalExpression extends BaseNode {
    type: AST_NODE_TYPES.LogicalExpression;
    left: Expression;
    operator: '&&' | '??' | '||';
    right: Expression;
}
declare type MemberExpression = MemberExpressionComputedName | MemberExpressionNonComputedName;
declare interface MemberExpressionBase extends BaseNode {
    computed: boolean;
    object: Expression;
    optional: boolean;
    property: Expression | Identifier | PrivateIdentifier;
}
declare interface MemberExpressionComputedName extends MemberExpressionBase {
    type: AST_NODE_TYPES.MemberExpression;
    computed: true;
    property: Expression;
}
declare interface MemberExpressionNonComputedName extends MemberExpressionBase {
    type: AST_NODE_TYPES.MemberExpression;
    computed: false;
    property: Identifier | PrivateIdentifier;
}
declare interface MetaProperty extends BaseNode {
    type: AST_NODE_TYPES.MetaProperty;
    meta: Identifier;
    property: Identifier;
}
declare type MethodDefinition = MethodDefinitionComputedName | MethodDefinitionNonComputedName;
/** this should not be directly used - instead use MethodDefinitionComputedNameBase or MethodDefinitionNonComputedNameBase */
declare interface MethodDefinitionBase extends BaseNode {
    accessibility: Accessibility | undefined;
    computed: boolean;
    decorators: Decorator[];
    key: PropertyName;
    kind: 'constructor' | 'get' | 'method' | 'set';
    optional: boolean;
    override: boolean;
    static: boolean;
    value: FunctionExpression | TSEmptyBodyFunctionExpression;
}
declare interface MethodDefinitionComputedName extends MethodDefinitionComputedNameBase {
    type: AST_NODE_TYPES.MethodDefinition;
}
declare interface MethodDefinitionComputedNameBase extends MethodDefinitionBase {
    computed: true;
    key: PropertyNameComputed;
}
declare interface MethodDefinitionNonComputedName extends ClassMethodDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.MethodDefinition;
}
declare interface MethodDefinitionNonComputedNameBase extends MethodDefinitionBase {
    computed: false;
    key: PropertyNameNonComputed;
}
declare type NamedExportDeclarations = ClassDeclarationWithName | ClassDeclarationWithOptionalName | FunctionDeclarationWithName | FunctionDeclarationWithOptionalName | TSDeclareFunction | TSEnumDeclaration | TSImportEqualsDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSTypeAliasDeclaration | VariableDeclaration;
declare interface NewExpression extends BaseNode {
    type: AST_NODE_TYPES.NewExpression;
    arguments: CallExpressionArgument[];
    callee: Expression;
    typeArguments: TSTypeParameterInstantiation | undefined;
}
declare interface NodeOrTokenData {
    type: string;
    /**
     * The source location information of the node.
     *
     * The loc property is defined as nullable by ESTree, but ESLint requires this property.
     */
    loc: SourceLocation;
    range: Range;
}
declare interface NullLiteral extends LiteralBase {
    raw: 'null';
    value: null;
}
declare interface NumberLiteral extends LiteralBase {
    value: number;
}
declare interface ObjectExpression extends BaseNode {
    type: AST_NODE_TYPES.ObjectExpression;
    properties: ObjectLiteralElement[];
}
declare type ObjectLiteralElement = Property | SpreadElement;
declare interface ObjectPattern extends BaseNode {
    type: AST_NODE_TYPES.ObjectPattern;
    decorators: Decorator[];
    optional: boolean;
    properties: (Property | RestElement)[];
    typeAnnotation: TSTypeAnnotation | undefined;
}
declare type Parameter = ArrayPattern | AssignmentPattern | Identifier | ObjectPattern | RestElement | TSParameterProperty;
declare interface Position {
    /**
     * Column number on the line (0-indexed)
     */
    column: number;
    /**
     * Line number (1-indexed)
     */
    line: number;
}
declare interface PrivateIdentifier extends BaseNode {
    type: AST_NODE_TYPES.PrivateIdentifier;
    name: string;
}
declare type ProgramStatement = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration | Statement | TSImportEqualsDeclaration | TSNamespaceExportDeclaration;
declare type Property = PropertyComputedName | PropertyNonComputedName;
declare interface PropertyBase extends BaseNode {
    type: AST_NODE_TYPES.Property;
    computed: boolean;
    key: PropertyName;
    kind: 'get' | 'init' | 'set';
    method: boolean;
    optional: boolean;
    shorthand: boolean;
    value: AssignmentPattern | BindingName | Expression | TSEmptyBodyFunctionExpression;
}
declare interface PropertyComputedName extends PropertyBase {
    computed: true;
    key: PropertyNameComputed;
}
declare type PropertyDefinition = PropertyDefinitionComputedName | PropertyDefinitionNonComputedName;
declare interface PropertyDefinitionBase extends BaseNode {
    accessibility: Accessibility | undefined;
    computed: boolean;
    declare: boolean;
    decorators: Decorator[];
    definite: boolean;
    key: PropertyName;
    optional: boolean;
    override: boolean;
    readonly: boolean;
    static: boolean;
    typeAnnotation: TSTypeAnnotation | undefined;
    value: Expression | null;
}
declare interface PropertyDefinitionComputedName extends PropertyDefinitionComputedNameBase {
    type: AST_NODE_TYPES.PropertyDefinition;
}
declare interface PropertyDefinitionComputedNameBase extends PropertyDefinitionBase {
    computed: true;
    key: PropertyNameComputed;
}
declare interface PropertyDefinitionNonComputedName extends ClassPropertyDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.PropertyDefinition;
}
declare interface PropertyDefinitionNonComputedNameBase extends PropertyDefinitionBase {
    computed: false;
    key: PropertyNameNonComputed;
}
declare type PropertyName = ClassPropertyNameNonComputed | PropertyNameComputed | PropertyNameNonComputed;
declare type PropertyNameComputed = Expression;
declare type PropertyNameNonComputed = Identifier | NumberLiteral | StringLiteral;
declare interface PropertyNonComputedName extends PropertyBase {
    computed: false;
    key: PropertyNameNonComputed;
}
/**
 * An array of two numbers.
 * Both numbers are a 0-based index which is the position in the array of source code characters.
 * The first is the start position of the node, the second is the end position of the node.
 */
declare type Range = [number, number];
declare interface RegExpLiteral extends LiteralBase {
    regex: {
        flags: string;
        pattern: string;
    };
    value: RegExp | null;
}
declare interface RestElement extends BaseNode {
    type: AST_NODE_TYPES.RestElement;
    argument: DestructuringPattern;
    decorators: Decorator[];
    optional: boolean;
    typeAnnotation: TSTypeAnnotation | undefined;
    value: AssignmentPattern | undefined;
}
declare interface ReturnStatement extends BaseNode {
    type: AST_NODE_TYPES.ReturnStatement;
    argument: Expression | null;
}
declare interface SequenceExpression extends BaseNode {
    type: AST_NODE_TYPES.SequenceExpression;
    expressions: Expression[];
}
declare interface SourceLocation {
    /**
     * The position of the first character after the parsed source region
     */
    end: Position;
    /**
     * The position of the first character of the parsed source region
     */
    start: Position;
}
declare interface SpreadElement extends BaseNode {
    type: AST_NODE_TYPES.SpreadElement;
    argument: Expression;
}
declare type Statement = BlockStatement | BreakStatement | ClassDeclarationWithName | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclarationWithName | IfStatement | ImportDeclaration | LabeledStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | TSDeclareFunction | TSEnumDeclaration | TSExportAssignment | TSImportEqualsDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSNamespaceExportDeclaration | TSTypeAliasDeclaration | VariableDeclaration | WhileStatement | WithStatement;
declare interface StaticBlock extends BaseNode {
    type: AST_NODE_TYPES.StaticBlock;
    body: Statement[];
}
declare interface StringLiteral extends LiteralBase {
    value: string;
}
declare interface Super extends BaseNode {
    type: AST_NODE_TYPES.Super;
}
declare interface SwitchCase extends BaseNode {
    type: AST_NODE_TYPES.SwitchCase;
    consequent: Statement[];
    test: Expression | null;
}
declare interface SwitchStatement extends BaseNode {
    type: AST_NODE_TYPES.SwitchStatement;
    cases: SwitchCase[];
    discriminant: Expression;
}
declare interface TaggedTemplateExpression extends BaseNode {
    type: AST_NODE_TYPES.TaggedTemplateExpression;
    quasi: TemplateLiteral;
    tag: Expression;
    typeArguments: TSTypeParameterInstantiation | undefined;
}
declare interface TemplateElement extends BaseNode {
    type: AST_NODE_TYPES.TemplateElement;
    tail: boolean;
    value: {
        cooked: string;
        raw: string;
    };
}
declare interface TemplateLiteral extends BaseNode {
    type: AST_NODE_TYPES.TemplateLiteral;
    expressions: Expression[];
    quasis: TemplateElement[];
}
declare interface ThisExpression extends BaseNode {
    type: AST_NODE_TYPES.ThisExpression;
}
declare interface ThrowStatement extends BaseNode {
    type: AST_NODE_TYPES.ThrowStatement;
    argument: Expression;
}
declare interface TryStatement extends BaseNode {
    type: AST_NODE_TYPES.TryStatement;
    block: BlockStatement;
    finalizer: BlockStatement | null;
    handler: CatchClause | null;
}
declare type TSAbstractAccessorProperty = TSAbstractAccessorPropertyComputedName | TSAbstractAccessorPropertyNonComputedName;
declare interface TSAbstractAccessorPropertyComputedName extends PropertyDefinitionComputedNameBase {
    type: AST_NODE_TYPES.TSAbstractAccessorProperty;
    value: null;
}
declare interface TSAbstractAccessorPropertyNonComputedName extends PropertyDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.TSAbstractAccessorProperty;
    value: null;
}
declare interface TSAbstractKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSAbstractKeyword;
}
declare type TSAbstractMethodDefinition = TSAbstractMethodDefinitionComputedName | TSAbstractMethodDefinitionNonComputedName;
declare interface TSAbstractMethodDefinitionComputedName extends MethodDefinitionComputedNameBase {
    type: AST_NODE_TYPES.TSAbstractMethodDefinition;
}
declare interface TSAbstractMethodDefinitionNonComputedName extends MethodDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.TSAbstractMethodDefinition;
}
declare type TSAbstractPropertyDefinition = TSAbstractPropertyDefinitionComputedName | TSAbstractPropertyDefinitionNonComputedName;
declare interface TSAbstractPropertyDefinitionComputedName extends PropertyDefinitionComputedNameBase {
    type: AST_NODE_TYPES.TSAbstractPropertyDefinition;
    value: null;
}
declare interface TSAbstractPropertyDefinitionNonComputedName extends PropertyDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.TSAbstractPropertyDefinition;
    value: null;
}
declare interface TSAnyKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSAnyKeyword;
}
declare interface TSArrayType extends BaseNode {
    type: AST_NODE_TYPES.TSArrayType;
    elementType: TypeNode;
}
declare interface TSAsExpression extends BaseNode {
    type: AST_NODE_TYPES.TSAsExpression;
    expression: Expression;
    typeAnnotation: TypeNode;
}
declare interface TSAsyncKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSAsyncKeyword;
}
declare interface TSBigIntKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSBigIntKeyword;
}
declare interface TSBooleanKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSBooleanKeyword;
}
declare interface TSCallSignatureDeclaration extends TSFunctionSignatureBase {
    type: AST_NODE_TYPES.TSCallSignatureDeclaration;
}
declare interface TSClassImplements extends TSHeritageBase {
    type: AST_NODE_TYPES.TSClassImplements;
}
declare interface TSConditionalType extends BaseNode {
    type: AST_NODE_TYPES.TSConditionalType;
    checkType: TypeNode;
    extendsType: TypeNode;
    falseType: TypeNode;
    trueType: TypeNode;
}
declare interface TSConstructorType extends TSFunctionSignatureBase {
    type: AST_NODE_TYPES.TSConstructorType;
    abstract: boolean;
}
declare interface TSConstructSignatureDeclaration extends TSFunctionSignatureBase {
    type: AST_NODE_TYPES.TSConstructSignatureDeclaration;
}
declare type TSDeclareFunction = TSDeclareFunctionNoDeclare | TSDeclareFunctionWithDeclare;
declare interface TSDeclareFunctionBase extends FunctionBase {
    type: AST_NODE_TYPES.TSDeclareFunction;
    /**
     * TS1183: An implementation cannot be declared in ambient contexts.
     */
    body: undefined;
    /**
     * Whether the declaration has `declare` modifier.
     */
    declare: boolean;
    expression: false;
}
/**
 * Function declaration without the `declare` keyword:
 * ```
 * function foo(): void;
 * ```
 * This can either be an overload signature or a declaration in an ambient context
 * (e.g. `declare module`)
 */
declare interface TSDeclareFunctionNoDeclare extends TSDeclareFunctionBase {
    declare: false;
    /**
     * - TS1221: Generators are not allowed in an ambient context.
     * - TS1222: An overload signature cannot be declared as a generator.
     */
    generator: false;
}
/**
 * Function declaration with the `declare` keyword:
 * ```
 * declare function foo(): void;
 * ```
 */
declare interface TSDeclareFunctionWithDeclare extends TSDeclareFunctionBase {
    /**
     * TS1040: 'async' modifier cannot be used in an ambient context.
     */
    async: false;
    declare: true;
    /**
     * TS1221: Generators are not allowed in an ambient context.
     */
    generator: false;
}
declare interface TSDeclareKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSDeclareKeyword;
}
declare interface TSEmptyBodyFunctionExpression extends FunctionBase {
    type: AST_NODE_TYPES.TSEmptyBodyFunctionExpression;
    body: null;
    id: null;
}
declare interface TSEnumBody extends BaseNode {
    type: AST_NODE_TYPES.TSEnumBody;
    members: TSEnumMember[];
}
declare interface TSEnumDeclaration extends BaseNode {
    type: AST_NODE_TYPES.TSEnumDeclaration;
    /**
     * The body of the enum.
     */
    body: TSEnumBody;
    /**
     * Whether this is a `const` enum.
     * @example
     * ```ts
     * const enum Foo {}
     * ```
     */
    const: boolean;
    /**
     * Whether this is a `declare`d enum.
     * @example
     * ```ts
     * declare enum Foo {}
     * ```
     */
    declare: boolean;
    /**
     * The enum name.
     */
    id: Identifier;
    /**
     * The enum members.
     * @deprecated Use {@link body} instead.
     */
    members: TSEnumMember[];
}
declare type TSEnumMember = TSEnumMemberComputedName | TSEnumMemberNonComputedName;
declare interface TSEnumMemberBase extends BaseNode {
    type: AST_NODE_TYPES.TSEnumMember;
    computed: boolean;
    id: PropertyNameComputed | PropertyNameNonComputed;
    initializer: Expression | undefined;
}
/**
 * this should only really happen in semantically invalid code (errors 1164 and 2452)
 *
 * @example
 * ```ts
 * // VALID:
 * enum Foo { ['a'] }
 *
 * // INVALID:
 * const x = 'a';
 * enum Foo { [x] }
 * enum Bar { ['a' + 'b'] }
 * ```
 */
declare interface TSEnumMemberComputedName extends TSEnumMemberBase {
    computed: true;
    id: PropertyNameComputed;
}
declare interface TSEnumMemberNonComputedName extends TSEnumMemberBase {
    computed: false;
    id: PropertyNameNonComputed;
}
declare interface TSExportAssignment extends BaseNode {
    type: AST_NODE_TYPES.TSExportAssignment;
    expression: Expression;
}
declare interface TSExportKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSExportKeyword;
}
declare interface TSExternalModuleReference extends BaseNode {
    type: AST_NODE_TYPES.TSExternalModuleReference;
    expression: StringLiteral;
}
declare interface TSFunctionSignatureBase extends BaseNode {
    params: Parameter[];
    returnType: TSTypeAnnotation | undefined;
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare interface TSFunctionType extends TSFunctionSignatureBase {
    type: AST_NODE_TYPES.TSFunctionType;
}
declare interface TSHeritageBase extends BaseNode {
    expression: Expression;
    typeArguments: TSTypeParameterInstantiation | undefined;
}
declare type TSImportEqualsDeclaration = TSImportEqualsNamespaceDeclaration | TSImportEqualsRequireDeclaration;
declare interface TSImportEqualsDeclarationBase extends BaseNode {
    type: AST_NODE_TYPES.TSImportEqualsDeclaration;
    /**
     * The locally imported name.
     */
    id: Identifier;
    /**
     * The kind of the import. Always `'value'` unless `moduleReference` is a
     * `TSExternalModuleReference`.
     */
    importKind: ImportKind;
    /**
     * The value being aliased.
     * @example
     * ```ts
     * import F1 = A;
     * import F2 = A.B.C;
     * import F3 = require('mod');
     * ```
     */
    moduleReference: Identifier | TSExternalModuleReference | TSQualifiedName;
}
declare interface TSImportEqualsNamespaceDeclaration extends TSImportEqualsDeclarationBase {
    /**
     * The kind of the import.
     */
    importKind: 'value';
    /**
     * The value being aliased.
     * ```
     * import F1 = A;
     * import F2 = A.B.C;
     * ```
     */
    moduleReference: Identifier | TSQualifiedName;
}
declare interface TSImportEqualsRequireDeclaration extends TSImportEqualsDeclarationBase {
    /**
     * The kind of the import.
     */
    importKind: ImportKind;
    /**
     * The value being aliased.
     * ```
     * import F3 = require('mod');
     * ```
     */
    moduleReference: TSExternalModuleReference;
}
declare interface TSImportType extends BaseNode {
    type: AST_NODE_TYPES.TSImportType;
    argument: TypeNode;
    qualifier: EntityName | null;
    typeArguments: TSTypeParameterInstantiation | null;
}
declare interface TSIndexedAccessType extends BaseNode {
    type: AST_NODE_TYPES.TSIndexedAccessType;
    indexType: TypeNode;
    objectType: TypeNode;
}
declare interface TSIndexSignature extends BaseNode {
    type: AST_NODE_TYPES.TSIndexSignature;
    accessibility: Accessibility | undefined;
    parameters: Parameter[];
    readonly: boolean;
    static: boolean;
    typeAnnotation: TSTypeAnnotation | undefined;
}
declare interface TSInferType extends BaseNode {
    type: AST_NODE_TYPES.TSInferType;
    typeParameter: TSTypeParameter;
}
declare interface TSInstantiationExpression extends BaseNode {
    type: AST_NODE_TYPES.TSInstantiationExpression;
    expression: Expression;
    typeArguments: TSTypeParameterInstantiation;
}
declare interface TSInterfaceBody extends BaseNode {
    type: AST_NODE_TYPES.TSInterfaceBody;
    body: TypeElement[];
}
declare interface TSInterfaceDeclaration extends BaseNode {
    type: AST_NODE_TYPES.TSInterfaceDeclaration;
    /**
     * The body of the interface
     */
    body: TSInterfaceBody;
    /**
     * Whether the interface was `declare`d
     */
    declare: boolean;
    /**
     * The types this interface `extends`
     */
    extends: TSInterfaceHeritage[];
    /**
     * The name of this interface
     */
    id: Identifier;
    /**
     * The generic type parameters declared for the interface. Empty declaration
     * (`<>`) is different from no declaration.
     */
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare interface TSInterfaceHeritage extends TSHeritageBase {
    type: AST_NODE_TYPES.TSInterfaceHeritage;
}
declare interface TSIntersectionType extends BaseNode {
    type: AST_NODE_TYPES.TSIntersectionType;
    types: TypeNode[];
}
declare interface TSIntrinsicKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSIntrinsicKeyword;
}
declare interface TSLiteralType extends BaseNode {
    type: AST_NODE_TYPES.TSLiteralType;
    literal: LiteralExpression | UnaryExpression | UpdateExpression;
}
declare interface TSMappedType extends BaseNode {
    type: AST_NODE_TYPES.TSMappedType;
    constraint: TypeNode;
    key: Identifier;
    nameType: TypeNode | null;
    optional: boolean | '+' | '-' | undefined;
    readonly: boolean | '+' | '-' | undefined;
    typeAnnotation: TypeNode | undefined;
    /** @deprecated Use {@link `constraint`} and {@link `key`} instead. */
    typeParameter: TSTypeParameter;
}
declare type TSMethodSignature = TSMethodSignatureComputedName | TSMethodSignatureNonComputedName;
declare interface TSMethodSignatureBase extends BaseNode {
    type: AST_NODE_TYPES.TSMethodSignature;
    accessibility: Accessibility | undefined;
    computed: boolean;
    key: PropertyName;
    kind: 'get' | 'method' | 'set';
    optional: boolean;
    params: Parameter[];
    readonly: boolean;
    returnType: TSTypeAnnotation | undefined;
    static: boolean;
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare interface TSMethodSignatureComputedName extends TSMethodSignatureBase {
    computed: true;
    key: PropertyNameComputed;
}
declare interface TSMethodSignatureNonComputedName extends TSMethodSignatureBase {
    computed: false;
    key: PropertyNameNonComputed;
}
declare interface TSModuleBlock extends BaseNode {
    type: AST_NODE_TYPES.TSModuleBlock;
    body: ProgramStatement[];
}
declare type TSModuleDeclaration = TSModuleDeclarationGlobal | TSModuleDeclarationModule | TSModuleDeclarationNamespace;
declare interface TSModuleDeclarationBase extends BaseNode {
    type: AST_NODE_TYPES.TSModuleDeclaration;
    /**
     * The body of the module.
     * This can only be `undefined` for the code `declare module 'mod';`
     */
    body?: TSModuleBlock;
    /**
     * Whether the module is `declare`d
     * @example
     * ```ts
     * declare namespace F {}
     * ```
     */
    declare: boolean;
    /**
     * Whether this is a global declaration
     * @example
     * ```ts
     * declare global {}
     * ```
     *
     * @deprecated Use {@link kind} instead
     */
    global: boolean;
    /**
     * The name of the module
     * ```
     * namespace A {}
     * namespace A.B.C {}
     * module 'a' {}
     * ```
     */
    id: Identifier | Literal | TSQualifiedName;
    /**
     * The keyword used to define this module declaration
     * @example
     * ```ts
     * namespace Foo {}
     * ^^^^^^^^^
     *
     * module 'foo' {}
     * ^^^^^^
     *
     * global {}
     * ^^^^^^
     * ```
     */
    kind: TSModuleDeclarationKind;
}
declare interface TSModuleDeclarationGlobal extends TSModuleDeclarationBase {
    body: TSModuleBlock;
    /**
     * This will always be an Identifier with name `global`
     */
    id: Identifier;
    kind: 'global';
}
declare type TSModuleDeclarationKind = 'global' | 'module' | 'namespace';
declare type TSModuleDeclarationModule = TSModuleDeclarationModuleWithIdentifierId | TSModuleDeclarationModuleWithStringId;
declare interface TSModuleDeclarationModuleBase extends TSModuleDeclarationBase {
    kind: 'module';
}
/**
 * The legacy module declaration, replaced with namespace declarations.
 * ```
 * module A {}
 * ```
 */
declare interface TSModuleDeclarationModuleWithIdentifierId extends TSModuleDeclarationModuleBase {
    body: TSModuleBlock;
    id: Identifier;
    kind: 'module';
}
declare type TSModuleDeclarationModuleWithStringId = TSModuleDeclarationModuleWithStringIdDeclared | TSModuleDeclarationModuleWithStringIdNotDeclared;
/**
 * A string module declaration that is declared:
 * ```
 * declare module 'foo' {}
 * declare module 'foo';
 * ```
 */
declare interface TSModuleDeclarationModuleWithStringIdDeclared extends TSModuleDeclarationModuleBase {
    body?: TSModuleBlock;
    declare: true;
    id: StringLiteral;
    kind: 'module';
}
/**
 * A string module declaration that is not declared:
 * ```
 * module 'foo' {}
 * ```
 */
declare interface TSModuleDeclarationModuleWithStringIdNotDeclared extends TSModuleDeclarationModuleBase {
    body: TSModuleBlock;
    declare: false;
    id: StringLiteral;
    kind: 'module';
}
declare interface TSModuleDeclarationNamespace extends TSModuleDeclarationBase {
    body: TSModuleBlock;
    id: Identifier | TSQualifiedName;
    kind: 'namespace';
}
declare interface TSNamedTupleMember extends BaseNode {
    type: AST_NODE_TYPES.TSNamedTupleMember;
    elementType: TypeNode;
    label: Identifier;
    optional: boolean;
}
/**
 * For the following declaration:
 * ```
 * export as namespace X;
 * ```
 */
declare interface TSNamespaceExportDeclaration extends BaseNode {
    type: AST_NODE_TYPES.TSNamespaceExportDeclaration;
    /**
     * The name of the global variable that's exported as namespace
     */
    id: Identifier;
}
declare interface TSNeverKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSNeverKeyword;
}
declare interface TSNonNullExpression extends BaseNode {
    type: AST_NODE_TYPES.TSNonNullExpression;
    expression: Expression;
}
declare interface TSNullKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSNullKeyword;
}
declare interface TSNumberKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSNumberKeyword;
}
declare interface TSObjectKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSObjectKeyword;
}
declare interface TSOptionalType extends BaseNode {
    type: AST_NODE_TYPES.TSOptionalType;
    typeAnnotation: TypeNode;
}
declare interface TSParameterProperty extends BaseNode {
    type: AST_NODE_TYPES.TSParameterProperty;
    accessibility: Accessibility | undefined;
    decorators: Decorator[];
    override: boolean;
    parameter: AssignmentPattern | BindingName | RestElement;
    readonly: boolean;
    static: boolean;
}
declare interface TSPrivateKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSPrivateKeyword;
}
declare type TSPropertySignature = TSPropertySignatureComputedName | TSPropertySignatureNonComputedName;
declare interface TSPropertySignatureBase extends BaseNode {
    type: AST_NODE_TYPES.TSPropertySignature;
    accessibility: Accessibility | undefined;
    computed: boolean;
    key: PropertyName;
    optional: boolean;
    readonly: boolean;
    static: boolean;
    typeAnnotation: TSTypeAnnotation | undefined;
}
declare interface TSPropertySignatureComputedName extends TSPropertySignatureBase {
    computed: true;
    key: PropertyNameComputed;
}
declare interface TSPropertySignatureNonComputedName extends TSPropertySignatureBase {
    computed: false;
    key: PropertyNameNonComputed;
}
declare interface TSProtectedKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSProtectedKeyword;
}
declare interface TSPublicKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSPublicKeyword;
}
declare interface TSQualifiedName extends BaseNode {
    type: AST_NODE_TYPES.TSQualifiedName;
    left: EntityName;
    right: Identifier;
}
declare interface TSReadonlyKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSReadonlyKeyword;
}
declare interface TSRestType extends BaseNode {
    type: AST_NODE_TYPES.TSRestType;
    typeAnnotation: TypeNode;
}
declare interface TSSatisfiesExpression extends BaseNode {
    type: AST_NODE_TYPES.TSSatisfiesExpression;
    expression: Expression;
    typeAnnotation: TypeNode;
}
declare interface TSStaticKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSStaticKeyword;
}
declare interface TSStringKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSStringKeyword;
}
declare interface TSSymbolKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSSymbolKeyword;
}
declare interface TSTemplateLiteralType extends BaseNode {
    type: AST_NODE_TYPES.TSTemplateLiteralType;
    quasis: TemplateElement[];
    types: TypeNode[];
}
declare interface TSThisType extends BaseNode {
    type: AST_NODE_TYPES.TSThisType;
}
declare interface TSTupleType extends BaseNode {
    type: AST_NODE_TYPES.TSTupleType;
    elementTypes: TypeNode[];
}
declare interface TSTypeAliasDeclaration extends BaseNode {
    type: AST_NODE_TYPES.TSTypeAliasDeclaration;
    /**
     * Whether the type was `declare`d.
     * @example
     * ```ts
     * declare type T = 1;
     * ```
     */
    declare: boolean;
    /**
     * The name of the type.
     */
    id: Identifier;
    /**
     * The "value" (type) of the declaration
     */
    typeAnnotation: TypeNode;
    /**
     * The generic type parameters declared for the type. Empty declaration
     * (`<>`) is different from no declaration.
     */
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare interface TSTypeAnnotation extends BaseNode {
    type: AST_NODE_TYPES.TSTypeAnnotation;
    typeAnnotation: TypeNode;
}
declare interface TSTypeAssertion extends BaseNode {
    type: AST_NODE_TYPES.TSTypeAssertion;
    expression: Expression;
    typeAnnotation: TypeNode;
}
declare interface TSTypeLiteral extends BaseNode {
    type: AST_NODE_TYPES.TSTypeLiteral;
    members: TypeElement[];
}
declare interface TSTypeOperator extends BaseNode {
    type: AST_NODE_TYPES.TSTypeOperator;
    operator: 'keyof' | 'readonly' | 'unique';
    typeAnnotation: TypeNode | undefined;
}
declare interface TSTypeParameter extends BaseNode {
    type: AST_NODE_TYPES.TSTypeParameter;
    const: boolean;
    constraint: TypeNode | undefined;
    default: TypeNode | undefined;
    in: boolean;
    name: Identifier;
    out: boolean;
}
declare interface TSTypeParameterDeclaration extends BaseNode {
    type: AST_NODE_TYPES.TSTypeParameterDeclaration;
    params: TSTypeParameter[];
}
declare interface TSTypeParameterInstantiation extends BaseNode {
    type: AST_NODE_TYPES.TSTypeParameterInstantiation;
    params: TypeNode[];
}
declare interface TSTypePredicate extends BaseNode {
    type: AST_NODE_TYPES.TSTypePredicate;
    asserts: boolean;
    parameterName: Identifier | TSThisType;
    typeAnnotation: TSTypeAnnotation | null;
}
declare interface TSTypeQuery extends BaseNode {
    type: AST_NODE_TYPES.TSTypeQuery;
    exprName: EntityName | TSImportType;
    typeArguments: TSTypeParameterInstantiation | undefined;
}
declare interface TSTypeReference extends BaseNode {
    type: AST_NODE_TYPES.TSTypeReference;
    typeArguments: TSTypeParameterInstantiation | undefined;
    typeName: EntityName;
}
declare interface TSUndefinedKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSUndefinedKeyword;
}
declare interface TSUnionType extends BaseNode {
    type: AST_NODE_TYPES.TSUnionType;
    types: TypeNode[];
}
declare interface TSUnknownKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSUnknownKeyword;
}
declare interface TSVoidKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSVoidKeyword;
}
declare type TypeElement = TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSIndexSignature | TSMethodSignature | TSPropertySignature;
declare type TypeNode = TSAbstractKeyword | TSAnyKeyword | TSArrayType | TSAsyncKeyword | TSBigIntKeyword | TSBooleanKeyword | TSConditionalType | TSConstructorType | TSDeclareKeyword | TSExportKeyword | TSFunctionType | TSImportType | TSIndexedAccessType | TSInferType | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSNamedTupleMember | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSPrivateKeyword | TSProtectedKeyword | TSPublicKeyword | TSQualifiedName | TSReadonlyKeyword | TSRestType | TSStaticKeyword | TSStringKeyword | TSSymbolKeyword | TSTemplateLiteralType | TSThisType | TSTupleType | TSTypeLiteral | TSTypeOperator | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword;
declare interface UnaryExpression extends UnaryExpressionBase {
    type: AST_NODE_TYPES.UnaryExpression;
    operator: '!' | '+' | '~' | '-' | 'delete' | 'typeof' | 'void';
}
declare interface UnaryExpressionBase extends BaseNode {
    argument: Expression;
    operator: string;
    prefix: boolean;
}
declare interface UpdateExpression extends UnaryExpressionBase {
    type: AST_NODE_TYPES.UpdateExpression;
    operator: '++' | '--';
}
declare type UsingDeclaration = UsingInForOfDeclaration | UsingInNormalContextDeclaration;
declare interface UsingDeclarationBase extends BaseNode {
    type: AST_NODE_TYPES.VariableDeclaration;
    /**
     * This value will always be `false`
     * because 'declare' modifier cannot appear on a 'using' declaration.
     */
    declare: false;
    /**
     * The keyword used to declare the variable(s)
     * @example
     * ```ts
     * using x = 1;
     * await using y = 2;
     * ```
     */
    kind: 'await using' | 'using';
}
declare interface UsingInForOfDeclaration extends UsingDeclarationBase {
    /**
     * The variables declared by this declaration.
     * Always has exactly one element.
     * @example
     * ```ts
     * for (using x of y) {}
     * ```
     */
    declarations: [UsingInForOfDeclarator];
}
declare interface UsingInForOfDeclarator extends VariableDeclaratorBase {
    definite: false;
    id: Identifier;
    init: null;
}
declare interface UsingInNormalContextDeclaration extends UsingDeclarationBase {
    /**
     * The variables declared by this declaration.
     * Always non-empty.
     * @example
     * ```ts
     * using x = 1;
     * using y = 1, z = 2;
     * ```
     */
    declarations: UsingInNormalContextDeclarator[];
}
declare interface UsingInNormalContextDeclarator extends VariableDeclaratorBase {
    definite: false;
    id: Identifier;
    init: Expression;
}
declare type ValueOf<T> = T[keyof T];
declare type VariableDeclaration = LetOrConstOrVarDeclaration | UsingDeclaration;
declare interface VariableDeclaratorBase extends BaseNode {
    type: AST_NODE_TYPES.VariableDeclarator;
    /**
     * Whether there's definite assignment assertion (`let x!: number`).
     * If `true`, then: `id` must be an identifier with a type annotation,
     * `init` must be `null`, and the declarator must be a `var`/`let` declarator.
     */
    definite: boolean;
    /**
     * The name(s) of the variable(s).
     */
    id: BindingName;
    /**
     * The initializer expression of the variable. Must be present for `const` unless
     * in a `declare const`.
     */
    init: Expression | null;
}
declare interface VariableDeclaratorDefiniteAssignment extends VariableDeclaratorBase {
    definite: true;
    /**
     * The name of the variable. Must have a type annotation.
     */
    id: Identifier;
    init: null;
}
declare interface VariableDeclaratorMaybeInit extends VariableDeclaratorBase {
    definite: false;
}
declare interface VariableDeclaratorNoInit extends VariableDeclaratorBase {
    definite: false;
    init: null;
}
declare interface WhileStatement extends BaseNode {
    type: AST_NODE_TYPES.WhileStatement;
    body: Statement;
    test: Expression;
}
declare interface WithStatement extends BaseNode {
    type: AST_NODE_TYPES.WithStatement;
    body: Statement;
    object: Expression;
}
declare interface YieldExpression extends BaseNode {
    type: AST_NODE_TYPES.YieldExpression;
    argument: Expression | undefined;
    delegate: boolean;
}

declare function isReactAPIWithName(name: string): ReturnType<typeof isFromReact>;
declare function isReactAPIWithName(name: string, member: string): ReturnType<typeof isFromReactMember>;
declare function isReactAPICallWithName(name: string): ReturnType<typeof isCallFromReact>;
declare function isReactAPICallWithName(name: string, member: string): ReturnType<typeof isCallFromReactMember>;
declare const isChildrenCount: (node: MemberExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isChildrenForEach: (node: MemberExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isChildrenMap: (node: MemberExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isChildrenOnly: (node: MemberExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isChildrenToArray: (node: MemberExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isCloneElement: (node: Identifier | MemberExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isCreateContext: (node: Identifier | MemberExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isCreateElement: (node: Identifier | MemberExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isCreateRef: (node: Identifier | MemberExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isForwardRef: (node: Identifier | MemberExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isMemo: (node: Identifier | MemberExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isChildrenCountCall: (node: CallExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isChildrenForEachCall: (node: CallExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isChildrenMapCall: (node: CallExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isChildrenOnlyCall: (node: CallExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isChildrenToArrayCall: (node: CallExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isCloneElementCall: (node: CallExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isCreateContextCall: (node: CallExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isCreateElementCall: (node: CallExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isCreateRefCall: (node: CallExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isForwardRefCall: (node: CallExpression, context: _eslint_react_types.RuleContext) => boolean;
declare const isMemoCall: (node: CallExpression, context: _eslint_react_types.RuleContext) => boolean;

export { DEFAULT_COMPONENT_HINT, type ERClassComponent, ERClassComponentFlag, type ERComponent, ERComponentHint, type ERComponentKind, type EREffectKind, type EREffectMethodKind, type EREffectPhaseKind, type ERFunctionComponent, ERFunctionComponentFlag, type ERHook, type ERHookKind, type ERLifecycleMethodKind, type ERLifecyclePhaseKind, type ERPhaseKind, ERPhaseRelevance, type ERSemanticEntry, type ERSemanticNode, type ERStateKind, RE_COMPONENT_NAME, RE_HOOK_NAME, getComponentNameFromIdentifier, getElementRepresentName, getFunctionComponentIdentifier, hasNoneOrValidComponentName, isCallFromReact, isCallFromReactMember, isChildrenCount, isChildrenCountCall, isChildrenForEach, isChildrenForEachCall, isChildrenMap, isChildrenMapCall, isChildrenOfCreateElement, isChildrenOnly, isChildrenOnlyCall, isChildrenToArray, isChildrenToArrayCall, isClassComponent, isCleanupFunction, isCloneElement, isCloneElementCall, isComponentDidMount, isComponentDidMountFunction, isComponentName, isComponentWillUnmount, isComponentWillUnmountFunction, isCreateContext, isCreateContextCall, isCreateElement, isCreateElementCall, isCreateRef, isCreateRefCall, isDeclaredInRenderPropLoose, isDirectValueOfRenderPropertyLoose, isForwardRef, isForwardRefCall, isFragmentElement, isFromReact, isFromReactMember, isFunctionOfRenderMethod, isInitializedFromReact, isInsideCreateElementProps, isInsideReactHook, isInsideReactHookCall, isInsideRenderMethod, isInversePhase, isMemo, isMemoCall, isPureComponent, isReactAPICallWithName, isReactAPIWithName, isReactHook, isReactHookCall, isReactHookCallWithName, isReactHookCallWithNameAlias, isReactHookCallWithNameLoose, isReactHookName, isRenderFunctionLoose, isRenderPropLoose, isSetupFunction, isThisSetState, isUseCallbackCall, isUseContextCall, isUseDebugValueCall, isUseDeferredValueCall, isUseEffectCall, isUseEffectCallLoose, isUseIdCall, isUseImperativeHandleCall, isUseInsertionEffectCall, isUseLayoutEffectCall, isUseMemoCall, isUseReducerCall, isUseRefCall, isUseStateCall, isUseSyncExternalStoreCall, isUseTransitionCall, useComponentCollector, useComponentCollectorLegacy, useHookCollector };
