import * as AST9 from '@eslint-react/ast';
import { F, isString, O } from '@eslint-react/eff';
import * as JSX4 from '@eslint-react/jsx';
import { AST_NODE_TYPES } from '@typescript-eslint/types';
import ShortUniqueId from 'short-unique-id';
import { isMatching, P, match } from 'ts-pattern';
import { normalizeSettings, decodeSettings, unsafeReadSettings } from '@eslint-react/shared';
import * as VAR from '@eslint-react/var';
import birecord from 'birecord';

// src/component/component-collector.ts
function getElementRepresentName(node, context) {
  const rawElementName = JSX4.getElementName(node);
  if (rawElementName === rawElementName.toLowerCase()) return rawElementName;
  const { components, polymorphicPropName } = normalizeSettings(decodeSettings(context.settings));
  const asElementName = components.get(rawElementName);
  if (isString(asElementName)) return asElementName;
  return F.pipe(
    O.fromNullable(polymorphicPropName),
    O.flatMap(JSX4.findPropInAttributes(node.attributes, context.sourceCode.getScope(node))),
    O.flatMap((attr) => JSX4.getPropValue(attr, context.sourceCode.getScope(attr))),
    O.filter(isString),
    O.getOrElse(() => rawElementName)
  );
}
function isInitializedFromReact(name, initialScope, settings) {
  if (!settings.strictImportCheck) return true;
  if (name.toLowerCase() === "react") return true;
  const { importSource = "react" } = settings;
  return VAR.isInitializedFromSource(name, importSource, initialScope);
}

// src/utils/is-from-react.ts
function isFromReact(name) {
  return (node, context) => {
    const settings = unsafeReadSettings(context.settings);
    const initialScope = context.sourceCode.getScope(node);
    if (node.type === AST_NODE_TYPES.MemberExpression) {
      return node.object.type === AST_NODE_TYPES.Identifier && node.property.type === AST_NODE_TYPES.Identifier && node.property.name === name && isInitializedFromReact(node.object.name, initialScope, settings);
    }
    if (node.name === name) return isInitializedFromReact(name, initialScope, settings);
    return false;
  };
}
function isFromReactMember(memberName, name) {
  return (node, context) => {
    const settings = unsafeReadSettings(context.settings);
    const initialScope = context.sourceCode.getScope(node);
    if (node.property.type !== AST_NODE_TYPES.Identifier || node.property.name !== name) return false;
    if (node.object.type === AST_NODE_TYPES.Identifier && node.object.name === memberName) {
      return isInitializedFromReact(node.object.name, initialScope, settings);
    }
    if (node.object.type === AST_NODE_TYPES.MemberExpression && node.object.object.type === AST_NODE_TYPES.Identifier && isInitializedFromReact(node.object.object.name, initialScope, settings) && node.object.property.type === AST_NODE_TYPES.Identifier) {
      return node.object.property.name === memberName;
    }
    return false;
  };
}
function isCallFromReact(name) {
  return (node, context) => {
    if (!AST9.isOneOf([AST_NODE_TYPES.Identifier, AST_NODE_TYPES.MemberExpression])(node.callee)) return false;
    return isFromReact(name)(node.callee, context);
  };
}
function isCallFromReactMember(pragmaMemberName, name) {
  return (node, context) => {
    if (!AST9.is(AST_NODE_TYPES.MemberExpression)(node.callee)) return false;
    return isFromReactMember(pragmaMemberName, name)(node.callee, context);
  };
}

// src/utils/is-react-api.ts
function isReactAPIWithName(name, member) {
  return member ? isFromReactMember(name, member) : isFromReact(name);
}
function isReactAPICallWithName(name, member) {
  return member ? isCallFromReactMember(name, member) : isCallFromReact(name);
}
var isChildrenCount = isReactAPIWithName("Children", "count");
var isChildrenForEach = isReactAPIWithName("Children", "forEach");
var isChildrenMap = isReactAPIWithName("Children", "map");
var isChildrenOnly = isReactAPIWithName("Children", "only");
var isChildrenToArray = isReactAPIWithName("Children", "toArray");
var isCloneElement = isReactAPIWithName("cloneElement");
var isCreateContext = isReactAPIWithName("createContext");
var isCreateElement = isReactAPIWithName("createElement");
var isCreateRef = isReactAPIWithName("createRef");
var isForwardRef = isReactAPIWithName("forwardRef");
var isMemo = isReactAPIWithName("memo");
var isChildrenCountCall = isReactAPICallWithName("Children", "count");
var isChildrenForEachCall = isReactAPICallWithName("Children", "forEach");
var isChildrenMapCall = isReactAPICallWithName("Children", "map");
var isChildrenOnlyCall = isReactAPICallWithName("Children", "only");
var isChildrenToArrayCall = isReactAPICallWithName("Children", "toArray");
var isCloneElementCall = isReactAPICallWithName("cloneElement");
var isCreateContextCall = isReactAPICallWithName("createContext");
var isCreateElementCall = isReactAPICallWithName("createElement");
var isCreateRefCall = isReactAPICallWithName("createRef");
var isForwardRefCall = isReactAPICallWithName("forwardRef");
var isMemoCall = isReactAPICallWithName("memo");

// src/element/hierarchy.ts
function isInsideCreateElementProps(node, context) {
  return F.pipe(
    AST9.traverseUp(node, (n) => AST9.is(AST_NODE_TYPES.CallExpression)(n) && isCreateElementCall(n, context)),
    O.filter(AST9.is(AST_NODE_TYPES.CallExpression)),
    O.flatMapNullable((c) => c.arguments.at(1)),
    O.filter(AST9.is(AST_NODE_TYPES.ObjectExpression)),
    O.zipWith(AST9.traverseUp(node, AST9.is(AST_NODE_TYPES.ObjectExpression)), (a, b) => a === b),
    O.getOrElse(F.constFalse)
  );
}
function isChildrenOfCreateElement(node, context) {
  return F.pipe(
    O.fromNullable(node.parent),
    O.filter(AST9.is(AST_NODE_TYPES.CallExpression)),
    O.filter((n) => isCreateElementCall(n, context)),
    O.exists(
      (n) => n.arguments.slice(2).some((arg) => arg === node)
    )
  );
}
function isFragmentElement(node, context) {
  const settings = decodeSettings(context.settings);
  const { jsxPragma = "React", jsxPragmaFrag = "Fragment" } = settings;
  const { name } = node.openingElement;
  if (name.type === AST_NODE_TYPES.JSXIdentifier && name.name === jsxPragmaFrag) return true;
  return name.type === AST_NODE_TYPES.JSXMemberExpression && name.object.type === AST_NODE_TYPES.JSXIdentifier && (name.object.name === jsxPragma || isInitializedFromReact(name.object.name, context.sourceCode.getScope(node), settings)) && name.property.name === jsxPragmaFrag;
}

// src/hook/hook-name.ts
var RE_HOOK_NAME = /^use[A-Z\d]/u;
function isReactHookName(name) {
  return name === "use" || RE_HOOK_NAME.test(name);
}

// src/hook/is.ts
function isReactHook(node) {
  return F.pipe(
    AST9.getFunctionIdentifier(node),
    O.flatMapNullable((id) => id.name),
    O.exists(isReactHookName)
  );
}
function isReactHookCall(node) {
  if (node.callee.type === AST_NODE_TYPES.Identifier) return isReactHookName(node.callee.name);
  if (node.callee.type === AST_NODE_TYPES.MemberExpression) {
    return node.callee.property.type === AST_NODE_TYPES.Identifier && isReactHookName(node.callee.property.name);
  }
  return false;
}
function isReactHookCallWithName(node, context) {
  const settings = unsafeReadSettings(context.settings);
  return (name) => {
    const initialScope = context.sourceCode.getScope(node);
    switch (true) {
      case (node.callee.type === AST_NODE_TYPES.Identifier && node.callee.name === name):
        return isInitializedFromReact(name, initialScope, settings);
      case (node.callee.type === AST_NODE_TYPES.MemberExpression && node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === name && "name" in node.callee.object):
        return isInitializedFromReact(node.callee.object.name, initialScope, settings);
      default:
        return false;
    }
  };
}
function isReactHookCallWithNameLoose(node) {
  return (name) => {
    switch (node.callee.type) {
      case AST_NODE_TYPES.Identifier:
        return node.callee.name === name;
      case AST_NODE_TYPES.MemberExpression:
        return node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === name;
      default:
        return false;
    }
  };
}
function isReactHookCallWithNameAlias(name, context, alias) {
  const settings = unsafeReadSettings(context.settings);
  return (node) => {
    const initialScope = context.sourceCode.getScope(node);
    switch (true) {
      case (node.callee.type === AST_NODE_TYPES.Identifier && node.callee.name === name):
        return isInitializedFromReact(name, initialScope, settings);
      case (node.callee.type === AST_NODE_TYPES.MemberExpression && node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === name && "name" in node.callee.object):
        return isInitializedFromReact(node.callee.object.name, initialScope, settings);
      default:
        return alias.some(isReactHookCallWithNameLoose(node));
    }
  };
}
function isUseEffectCallLoose(node) {
  if (node.type !== AST_NODE_TYPES.CallExpression) return false;
  switch (node.callee.type) {
    case AST_NODE_TYPES.Identifier:
      return /^use\w*Effect$/u.test(node.callee.name);
    case AST_NODE_TYPES.MemberExpression:
      return node.callee.property.type === AST_NODE_TYPES.Identifier && /^use\w*Effect$/u.test(node.callee.property.name);
    default:
      return false;
  }
}
var isUseCallbackCall = F.flip(isReactHookCallWithName)("useCallback");
var isUseContextCall = F.flip(isReactHookCallWithName)("useContext");
var isUseDebugValueCall = F.flip(isReactHookCallWithName)("useDebugValue");
var isUseDeferredValueCall = F.flip(isReactHookCallWithName)("useDeferredValue");
var isUseEffectCall = F.flip(isReactHookCallWithName)("useEffect");
var isUseIdCall = F.flip(isReactHookCallWithName)("useId");
var isUseImperativeHandleCall = F.flip(isReactHookCallWithName)("useImperativeHandle");
var isUseInsertionEffectCall = F.flip(isReactHookCallWithName)("useInsertionEffect");
var isUseLayoutEffectCall = F.flip(isReactHookCallWithName)("useLayoutEffect");
var isUseMemoCall = F.flip(isReactHookCallWithName)("useMemo");
var isUseReducerCall = F.flip(isReactHookCallWithName)("useReducer");
var isUseRefCall = F.flip(isReactHookCallWithName)("useRef");
var isUseStateCall = F.flip(isReactHookCallWithName)("useState");
var isUseSyncExternalStoreCall = F.flip(isReactHookCallWithName)("useSyncExternalStore");
var isUseTransitionCall = F.flip(isReactHookCallWithName)("useTransition");

// src/hook/hierarchy.ts
function isInsideReactHook(node) {
  return O.exists(AST9.traverseUpGuard(node, AST9.isFunction), isReactHook);
}
function isInsideReactHookCall(node) {
  return O.isSome(AST9.traverseUp(node, (n) => AST9.is(AST_NODE_TYPES.CallExpression)(n) && isReactHookCall(n)));
}
var uid = new ShortUniqueId({ length: 10 });
function useHookCollector() {
  const hooks = /* @__PURE__ */ new Map();
  const fStack = [];
  const onFunctionEnter = (node) => {
    const id = AST9.getFunctionIdentifier(node);
    const name = O.flatMapNullable(id, (id2) => id2.name);
    const isHook = O.isSome(id) && O.isSome(name) && isReactHookName(name.value);
    if (!isHook) {
      fStack.push([node, O.none()]);
      return;
    }
    const key = uid.rnd();
    fStack.push([node, O.some(key)]);
    hooks.set(key, {
      _: key,
      id,
      kind: "function",
      name,
      node,
      flag: 0n,
      hint: 0n,
      hookCalls: []
    });
  };
  const onFunctionExit = () => {
    fStack.pop();
  };
  const ctx = {
    getAllHooks(_) {
      return hooks;
    },
    getCurrentHooks() {
      return new Map(hooks);
    }
  };
  const listeners = {
    ":function[type]": onFunctionEnter,
    ":function[type]:exit": onFunctionExit,
    "CallExpression[type]"(node) {
      if (!isReactHookCall(node)) return;
      const [fNode, hookId] = fStack.at(-1) ?? [];
      if (!fNode || !hookId) return;
      F.pipe(
        O.Do,
        O.bind("id", () => hookId),
        O.bind("hook", ({ id }) => O.fromNullable(hooks.get(id))),
        O.map(({ id, hook }) => {
          hooks.set(id, {
            ...hook,
            hookCalls: [
              ...hook.hookCalls,
              node
            ]
          });
        })
      );
    }
  };
  return { ctx, listeners };
}
var ERComponentHint = {
  ...JSX4.JSXValueHint,
  // 1n << 0n - 1n << 63n are reserved for JSXValueHint
  // Skip function component created by React.memo
  SkipMemo: 1n << 64n,
  // Skip function component created by React.forwardRef
  SkipForwardRef: 1n << 65n,
  // Skip function component defined in map function callback
  SkipMapCallback: 1n << 66n,
  // Skip function component defined on object method
  SkipObjectMethod: 1n << 67n,
  // Skip function component defined on class method
  SkipClassMethod: 1n << 68n,
  // Skip function component defined on class property
  SkipClassProperty: 1n << 69n
};
var DEFAULT_COMPONENT_HINT = 0n | ERComponentHint.SkipBooleanLiteral | ERComponentHint.SkipMapCallback | ERComponentHint.SkipNumberLiteral | ERComponentHint.SkipStringLiteral | ERComponentHint.SkipUndefinedLiteral | ERComponentHint.SkipEmptyArray | ERComponentHint.StrictArray | ERComponentHint.StrictConditional | ERComponentHint.StrictLogical;

// src/component/component-flag.ts
var ERClassComponentFlag = {
  None: 0n,
  PureComponent: 1n << 0n
  // Reserved for future use
  // CreateElement: 1n << 1n,
};
var ERFunctionComponentFlag = {
  None: 0n,
  Memo: 1n << 0n,
  ForwardRef: 1n << 1n
  // Reserved for future use
  // CreateElement: 1n << 2n,
  // Reserved for future use
  // hasHooks: 1n << 3n,
  // Reserved for future use
  // Async: 1n << 4n,
};
function isComponentWrapperCall(node, context) {
  if (node.type !== AST_NODE_TYPES.CallExpression) return false;
  return isMemoCall(node, context) || isForwardRefCall(node, context) || isReactHookCallWithNameLoose(node)("useCallback");
}
function getFunctionComponentIdentifier(node, context) {
  const functionId = AST9.getFunctionIdentifier(node);
  if (O.isSome(functionId)) return functionId;
  const { parent } = node;
  if (parent.type === AST_NODE_TYPES.CallExpression && isComponentWrapperCall(parent, context) && parent.parent.type === AST_NODE_TYPES.VariableDeclarator && parent.parent.id.type === AST_NODE_TYPES.Identifier) {
    return O.some(parent.parent.id);
  }
  if (parent.type === AST_NODE_TYPES.CallExpression && isComponentWrapperCall(parent, context) && parent.parent.type === AST_NODE_TYPES.CallExpression && isComponentWrapperCall(parent.parent, context) && parent.parent.parent.type === AST_NODE_TYPES.VariableDeclarator && parent.parent.parent.id.type === AST_NODE_TYPES.Identifier) {
    return O.some(parent.parent.parent.id);
  }
  return O.none();
}

// src/component/component-name.ts
var RE_COMPONENT_NAME = /^_?[A-Z]/u;
function getComponentNameFromIdentifier(node) {
  return Array.isArray(node) ? node.map((n) => n.name).join(".") : node.name;
}
function isComponentName(name) {
  return !!name && RE_COMPONENT_NAME.test(name);
}
var uid2 = new ShortUniqueId({ length: 10 });
function isClassComponent(node) {
  if (!("superClass" in node && node.superClass)) return false;
  const { superClass } = node;
  return match(superClass).with({
    type: AST_NODE_TYPES.Identifier,
    name: P.string
  }, ({ name }) => /^(?:Pure)?Component$/u.test(name)).with({
    type: AST_NODE_TYPES.MemberExpression,
    property: { name: P.string }
  }, ({ property }) => /^(?:Pure)?Component$/u.test(property.name)).otherwise(() => false);
}
function isPureComponent(node) {
  if ("superClass" in node && node.superClass) {
    return match(node.superClass).with({
      type: AST_NODE_TYPES.Identifier,
      name: P.string
    }, ({ name }) => /^PureComponent$/u.test(name)).with({
      type: AST_NODE_TYPES.MemberExpression,
      property: { name: P.string }
    }, ({ property }) => /^PureComponent$/u.test(property.name)).otherwise(() => false);
  }
  return false;
}
function isComponentDidMount(node) {
  return AST9.isOneOf([AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentDidMount";
}
function isComponentWillUnmount(node) {
  return AST9.isOneOf([AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentWillUnmount";
}
function isComponentDidMountFunction(node) {
  return AST9.isFunction(node) && isComponentDidMount(node.parent) && node.parent.value === node;
}
function isComponentWillUnmountFunction(node) {
  return AST9.isFunction(node) && isComponentWillUnmount(node.parent) && node.parent.value === node;
}
function useComponentCollectorLegacy() {
  const components = /* @__PURE__ */ new Map();
  const ctx = {
    getAllComponents(_) {
      return components;
    },
    getCurrentComponents() {
      return new Map(components);
    }
  };
  const collect = (node) => {
    if (!isClassComponent(node)) return;
    const id = AST9.getClassIdentifier(node);
    const key = uid2.rnd();
    const flag = isPureComponent(node) ? ERClassComponentFlag.PureComponent : ERClassComponentFlag.None;
    components.set(
      key,
      {
        _: key,
        id,
        kind: "class",
        name: O.flatMapNullable(id, (n) => n.name),
        node,
        // TODO: Get displayName of class component
        displayName: O.none(),
        flag,
        hint: 0n,
        // TODO: Get methods of class component
        methods: []
      }
    );
  };
  const listeners = {
    "ClassDeclaration[type]": collect,
    "ClassExpression[type]": collect
  };
  return { ctx, listeners };
}

// src/component/component-render-method.ts
var isRenderMethodLike = isMatching({
  key: {
    type: AST_NODE_TYPES.Identifier,
    name: "render"
  },
  type: P.union(AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition),
  parent: {
    type: AST_NODE_TYPES.ClassBody,
    parent: {
      type: AST_NODE_TYPES.ClassDeclaration
    }
  }
});
function isFunctionOfRenderMethod(node) {
  if (!isRenderMethodLike(node.parent)) return false;
  return isClassComponent(node.parent.parent.parent);
}
function isInsideRenderMethod(node) {
  const predicate = (node2) => {
    return isRenderMethodLike(node2) && isClassComponent(node2.parent.parent);
  };
  return O.isSome(AST9.traverseUp(node, predicate));
}
function hasNoneOrValidComponentName(node, context) {
  return O.match(
    getFunctionComponentIdentifier(node, context),
    {
      onNone: F.constTrue,
      onSome: (id) => {
        const name = Array.isArray(id) ? id.at(-1)?.name : id.name;
        return !!name && isComponentName(name);
      }
    }
  );
}

// src/component/component-collector.ts
var uid3 = new ShortUniqueId({ length: 10 });
function hasValidHierarchy(node, context, hint) {
  if (isChildrenOfCreateElement(node, context) || isFunctionOfRenderMethod(node)) {
    return false;
  }
  if (hint & ERComponentHint.SkipMapCallback && AST9.isMapCallLoose(node.parent)) {
    return false;
  }
  if (hint & ERComponentHint.SkipObjectMethod && AST9.isFunctionOfObjectMethod(node.parent)) {
    return false;
  }
  if (hint & ERComponentHint.SkipClassMethod && AST9.isFunctionOfClassMethod(node.parent)) {
    return false;
  }
  if (hint & ERComponentHint.SkipClassProperty && AST9.isFunctionOfClassProperty(node.parent)) {
    return false;
  }
  return !O.exists(
    AST9.traverseUp(
      node,
      AST9.isOneOf([
        AST_NODE_TYPES.JSXExpressionContainer,
        AST_NODE_TYPES.ArrowFunctionExpression,
        AST_NODE_TYPES.FunctionExpression,
        AST_NODE_TYPES.Property,
        AST_NODE_TYPES.ClassBody
      ])
    ),
    AST9.is(AST_NODE_TYPES.JSXExpressionContainer)
  );
}
function getComponentFlag(initPath) {
  let flag = ERFunctionComponentFlag.None;
  if (AST9.hasCallInFunctionInitPath("memo")(initPath)) {
    flag |= ERFunctionComponentFlag.Memo;
  }
  if (AST9.hasCallInFunctionInitPath("forwardRef")(initPath)) {
    flag |= ERFunctionComponentFlag.ForwardRef;
  }
  return flag;
}
function useComponentCollector(context, hint = DEFAULT_COMPONENT_HINT) {
  const jsxCtx = { getScope: (node) => context.sourceCode.getScope(node) };
  const components = /* @__PURE__ */ new Map();
  const functionStack = [];
  const getCurrentFunction = () => O.fromNullable(functionStack.at(-1));
  const onFunctionEnter = (node) => functionStack.push([uid3.rnd(), node, false, []]);
  const onFunctionExit = () => {
    const [key, fn, isComponent] = functionStack.at(-1) ?? [];
    if (!key || !fn || !isComponent) return functionStack.pop();
    const shouldDrop = AST9.getNestedReturnStatements(fn.body).slice().reverse().some((r) => {
      return context.sourceCode.getScope(r).block === fn && r.argument !== null && !JSX4.isJSXValue(r.argument, jsxCtx, hint);
    });
    if (shouldDrop) components.delete(key);
    return functionStack.pop();
  };
  const ctx = {
    getAllComponents(_) {
      return components;
    },
    getCurrentComponents() {
      return new Map(components);
    },
    getCurrentFunction,
    getCurrentFunctionStack() {
      return [...functionStack];
    }
  };
  const listeners = {
    ":function[type]": onFunctionEnter,
    ":function[type]:exit": onFunctionExit,
    "ArrowFunctionExpression[type][body.type!='BlockStatement']"() {
      const maybeCurrentFn = getCurrentFunction();
      if (O.isNone(maybeCurrentFn)) return;
      const [_key, currentFn, _isComponent, hookCalls] = maybeCurrentFn.value;
      const { body } = currentFn;
      const isComponent = hasNoneOrValidComponentName(currentFn, context) && JSX4.isJSXValue(body, jsxCtx, hint) && hasValidHierarchy(currentFn, context, hint);
      if (!isComponent) return;
      const initPath = AST9.getFunctionInitPath(currentFn);
      const id = getFunctionComponentIdentifier(currentFn, context);
      const name = O.flatMapNullable(id, getComponentNameFromIdentifier);
      const key = uid3.rnd();
      components.set(key, {
        _: key,
        id,
        kind: "function",
        name,
        node: currentFn,
        displayName: O.none(),
        flag: getComponentFlag(initPath),
        hint,
        hookCalls,
        initPath
      });
    },
    "AssignmentExpression[type][operator='='][left.type='MemberExpression'][left.property.name='displayName']"(node) {
      if (node.type !== AST_NODE_TYPES.AssignmentExpression) return;
      const { left, right } = node;
      if (left.type !== AST_NODE_TYPES.MemberExpression) return;
      const maybeComponentName = match(left.object).with({ type: AST_NODE_TYPES.Identifier }, (n) => O.some(n.name)).otherwise(O.none);
      if (O.isNone(maybeComponentName)) return;
      const component = Array.from(components.values()).findLast(({ name }) => O.exists(name, (n) => n === maybeComponentName.value));
      if (!component) return;
      components.set(component._, {
        ...component,
        displayName: O.some(right)
      });
    },
    "CallExpression[type]:exit"(node) {
      if (!isReactHookCall(node)) return;
      const maybeCurrentFn = getCurrentFunction();
      if (O.isNone(maybeCurrentFn)) return;
      const [key, currentFn, isComponent, hookCalls] = maybeCurrentFn.value;
      functionStack.pop();
      functionStack.push([key, currentFn, isComponent, [...hookCalls, node]]);
    },
    "ReturnStatement[type]"(node) {
      const maybeCurrentFn = getCurrentFunction();
      if (O.isNone(maybeCurrentFn)) return;
      const [key, currentFn, isKnown, hookCalls] = maybeCurrentFn.value;
      if (isKnown) return;
      const isComponent = hasNoneOrValidComponentName(currentFn, context) && JSX4.isJSXValue(node.argument, jsxCtx, hint) && hasValidHierarchy(currentFn, context, hint);
      if (!isComponent) return;
      functionStack.pop();
      functionStack.push([key, currentFn, true, []]);
      const initPath = AST9.getFunctionInitPath(currentFn);
      const id = getFunctionComponentIdentifier(currentFn, context);
      const name = O.flatMapNullable(id, getComponentNameFromIdentifier);
      components.set(key, {
        _: key,
        id,
        kind: "function",
        name,
        node: currentFn,
        displayName: O.none(),
        flag: getComponentFlag(initPath),
        hint,
        hookCalls,
        initPath
      });
    }
  };
  return { ctx, listeners };
}
function isSetupFunction(node) {
  return node.parent?.type === AST_NODE_TYPES.CallExpression && node.parent.callee !== node && node.parent.callee.type === AST_NODE_TYPES.Identifier && node.parent.arguments.at(0) === node && isUseEffectCallLoose(node.parent);
}
function isCleanupFunction(node) {
  const nearestRet = O.getOrNull(AST9.traverseUpGuard(node, AST9.is(AST_NODE_TYPES.ReturnStatement)));
  if (!nearestRet) return false;
  const nearestFunction = O.getOrNull(AST9.traverseUpGuard(node, AST9.isFunction));
  const nearestFunctionOfRet = O.getOrNull(AST9.traverseUpGuard(nearestRet, AST9.isFunction));
  if (!nearestFunction || !nearestFunctionOfRet) return false;
  return nearestFunction === nearestFunctionOfRet && isSetupFunction(nearestFunction);
}
var ERPhaseRelevance = birecord({
  mount: "unmount",
  setup: "cleanup"
});
var isInversePhase = F.dual(2, (a, b) => ERPhaseRelevance.get(a) === b);
function isDirectValueOfRenderPropertyLoose(node) {
  const matching = isMatching({
    key: {
      type: AST_NODE_TYPES.Identifier,
      name: P.string.startsWith("render")
    },
    type: AST_NODE_TYPES.Property
  });
  return matching(node) || matching(node.parent);
}
function isDeclaredInRenderPropLoose(node) {
  if (isDirectValueOfRenderPropertyLoose(node)) {
    return true;
  }
  return F.pipe(
    AST9.traverseUpGuard(node, AST9.is(AST_NODE_TYPES.JSXExpressionContainer)),
    O.flatMapNullable((c) => c.parent),
    O.filter(AST9.is(AST_NODE_TYPES.JSXAttribute)),
    O.flatMapNullable((a) => a.name),
    O.exists(isMatching({
      type: AST_NODE_TYPES.JSXIdentifier,
      name: P.string.startsWith("render")
    }))
  );
}
function isRenderFunctionLoose(node, context) {
  const { body, parent } = node;
  const maybeId = AST9.getFunctionIdentifier(node);
  if (O.isSome(maybeId) && !maybeId.value.name.startsWith("render")) {
    return parent.type === AST_NODE_TYPES.JSXExpressionContainer && parent.parent.type === AST_NODE_TYPES.JSXAttribute && parent.parent.name.type === AST_NODE_TYPES.JSXIdentifier && parent.parent.name.name.startsWith("render");
  }
  const jsxCtx = { getScope: (node2) => context.sourceCode.getScope(node2) };
  return JSX4.isJSXValue(
    body,
    jsxCtx,
    JSX4.JSXValueHint.SkipNullLiteral | JSX4.JSXValueHint.SkipUndefinedLiteral | JSX4.JSXValueHint.StrictLogical | JSX4.JSXValueHint.StrictConditional
  );
}
function isRenderPropLoose(node, context) {
  if (node.name.type !== AST_NODE_TYPES.JSXIdentifier) return false;
  return node.name.name.startsWith("render") && node.value?.type === AST_NODE_TYPES.JSXExpressionContainer && AST9.isFunction(node.value.expression) && isRenderFunctionLoose(node.value.expression, context);
}
function isThisSetState(node) {
  const { callee } = node;
  return callee.type === AST_NODE_TYPES.MemberExpression && AST9.isThisExpression(callee.object) && callee.property.type === AST_NODE_TYPES.Identifier && callee.property.name === "setState";
}

export { DEFAULT_COMPONENT_HINT, ERClassComponentFlag, ERComponentHint, ERFunctionComponentFlag, ERPhaseRelevance, RE_COMPONENT_NAME, RE_HOOK_NAME, getComponentNameFromIdentifier, getElementRepresentName, getFunctionComponentIdentifier, hasNoneOrValidComponentName, isCallFromReact, isCallFromReactMember, isChildrenCount, isChildrenCountCall, isChildrenForEach, isChildrenForEachCall, isChildrenMap, isChildrenMapCall, isChildrenOfCreateElement, isChildrenOnly, isChildrenOnlyCall, isChildrenToArray, isChildrenToArrayCall, isClassComponent, isCleanupFunction, isCloneElement, isCloneElementCall, isComponentDidMount, isComponentDidMountFunction, isComponentName, isComponentWillUnmount, isComponentWillUnmountFunction, isCreateContext, isCreateContextCall, isCreateElement, isCreateElementCall, isCreateRef, isCreateRefCall, isDeclaredInRenderPropLoose, isDirectValueOfRenderPropertyLoose, isForwardRef, isForwardRefCall, isFragmentElement, isFromReact, isFromReactMember, isFunctionOfRenderMethod, isInitializedFromReact, isInsideCreateElementProps, isInsideReactHook, isInsideReactHookCall, isInsideRenderMethod, isInversePhase, isMemo, isMemoCall, isPureComponent, isReactAPICallWithName, isReactAPIWithName, isReactHook, isReactHookCall, isReactHookCallWithName, isReactHookCallWithNameAlias, isReactHookCallWithNameLoose, isReactHookName, isRenderFunctionLoose, isRenderPropLoose, isSetupFunction, isThisSetState, isUseCallbackCall, isUseContextCall, isUseDebugValueCall, isUseDeferredValueCall, isUseEffectCall, isUseEffectCallLoose, isUseIdCall, isUseImperativeHandleCall, isUseInsertionEffectCall, isUseLayoutEffectCall, isUseMemoCall, isUseReducerCall, isUseRefCall, isUseStateCall, isUseSyncExternalStoreCall, isUseTransitionCall, useComponentCollector, useComponentCollectorLegacy, useHookCollector };
