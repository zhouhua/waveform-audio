'use strict';

var AST9 = require('@eslint-react/ast');
var eff = require('@eslint-react/eff');
var JSX4 = require('@eslint-react/jsx');
var types = require('@typescript-eslint/types');
var ShortUniqueId = require('short-unique-id');
var tsPattern = require('ts-pattern');
var shared = require('@eslint-react/shared');
var VAR = require('@eslint-react/var');
var birecord = require('birecord');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var AST9__namespace = /*#__PURE__*/_interopNamespace(AST9);
var JSX4__namespace = /*#__PURE__*/_interopNamespace(JSX4);
var ShortUniqueId__default = /*#__PURE__*/_interopDefault(ShortUniqueId);
var VAR__namespace = /*#__PURE__*/_interopNamespace(VAR);
var birecord__default = /*#__PURE__*/_interopDefault(birecord);

// src/component/component-collector.ts
function getElementRepresentName(node, context) {
  const rawElementName = JSX4__namespace.getElementName(node);
  if (rawElementName === rawElementName.toLowerCase()) return rawElementName;
  const { components, polymorphicPropName } = shared.normalizeSettings(shared.decodeSettings(context.settings));
  const asElementName = components.get(rawElementName);
  if (eff.isString(asElementName)) return asElementName;
  return eff.F.pipe(
    eff.O.fromNullable(polymorphicPropName),
    eff.O.flatMap(JSX4__namespace.findPropInAttributes(node.attributes, context.sourceCode.getScope(node))),
    eff.O.flatMap((attr) => JSX4__namespace.getPropValue(attr, context.sourceCode.getScope(attr))),
    eff.O.filter(eff.isString),
    eff.O.getOrElse(() => rawElementName)
  );
}
function isInitializedFromReact(name, initialScope, settings) {
  if (!settings.strictImportCheck) return true;
  if (name.toLowerCase() === "react") return true;
  const { importSource = "react" } = settings;
  return VAR__namespace.isInitializedFromSource(name, importSource, initialScope);
}

// src/utils/is-from-react.ts
function isFromReact(name) {
  return (node, context) => {
    const settings = shared.unsafeReadSettings(context.settings);
    const initialScope = context.sourceCode.getScope(node);
    if (node.type === types.AST_NODE_TYPES.MemberExpression) {
      return node.object.type === types.AST_NODE_TYPES.Identifier && node.property.type === types.AST_NODE_TYPES.Identifier && node.property.name === name && isInitializedFromReact(node.object.name, initialScope, settings);
    }
    if (node.name === name) return isInitializedFromReact(name, initialScope, settings);
    return false;
  };
}
function isFromReactMember(memberName, name) {
  return (node, context) => {
    const settings = shared.unsafeReadSettings(context.settings);
    const initialScope = context.sourceCode.getScope(node);
    if (node.property.type !== types.AST_NODE_TYPES.Identifier || node.property.name !== name) return false;
    if (node.object.type === types.AST_NODE_TYPES.Identifier && node.object.name === memberName) {
      return isInitializedFromReact(node.object.name, initialScope, settings);
    }
    if (node.object.type === types.AST_NODE_TYPES.MemberExpression && node.object.object.type === types.AST_NODE_TYPES.Identifier && isInitializedFromReact(node.object.object.name, initialScope, settings) && node.object.property.type === types.AST_NODE_TYPES.Identifier) {
      return node.object.property.name === memberName;
    }
    return false;
  };
}
function isCallFromReact(name) {
  return (node, context) => {
    if (!AST9__namespace.isOneOf([types.AST_NODE_TYPES.Identifier, types.AST_NODE_TYPES.MemberExpression])(node.callee)) return false;
    return isFromReact(name)(node.callee, context);
  };
}
function isCallFromReactMember(pragmaMemberName, name) {
  return (node, context) => {
    if (!AST9__namespace.is(types.AST_NODE_TYPES.MemberExpression)(node.callee)) return false;
    return isFromReactMember(pragmaMemberName, name)(node.callee, context);
  };
}

// src/utils/is-react-api.ts
function isReactAPIWithName(name, member) {
  return member ? isFromReactMember(name, member) : isFromReact(name);
}
function isReactAPICallWithName(name, member) {
  return member ? isCallFromReactMember(name, member) : isCallFromReact(name);
}
var isChildrenCount = isReactAPIWithName("Children", "count");
var isChildrenForEach = isReactAPIWithName("Children", "forEach");
var isChildrenMap = isReactAPIWithName("Children", "map");
var isChildrenOnly = isReactAPIWithName("Children", "only");
var isChildrenToArray = isReactAPIWithName("Children", "toArray");
var isCloneElement = isReactAPIWithName("cloneElement");
var isCreateContext = isReactAPIWithName("createContext");
var isCreateElement = isReactAPIWithName("createElement");
var isCreateRef = isReactAPIWithName("createRef");
var isForwardRef = isReactAPIWithName("forwardRef");
var isMemo = isReactAPIWithName("memo");
var isChildrenCountCall = isReactAPICallWithName("Children", "count");
var isChildrenForEachCall = isReactAPICallWithName("Children", "forEach");
var isChildrenMapCall = isReactAPICallWithName("Children", "map");
var isChildrenOnlyCall = isReactAPICallWithName("Children", "only");
var isChildrenToArrayCall = isReactAPICallWithName("Children", "toArray");
var isCloneElementCall = isReactAPICallWithName("cloneElement");
var isCreateContextCall = isReactAPICallWithName("createContext");
var isCreateElementCall = isReactAPICallWithName("createElement");
var isCreateRefCall = isReactAPICallWithName("createRef");
var isForwardRefCall = isReactAPICallWithName("forwardRef");
var isMemoCall = isReactAPICallWithName("memo");

// src/element/hierarchy.ts
function isInsideCreateElementProps(node, context) {
  return eff.F.pipe(
    AST9__namespace.traverseUp(node, (n) => AST9__namespace.is(types.AST_NODE_TYPES.CallExpression)(n) && isCreateElementCall(n, context)),
    eff.O.filter(AST9__namespace.is(types.AST_NODE_TYPES.CallExpression)),
    eff.O.flatMapNullable((c) => c.arguments.at(1)),
    eff.O.filter(AST9__namespace.is(types.AST_NODE_TYPES.ObjectExpression)),
    eff.O.zipWith(AST9__namespace.traverseUp(node, AST9__namespace.is(types.AST_NODE_TYPES.ObjectExpression)), (a, b) => a === b),
    eff.O.getOrElse(eff.F.constFalse)
  );
}
function isChildrenOfCreateElement(node, context) {
  return eff.F.pipe(
    eff.O.fromNullable(node.parent),
    eff.O.filter(AST9__namespace.is(types.AST_NODE_TYPES.CallExpression)),
    eff.O.filter((n) => isCreateElementCall(n, context)),
    eff.O.exists(
      (n) => n.arguments.slice(2).some((arg) => arg === node)
    )
  );
}
function isFragmentElement(node, context) {
  const settings = shared.decodeSettings(context.settings);
  const { jsxPragma = "React", jsxPragmaFrag = "Fragment" } = settings;
  const { name } = node.openingElement;
  if (name.type === types.AST_NODE_TYPES.JSXIdentifier && name.name === jsxPragmaFrag) return true;
  return name.type === types.AST_NODE_TYPES.JSXMemberExpression && name.object.type === types.AST_NODE_TYPES.JSXIdentifier && (name.object.name === jsxPragma || isInitializedFromReact(name.object.name, context.sourceCode.getScope(node), settings)) && name.property.name === jsxPragmaFrag;
}

// src/hook/hook-name.ts
var RE_HOOK_NAME = /^use[A-Z\d]/u;
function isReactHookName(name) {
  return name === "use" || RE_HOOK_NAME.test(name);
}

// src/hook/is.ts
function isReactHook(node) {
  return eff.F.pipe(
    AST9__namespace.getFunctionIdentifier(node),
    eff.O.flatMapNullable((id) => id.name),
    eff.O.exists(isReactHookName)
  );
}
function isReactHookCall(node) {
  if (node.callee.type === types.AST_NODE_TYPES.Identifier) return isReactHookName(node.callee.name);
  if (node.callee.type === types.AST_NODE_TYPES.MemberExpression) {
    return node.callee.property.type === types.AST_NODE_TYPES.Identifier && isReactHookName(node.callee.property.name);
  }
  return false;
}
function isReactHookCallWithName(node, context) {
  const settings = shared.unsafeReadSettings(context.settings);
  return (name) => {
    const initialScope = context.sourceCode.getScope(node);
    switch (true) {
      case (node.callee.type === types.AST_NODE_TYPES.Identifier && node.callee.name === name):
        return isInitializedFromReact(name, initialScope, settings);
      case (node.callee.type === types.AST_NODE_TYPES.MemberExpression && node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === name && "name" in node.callee.object):
        return isInitializedFromReact(node.callee.object.name, initialScope, settings);
      default:
        return false;
    }
  };
}
function isReactHookCallWithNameLoose(node) {
  return (name) => {
    switch (node.callee.type) {
      case types.AST_NODE_TYPES.Identifier:
        return node.callee.name === name;
      case types.AST_NODE_TYPES.MemberExpression:
        return node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === name;
      default:
        return false;
    }
  };
}
function isReactHookCallWithNameAlias(name, context, alias) {
  const settings = shared.unsafeReadSettings(context.settings);
  return (node) => {
    const initialScope = context.sourceCode.getScope(node);
    switch (true) {
      case (node.callee.type === types.AST_NODE_TYPES.Identifier && node.callee.name === name):
        return isInitializedFromReact(name, initialScope, settings);
      case (node.callee.type === types.AST_NODE_TYPES.MemberExpression && node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === name && "name" in node.callee.object):
        return isInitializedFromReact(node.callee.object.name, initialScope, settings);
      default:
        return alias.some(isReactHookCallWithNameLoose(node));
    }
  };
}
function isUseEffectCallLoose(node) {
  if (node.type !== types.AST_NODE_TYPES.CallExpression) return false;
  switch (node.callee.type) {
    case types.AST_NODE_TYPES.Identifier:
      return /^use\w*Effect$/u.test(node.callee.name);
    case types.AST_NODE_TYPES.MemberExpression:
      return node.callee.property.type === types.AST_NODE_TYPES.Identifier && /^use\w*Effect$/u.test(node.callee.property.name);
    default:
      return false;
  }
}
var isUseCallbackCall = eff.F.flip(isReactHookCallWithName)("useCallback");
var isUseContextCall = eff.F.flip(isReactHookCallWithName)("useContext");
var isUseDebugValueCall = eff.F.flip(isReactHookCallWithName)("useDebugValue");
var isUseDeferredValueCall = eff.F.flip(isReactHookCallWithName)("useDeferredValue");
var isUseEffectCall = eff.F.flip(isReactHookCallWithName)("useEffect");
var isUseIdCall = eff.F.flip(isReactHookCallWithName)("useId");
var isUseImperativeHandleCall = eff.F.flip(isReactHookCallWithName)("useImperativeHandle");
var isUseInsertionEffectCall = eff.F.flip(isReactHookCallWithName)("useInsertionEffect");
var isUseLayoutEffectCall = eff.F.flip(isReactHookCallWithName)("useLayoutEffect");
var isUseMemoCall = eff.F.flip(isReactHookCallWithName)("useMemo");
var isUseReducerCall = eff.F.flip(isReactHookCallWithName)("useReducer");
var isUseRefCall = eff.F.flip(isReactHookCallWithName)("useRef");
var isUseStateCall = eff.F.flip(isReactHookCallWithName)("useState");
var isUseSyncExternalStoreCall = eff.F.flip(isReactHookCallWithName)("useSyncExternalStore");
var isUseTransitionCall = eff.F.flip(isReactHookCallWithName)("useTransition");

// src/hook/hierarchy.ts
function isInsideReactHook(node) {
  return eff.O.exists(AST9__namespace.traverseUpGuard(node, AST9__namespace.isFunction), isReactHook);
}
function isInsideReactHookCall(node) {
  return eff.O.isSome(AST9__namespace.traverseUp(node, (n) => AST9__namespace.is(types.AST_NODE_TYPES.CallExpression)(n) && isReactHookCall(n)));
}
var uid = new ShortUniqueId__default.default({ length: 10 });
function useHookCollector() {
  const hooks = /* @__PURE__ */ new Map();
  const fStack = [];
  const onFunctionEnter = (node) => {
    const id = AST9__namespace.getFunctionIdentifier(node);
    const name = eff.O.flatMapNullable(id, (id2) => id2.name);
    const isHook = eff.O.isSome(id) && eff.O.isSome(name) && isReactHookName(name.value);
    if (!isHook) {
      fStack.push([node, eff.O.none()]);
      return;
    }
    const key = uid.rnd();
    fStack.push([node, eff.O.some(key)]);
    hooks.set(key, {
      _: key,
      id,
      kind: "function",
      name,
      node,
      flag: 0n,
      hint: 0n,
      hookCalls: []
    });
  };
  const onFunctionExit = () => {
    fStack.pop();
  };
  const ctx = {
    getAllHooks(_) {
      return hooks;
    },
    getCurrentHooks() {
      return new Map(hooks);
    }
  };
  const listeners = {
    ":function[type]": onFunctionEnter,
    ":function[type]:exit": onFunctionExit,
    "CallExpression[type]"(node) {
      if (!isReactHookCall(node)) return;
      const [fNode, hookId] = fStack.at(-1) ?? [];
      if (!fNode || !hookId) return;
      eff.F.pipe(
        eff.O.Do,
        eff.O.bind("id", () => hookId),
        eff.O.bind("hook", ({ id }) => eff.O.fromNullable(hooks.get(id))),
        eff.O.map(({ id, hook }) => {
          hooks.set(id, {
            ...hook,
            hookCalls: [
              ...hook.hookCalls,
              node
            ]
          });
        })
      );
    }
  };
  return { ctx, listeners };
}
var ERComponentHint = {
  ...JSX4__namespace.JSXValueHint,
  // 1n << 0n - 1n << 63n are reserved for JSXValueHint
  // Skip function component created by React.memo
  SkipMemo: 1n << 64n,
  // Skip function component created by React.forwardRef
  SkipForwardRef: 1n << 65n,
  // Skip function component defined in map function callback
  SkipMapCallback: 1n << 66n,
  // Skip function component defined on object method
  SkipObjectMethod: 1n << 67n,
  // Skip function component defined on class method
  SkipClassMethod: 1n << 68n,
  // Skip function component defined on class property
  SkipClassProperty: 1n << 69n
};
var DEFAULT_COMPONENT_HINT = 0n | ERComponentHint.SkipBooleanLiteral | ERComponentHint.SkipMapCallback | ERComponentHint.SkipNumberLiteral | ERComponentHint.SkipStringLiteral | ERComponentHint.SkipUndefinedLiteral | ERComponentHint.SkipEmptyArray | ERComponentHint.StrictArray | ERComponentHint.StrictConditional | ERComponentHint.StrictLogical;

// src/component/component-flag.ts
var ERClassComponentFlag = {
  None: 0n,
  PureComponent: 1n << 0n
  // Reserved for future use
  // CreateElement: 1n << 1n,
};
var ERFunctionComponentFlag = {
  None: 0n,
  Memo: 1n << 0n,
  ForwardRef: 1n << 1n
  // Reserved for future use
  // CreateElement: 1n << 2n,
  // Reserved for future use
  // hasHooks: 1n << 3n,
  // Reserved for future use
  // Async: 1n << 4n,
};
function isComponentWrapperCall(node, context) {
  if (node.type !== types.AST_NODE_TYPES.CallExpression) return false;
  return isMemoCall(node, context) || isForwardRefCall(node, context) || isReactHookCallWithNameLoose(node)("useCallback");
}
function getFunctionComponentIdentifier(node, context) {
  const functionId = AST9__namespace.getFunctionIdentifier(node);
  if (eff.O.isSome(functionId)) return functionId;
  const { parent } = node;
  if (parent.type === types.AST_NODE_TYPES.CallExpression && isComponentWrapperCall(parent, context) && parent.parent.type === types.AST_NODE_TYPES.VariableDeclarator && parent.parent.id.type === types.AST_NODE_TYPES.Identifier) {
    return eff.O.some(parent.parent.id);
  }
  if (parent.type === types.AST_NODE_TYPES.CallExpression && isComponentWrapperCall(parent, context) && parent.parent.type === types.AST_NODE_TYPES.CallExpression && isComponentWrapperCall(parent.parent, context) && parent.parent.parent.type === types.AST_NODE_TYPES.VariableDeclarator && parent.parent.parent.id.type === types.AST_NODE_TYPES.Identifier) {
    return eff.O.some(parent.parent.parent.id);
  }
  return eff.O.none();
}

// src/component/component-name.ts
var RE_COMPONENT_NAME = /^_?[A-Z]/u;
function getComponentNameFromIdentifier(node) {
  return Array.isArray(node) ? node.map((n) => n.name).join(".") : node.name;
}
function isComponentName(name) {
  return !!name && RE_COMPONENT_NAME.test(name);
}
var uid2 = new ShortUniqueId__default.default({ length: 10 });
function isClassComponent(node) {
  if (!("superClass" in node && node.superClass)) return false;
  const { superClass } = node;
  return tsPattern.match(superClass).with({
    type: types.AST_NODE_TYPES.Identifier,
    name: tsPattern.P.string
  }, ({ name }) => /^(?:Pure)?Component$/u.test(name)).with({
    type: types.AST_NODE_TYPES.MemberExpression,
    property: { name: tsPattern.P.string }
  }, ({ property }) => /^(?:Pure)?Component$/u.test(property.name)).otherwise(() => false);
}
function isPureComponent(node) {
  if ("superClass" in node && node.superClass) {
    return tsPattern.match(node.superClass).with({
      type: types.AST_NODE_TYPES.Identifier,
      name: tsPattern.P.string
    }, ({ name }) => /^PureComponent$/u.test(name)).with({
      type: types.AST_NODE_TYPES.MemberExpression,
      property: { name: tsPattern.P.string }
    }, ({ property }) => /^PureComponent$/u.test(property.name)).otherwise(() => false);
  }
  return false;
}
function isComponentDidMount(node) {
  return AST9__namespace.isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentDidMount";
}
function isComponentWillUnmount(node) {
  return AST9__namespace.isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillUnmount";
}
function isComponentDidMountFunction(node) {
  return AST9__namespace.isFunction(node) && isComponentDidMount(node.parent) && node.parent.value === node;
}
function isComponentWillUnmountFunction(node) {
  return AST9__namespace.isFunction(node) && isComponentWillUnmount(node.parent) && node.parent.value === node;
}
function useComponentCollectorLegacy() {
  const components = /* @__PURE__ */ new Map();
  const ctx = {
    getAllComponents(_) {
      return components;
    },
    getCurrentComponents() {
      return new Map(components);
    }
  };
  const collect = (node) => {
    if (!isClassComponent(node)) return;
    const id = AST9__namespace.getClassIdentifier(node);
    const key = uid2.rnd();
    const flag = isPureComponent(node) ? ERClassComponentFlag.PureComponent : ERClassComponentFlag.None;
    components.set(
      key,
      {
        _: key,
        id,
        kind: "class",
        name: eff.O.flatMapNullable(id, (n) => n.name),
        node,
        // TODO: Get displayName of class component
        displayName: eff.O.none(),
        flag,
        hint: 0n,
        // TODO: Get methods of class component
        methods: []
      }
    );
  };
  const listeners = {
    "ClassDeclaration[type]": collect,
    "ClassExpression[type]": collect
  };
  return { ctx, listeners };
}

// src/component/component-render-method.ts
var isRenderMethodLike = tsPattern.isMatching({
  key: {
    type: types.AST_NODE_TYPES.Identifier,
    name: "render"
  },
  type: tsPattern.P.union(types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition),
  parent: {
    type: types.AST_NODE_TYPES.ClassBody,
    parent: {
      type: types.AST_NODE_TYPES.ClassDeclaration
    }
  }
});
function isFunctionOfRenderMethod(node) {
  if (!isRenderMethodLike(node.parent)) return false;
  return isClassComponent(node.parent.parent.parent);
}
function isInsideRenderMethod(node) {
  const predicate = (node2) => {
    return isRenderMethodLike(node2) && isClassComponent(node2.parent.parent);
  };
  return eff.O.isSome(AST9__namespace.traverseUp(node, predicate));
}
function hasNoneOrValidComponentName(node, context) {
  return eff.O.match(
    getFunctionComponentIdentifier(node, context),
    {
      onNone: eff.F.constTrue,
      onSome: (id) => {
        const name = Array.isArray(id) ? id.at(-1)?.name : id.name;
        return !!name && isComponentName(name);
      }
    }
  );
}

// src/component/component-collector.ts
var uid3 = new ShortUniqueId__default.default({ length: 10 });
function hasValidHierarchy(node, context, hint) {
  if (isChildrenOfCreateElement(node, context) || isFunctionOfRenderMethod(node)) {
    return false;
  }
  if (hint & ERComponentHint.SkipMapCallback && AST9__namespace.isMapCallLoose(node.parent)) {
    return false;
  }
  if (hint & ERComponentHint.SkipObjectMethod && AST9__namespace.isFunctionOfObjectMethod(node.parent)) {
    return false;
  }
  if (hint & ERComponentHint.SkipClassMethod && AST9__namespace.isFunctionOfClassMethod(node.parent)) {
    return false;
  }
  if (hint & ERComponentHint.SkipClassProperty && AST9__namespace.isFunctionOfClassProperty(node.parent)) {
    return false;
  }
  return !eff.O.exists(
    AST9__namespace.traverseUp(
      node,
      AST9__namespace.isOneOf([
        types.AST_NODE_TYPES.JSXExpressionContainer,
        types.AST_NODE_TYPES.ArrowFunctionExpression,
        types.AST_NODE_TYPES.FunctionExpression,
        types.AST_NODE_TYPES.Property,
        types.AST_NODE_TYPES.ClassBody
      ])
    ),
    AST9__namespace.is(types.AST_NODE_TYPES.JSXExpressionContainer)
  );
}
function getComponentFlag(initPath) {
  let flag = ERFunctionComponentFlag.None;
  if (AST9__namespace.hasCallInFunctionInitPath("memo")(initPath)) {
    flag |= ERFunctionComponentFlag.Memo;
  }
  if (AST9__namespace.hasCallInFunctionInitPath("forwardRef")(initPath)) {
    flag |= ERFunctionComponentFlag.ForwardRef;
  }
  return flag;
}
function useComponentCollector(context, hint = DEFAULT_COMPONENT_HINT) {
  const jsxCtx = { getScope: (node) => context.sourceCode.getScope(node) };
  const components = /* @__PURE__ */ new Map();
  const functionStack = [];
  const getCurrentFunction = () => eff.O.fromNullable(functionStack.at(-1));
  const onFunctionEnter = (node) => functionStack.push([uid3.rnd(), node, false, []]);
  const onFunctionExit = () => {
    const [key, fn, isComponent] = functionStack.at(-1) ?? [];
    if (!key || !fn || !isComponent) return functionStack.pop();
    const shouldDrop = AST9__namespace.getNestedReturnStatements(fn.body).slice().reverse().some((r) => {
      return context.sourceCode.getScope(r).block === fn && r.argument !== null && !JSX4__namespace.isJSXValue(r.argument, jsxCtx, hint);
    });
    if (shouldDrop) components.delete(key);
    return functionStack.pop();
  };
  const ctx = {
    getAllComponents(_) {
      return components;
    },
    getCurrentComponents() {
      return new Map(components);
    },
    getCurrentFunction,
    getCurrentFunctionStack() {
      return [...functionStack];
    }
  };
  const listeners = {
    ":function[type]": onFunctionEnter,
    ":function[type]:exit": onFunctionExit,
    "ArrowFunctionExpression[type][body.type!='BlockStatement']"() {
      const maybeCurrentFn = getCurrentFunction();
      if (eff.O.isNone(maybeCurrentFn)) return;
      const [_key, currentFn, _isComponent, hookCalls] = maybeCurrentFn.value;
      const { body } = currentFn;
      const isComponent = hasNoneOrValidComponentName(currentFn, context) && JSX4__namespace.isJSXValue(body, jsxCtx, hint) && hasValidHierarchy(currentFn, context, hint);
      if (!isComponent) return;
      const initPath = AST9__namespace.getFunctionInitPath(currentFn);
      const id = getFunctionComponentIdentifier(currentFn, context);
      const name = eff.O.flatMapNullable(id, getComponentNameFromIdentifier);
      const key = uid3.rnd();
      components.set(key, {
        _: key,
        id,
        kind: "function",
        name,
        node: currentFn,
        displayName: eff.O.none(),
        flag: getComponentFlag(initPath),
        hint,
        hookCalls,
        initPath
      });
    },
    "AssignmentExpression[type][operator='='][left.type='MemberExpression'][left.property.name='displayName']"(node) {
      if (node.type !== types.AST_NODE_TYPES.AssignmentExpression) return;
      const { left, right } = node;
      if (left.type !== types.AST_NODE_TYPES.MemberExpression) return;
      const maybeComponentName = tsPattern.match(left.object).with({ type: types.AST_NODE_TYPES.Identifier }, (n) => eff.O.some(n.name)).otherwise(eff.O.none);
      if (eff.O.isNone(maybeComponentName)) return;
      const component = Array.from(components.values()).findLast(({ name }) => eff.O.exists(name, (n) => n === maybeComponentName.value));
      if (!component) return;
      components.set(component._, {
        ...component,
        displayName: eff.O.some(right)
      });
    },
    "CallExpression[type]:exit"(node) {
      if (!isReactHookCall(node)) return;
      const maybeCurrentFn = getCurrentFunction();
      if (eff.O.isNone(maybeCurrentFn)) return;
      const [key, currentFn, isComponent, hookCalls] = maybeCurrentFn.value;
      functionStack.pop();
      functionStack.push([key, currentFn, isComponent, [...hookCalls, node]]);
    },
    "ReturnStatement[type]"(node) {
      const maybeCurrentFn = getCurrentFunction();
      if (eff.O.isNone(maybeCurrentFn)) return;
      const [key, currentFn, isKnown, hookCalls] = maybeCurrentFn.value;
      if (isKnown) return;
      const isComponent = hasNoneOrValidComponentName(currentFn, context) && JSX4__namespace.isJSXValue(node.argument, jsxCtx, hint) && hasValidHierarchy(currentFn, context, hint);
      if (!isComponent) return;
      functionStack.pop();
      functionStack.push([key, currentFn, true, []]);
      const initPath = AST9__namespace.getFunctionInitPath(currentFn);
      const id = getFunctionComponentIdentifier(currentFn, context);
      const name = eff.O.flatMapNullable(id, getComponentNameFromIdentifier);
      components.set(key, {
        _: key,
        id,
        kind: "function",
        name,
        node: currentFn,
        displayName: eff.O.none(),
        flag: getComponentFlag(initPath),
        hint,
        hookCalls,
        initPath
      });
    }
  };
  return { ctx, listeners };
}
function isSetupFunction(node) {
  return node.parent?.type === types.AST_NODE_TYPES.CallExpression && node.parent.callee !== node && node.parent.callee.type === types.AST_NODE_TYPES.Identifier && node.parent.arguments.at(0) === node && isUseEffectCallLoose(node.parent);
}
function isCleanupFunction(node) {
  const nearestRet = eff.O.getOrNull(AST9__namespace.traverseUpGuard(node, AST9__namespace.is(types.AST_NODE_TYPES.ReturnStatement)));
  if (!nearestRet) return false;
  const nearestFunction = eff.O.getOrNull(AST9__namespace.traverseUpGuard(node, AST9__namespace.isFunction));
  const nearestFunctionOfRet = eff.O.getOrNull(AST9__namespace.traverseUpGuard(nearestRet, AST9__namespace.isFunction));
  if (!nearestFunction || !nearestFunctionOfRet) return false;
  return nearestFunction === nearestFunctionOfRet && isSetupFunction(nearestFunction);
}
var ERPhaseRelevance = birecord__default.default({
  mount: "unmount",
  setup: "cleanup"
});
var isInversePhase = eff.F.dual(2, (a, b) => ERPhaseRelevance.get(a) === b);
function isDirectValueOfRenderPropertyLoose(node) {
  const matching = tsPattern.isMatching({
    key: {
      type: types.AST_NODE_TYPES.Identifier,
      name: tsPattern.P.string.startsWith("render")
    },
    type: types.AST_NODE_TYPES.Property
  });
  return matching(node) || matching(node.parent);
}
function isDeclaredInRenderPropLoose(node) {
  if (isDirectValueOfRenderPropertyLoose(node)) {
    return true;
  }
  return eff.F.pipe(
    AST9__namespace.traverseUpGuard(node, AST9__namespace.is(types.AST_NODE_TYPES.JSXExpressionContainer)),
    eff.O.flatMapNullable((c) => c.parent),
    eff.O.filter(AST9__namespace.is(types.AST_NODE_TYPES.JSXAttribute)),
    eff.O.flatMapNullable((a) => a.name),
    eff.O.exists(tsPattern.isMatching({
      type: types.AST_NODE_TYPES.JSXIdentifier,
      name: tsPattern.P.string.startsWith("render")
    }))
  );
}
function isRenderFunctionLoose(node, context) {
  const { body, parent } = node;
  const maybeId = AST9__namespace.getFunctionIdentifier(node);
  if (eff.O.isSome(maybeId) && !maybeId.value.name.startsWith("render")) {
    return parent.type === types.AST_NODE_TYPES.JSXExpressionContainer && parent.parent.type === types.AST_NODE_TYPES.JSXAttribute && parent.parent.name.type === types.AST_NODE_TYPES.JSXIdentifier && parent.parent.name.name.startsWith("render");
  }
  const jsxCtx = { getScope: (node2) => context.sourceCode.getScope(node2) };
  return JSX4__namespace.isJSXValue(
    body,
    jsxCtx,
    JSX4__namespace.JSXValueHint.SkipNullLiteral | JSX4__namespace.JSXValueHint.SkipUndefinedLiteral | JSX4__namespace.JSXValueHint.StrictLogical | JSX4__namespace.JSXValueHint.StrictConditional
  );
}
function isRenderPropLoose(node, context) {
  if (node.name.type !== types.AST_NODE_TYPES.JSXIdentifier) return false;
  return node.name.name.startsWith("render") && node.value?.type === types.AST_NODE_TYPES.JSXExpressionContainer && AST9__namespace.isFunction(node.value.expression) && isRenderFunctionLoose(node.value.expression, context);
}
function isThisSetState(node) {
  const { callee } = node;
  return callee.type === types.AST_NODE_TYPES.MemberExpression && AST9__namespace.isThisExpression(callee.object) && callee.property.type === types.AST_NODE_TYPES.Identifier && callee.property.name === "setState";
}

exports.DEFAULT_COMPONENT_HINT = DEFAULT_COMPONENT_HINT;
exports.ERClassComponentFlag = ERClassComponentFlag;
exports.ERComponentHint = ERComponentHint;
exports.ERFunctionComponentFlag = ERFunctionComponentFlag;
exports.ERPhaseRelevance = ERPhaseRelevance;
exports.RE_COMPONENT_NAME = RE_COMPONENT_NAME;
exports.RE_HOOK_NAME = RE_HOOK_NAME;
exports.getComponentNameFromIdentifier = getComponentNameFromIdentifier;
exports.getElementRepresentName = getElementRepresentName;
exports.getFunctionComponentIdentifier = getFunctionComponentIdentifier;
exports.hasNoneOrValidComponentName = hasNoneOrValidComponentName;
exports.isCallFromReact = isCallFromReact;
exports.isCallFromReactMember = isCallFromReactMember;
exports.isChildrenCount = isChildrenCount;
exports.isChildrenCountCall = isChildrenCountCall;
exports.isChildrenForEach = isChildrenForEach;
exports.isChildrenForEachCall = isChildrenForEachCall;
exports.isChildrenMap = isChildrenMap;
exports.isChildrenMapCall = isChildrenMapCall;
exports.isChildrenOfCreateElement = isChildrenOfCreateElement;
exports.isChildrenOnly = isChildrenOnly;
exports.isChildrenOnlyCall = isChildrenOnlyCall;
exports.isChildrenToArray = isChildrenToArray;
exports.isChildrenToArrayCall = isChildrenToArrayCall;
exports.isClassComponent = isClassComponent;
exports.isCleanupFunction = isCleanupFunction;
exports.isCloneElement = isCloneElement;
exports.isCloneElementCall = isCloneElementCall;
exports.isComponentDidMount = isComponentDidMount;
exports.isComponentDidMountFunction = isComponentDidMountFunction;
exports.isComponentName = isComponentName;
exports.isComponentWillUnmount = isComponentWillUnmount;
exports.isComponentWillUnmountFunction = isComponentWillUnmountFunction;
exports.isCreateContext = isCreateContext;
exports.isCreateContextCall = isCreateContextCall;
exports.isCreateElement = isCreateElement;
exports.isCreateElementCall = isCreateElementCall;
exports.isCreateRef = isCreateRef;
exports.isCreateRefCall = isCreateRefCall;
exports.isDeclaredInRenderPropLoose = isDeclaredInRenderPropLoose;
exports.isDirectValueOfRenderPropertyLoose = isDirectValueOfRenderPropertyLoose;
exports.isForwardRef = isForwardRef;
exports.isForwardRefCall = isForwardRefCall;
exports.isFragmentElement = isFragmentElement;
exports.isFromReact = isFromReact;
exports.isFromReactMember = isFromReactMember;
exports.isFunctionOfRenderMethod = isFunctionOfRenderMethod;
exports.isInitializedFromReact = isInitializedFromReact;
exports.isInsideCreateElementProps = isInsideCreateElementProps;
exports.isInsideReactHook = isInsideReactHook;
exports.isInsideReactHookCall = isInsideReactHookCall;
exports.isInsideRenderMethod = isInsideRenderMethod;
exports.isInversePhase = isInversePhase;
exports.isMemo = isMemo;
exports.isMemoCall = isMemoCall;
exports.isPureComponent = isPureComponent;
exports.isReactAPICallWithName = isReactAPICallWithName;
exports.isReactAPIWithName = isReactAPIWithName;
exports.isReactHook = isReactHook;
exports.isReactHookCall = isReactHookCall;
exports.isReactHookCallWithName = isReactHookCallWithName;
exports.isReactHookCallWithNameAlias = isReactHookCallWithNameAlias;
exports.isReactHookCallWithNameLoose = isReactHookCallWithNameLoose;
exports.isReactHookName = isReactHookName;
exports.isRenderFunctionLoose = isRenderFunctionLoose;
exports.isRenderPropLoose = isRenderPropLoose;
exports.isSetupFunction = isSetupFunction;
exports.isThisSetState = isThisSetState;
exports.isUseCallbackCall = isUseCallbackCall;
exports.isUseContextCall = isUseContextCall;
exports.isUseDebugValueCall = isUseDebugValueCall;
exports.isUseDeferredValueCall = isUseDeferredValueCall;
exports.isUseEffectCall = isUseEffectCall;
exports.isUseEffectCallLoose = isUseEffectCallLoose;
exports.isUseIdCall = isUseIdCall;
exports.isUseImperativeHandleCall = isUseImperativeHandleCall;
exports.isUseInsertionEffectCall = isUseInsertionEffectCall;
exports.isUseLayoutEffectCall = isUseLayoutEffectCall;
exports.isUseMemoCall = isUseMemoCall;
exports.isUseReducerCall = isUseReducerCall;
exports.isUseRefCall = isUseRefCall;
exports.isUseStateCall = isUseStateCall;
exports.isUseSyncExternalStoreCall = isUseSyncExternalStoreCall;
exports.isUseTransitionCall = isUseTransitionCall;
exports.useComponentCollector = useComponentCollector;
exports.useComponentCollectorLegacy = useComponentCollectorLegacy;
exports.useHookCollector = useHookCollector;
