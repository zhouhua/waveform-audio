import { AST_NODE_TYPES } from '@typescript-eslint/types';
import * as AST from '@eslint-react/ast';
import { O, F, isString } from '@eslint-react/eff';
import * as VAR from '@eslint-react/var';
import { match, P } from 'ts-pattern';
import birecord from 'birecord';

// src/get-element-name.ts
function resolveJSXMemberExpressions(object, property) {
  if (object.type === AST_NODE_TYPES.JSXMemberExpression) {
    return `${resolveJSXMemberExpressions(object.object, object.property)}.${property.name}`;
  }
  if (object.type === AST_NODE_TYPES.JSXNamespacedName) {
    return `${object.namespace.name}:${object.name.name}.${property.name}`;
  }
  return `${object.name}.${property.name}`;
}
function getElementName(node) {
  if (node.type === AST_NODE_TYPES.JSXOpeningFragment) {
    return "<>";
  }
  const { name } = node;
  if (name.type === AST_NODE_TYPES.JSXMemberExpression) {
    const { object, property } = name;
    return resolveJSXMemberExpressions(object, property);
  }
  if (name.type === AST_NODE_TYPES.JSXNamespacedName) {
    return `${name.namespace.name}:${name.name.name}`;
  }
  return name.name;
}
function getPropName(node) {
  switch (node.name.type) {
    case AST_NODE_TYPES.JSXIdentifier:
      return node.name.name;
    case AST_NODE_TYPES.JSXNamespacedName:
      return `${node.name.namespace.name}:${node.name.name.name}`;
  }
}
function getProp(props, propName, initialScope) {
  return findPropInAttributes(props, initialScope)(propName);
}
function getPropValue(attribute, initialScope) {
  if (attribute.type === AST_NODE_TYPES.JSXAttribute && "value" in attribute) {
    const { value } = attribute;
    if (value === null) return O.none();
    if (value.type === AST_NODE_TYPES.Literal) return VAR.getStaticValue(value, initialScope);
    if (value.type === AST_NODE_TYPES.JSXExpressionContainer) {
      return VAR.getStaticValue(value.expression, initialScope);
    }
    return O.none();
  }
  const { argument } = attribute;
  return VAR.getStaticValue(argument, initialScope);
}
function findPropInProperties(properties, initialScope, seenProps = []) {
  return (propName) => {
    return O.fromNullable(
      properties.findLast((prop) => {
        switch (true) {
          case (prop.type === AST_NODE_TYPES.Property && "name" in prop.key && prop.key.name === propName):
            return true;
          case prop.type === AST_NODE_TYPES.SpreadElement:
            switch (true) {
              case prop.argument.type === AST_NODE_TYPES.Identifier: {
                const { name } = prop.argument;
                const maybeInit = O.flatMap(
                  VAR.findVariable(name, initialScope),
                  VAR.getVariableNode(0)
                );
                if (O.isNone(maybeInit)) return false;
                const init = maybeInit.value;
                if (!AST.is(AST_NODE_TYPES.ObjectExpression)(init)) return false;
                if (seenProps.includes(name)) return false;
                return O.isSome(
                  findPropInProperties(init.properties, initialScope, [...seenProps, name])(propName)
                );
              }
              case prop.argument.type === AST_NODE_TYPES.ObjectExpression: {
                return O.isSome(
                  findPropInProperties(prop.argument.properties, initialScope, seenProps)(propName)
                );
              }
              default: {
                return false;
              }
            }
          case prop.type === AST_NODE_TYPES.RestElement:
            return false;
          default:
            return false;
        }
      })
    );
  };
}
function findPropInAttributes(attributes, initialScope) {
  return (propName) => {
    return O.fromNullable(
      attributes.findLast((attr) => {
        switch (attr.type) {
          case AST_NODE_TYPES.JSXAttribute:
            return getPropName(attr) === propName;
          case AST_NODE_TYPES.JSXSpreadAttribute:
            switch (attr.argument.type) {
              case AST_NODE_TYPES.CallExpression:
                return false;
              case AST_NODE_TYPES.Identifier: {
                const { name } = attr.argument;
                const maybeInit = O.flatMap(
                  VAR.findVariable(name, initialScope),
                  VAR.getVariableNode(0)
                );
                if (O.isNone(maybeInit)) return false;
                const init = maybeInit.value;
                if (!AST.is(AST_NODE_TYPES.ObjectExpression)(init)) return false;
                return O.isSome(findPropInProperties(init.properties, initialScope)(propName));
              }
              case AST_NODE_TYPES.MemberExpression:
                return false;
              case AST_NODE_TYPES.ObjectExpression:
                return O.isSome(findPropInProperties(attr.argument.properties, initialScope)(propName));
              default:
                return false;
            }
          default:
            return false;
        }
      })
    );
  };
}
function hasProp(attributes, propName, initialScope) {
  return O.isSome(findPropInAttributes(attributes, initialScope)(propName));
}
function hasAnyProp(attributes, propNames, initialScope) {
  return propNames.some((propName) => hasProp(attributes, propName, initialScope));
}
function hasEveryProp(attributes, propNames, initialScope) {
  return propNames.every((propName) => hasProp(attributes, propName, initialScope));
}
function isKeyedElement(node, initialScope) {
  return node.type === AST_NODE_TYPES.JSXElement && hasProp(node.openingElement.attributes, "key", initialScope);
}
function isBuiltInElement(node) {
  return node.type === AST_NODE_TYPES.JSXElement && node.openingElement.name.type === AST_NODE_TYPES.JSXIdentifier && node.openingElement.name.name.toLowerCase() === node.openingElement.name.name && /^[a-z]/u.test(node.openingElement.name.name);
}
function isUserDefinedElement(node) {
  return node.type === AST_NODE_TYPES.JSXElement && node.openingElement.name.type === AST_NODE_TYPES.JSXIdentifier && /^[A-Z]/u.test(node.openingElement.name.name);
}
var JSXValueHint = {
  None: 0n,
  SkipNullLiteral: 1n << 0n,
  SkipUndefinedLiteral: 1n << 1n,
  SkipBooleanLiteral: 1n << 2n,
  SkipStringLiteral: 1n << 3n,
  SkipNumberLiteral: 1n << 4n,
  SkipCreateElement: 1n << 5n,
  SkipEmptyArray: 1n << 6n,
  StrictArray: 1n << 7n,
  StrictLogical: 1n << 8n,
  StrictConditional: 1n << 9n
};
var DEFAULT_JSX_VALUE_HINT = 0n | JSXValueHint.SkipUndefinedLiteral | JSXValueHint.SkipBooleanLiteral;
function isJSXValue(node, jsxCtx, hint = DEFAULT_JSX_VALUE_HINT) {
  if (!node) return false;
  return match(node).with({ type: AST_NODE_TYPES.JSXElement }, F.constTrue).with({ type: AST_NODE_TYPES.JSXFragment }, F.constTrue).with({ type: AST_NODE_TYPES.JSXMemberExpression }, F.constTrue).with({ type: AST_NODE_TYPES.JSXNamespacedName }, F.constTrue).with({ type: AST_NODE_TYPES.Literal }, (node2) => {
    return match(node2.value).with(null, () => !(hint & JSXValueHint.SkipNullLiteral)).with(P.boolean, () => !(hint & JSXValueHint.SkipBooleanLiteral)).with(P.string, () => !(hint & JSXValueHint.SkipStringLiteral)).with(P.number, () => !(hint & JSXValueHint.SkipNumberLiteral)).otherwise(F.constFalse);
  }).with({ type: AST_NODE_TYPES.TemplateLiteral }, () => !(hint & JSXValueHint.SkipStringLiteral)).with({ type: AST_NODE_TYPES.ArrayExpression }, (node2) => {
    if (hint & JSXValueHint.StrictArray) return node2.elements.every((n) => isJSXValue(n, jsxCtx, hint));
    return node2.elements.some((n) => isJSXValue(n, jsxCtx, hint));
  }).with({ type: AST_NODE_TYPES.ConditionalExpression }, (node2) => {
    function leftHasJSX(node3) {
      if (Array.isArray(node3.consequent)) {
        if (node3.consequent.length === 0) return !(hint & JSXValueHint.SkipEmptyArray);
        if (hint & JSXValueHint.StrictArray) {
          return node3.consequent.every((n) => isJSXValue(n, jsxCtx, hint));
        }
        return node3.consequent.some((n) => isJSXValue(n, jsxCtx, hint));
      }
      return isJSXValue(node3.consequent, jsxCtx, hint);
    }
    function rightHasJSX(node3) {
      return isJSXValue(node3.alternate, jsxCtx, hint);
    }
    if (hint & JSXValueHint.StrictConditional) {
      return leftHasJSX(node2) && rightHasJSX(node2);
    }
    return leftHasJSX(node2) || rightHasJSX(node2);
  }).with({ type: AST_NODE_TYPES.LogicalExpression }, (node2) => {
    if (hint & JSXValueHint.StrictLogical) {
      return isJSXValue(node2.left, jsxCtx, hint) && isJSXValue(node2.right, jsxCtx, hint);
    }
    return isJSXValue(node2.left, jsxCtx, hint) || isJSXValue(node2.right, jsxCtx, hint);
  }).with({ type: AST_NODE_TYPES.SequenceExpression }, (node2) => {
    const exp = node2.expressions.at(-1);
    return isJSXValue(exp, jsxCtx, hint);
  }).with({ type: AST_NODE_TYPES.CallExpression }, (node2) => {
    if (hint & JSXValueHint.SkipCreateElement) return false;
    return match(node2.callee).with({ type: AST_NODE_TYPES.Identifier, name: "createElement" }, F.constTrue).with({ type: AST_NODE_TYPES.MemberExpression, property: { name: "createElement" } }, F.constTrue).otherwise(F.constFalse);
  }).with({ type: AST_NODE_TYPES.Identifier }, (node2) => {
    const { name } = node2;
    if (name === "undefined") return !(hint & JSXValueHint.SkipUndefinedLiteral);
    if (AST.isJSXTagNameExpression(node2)) return true;
    const initialScope = jsxCtx.getScope(node2);
    return F.pipe(
      VAR.findVariable(name, initialScope),
      O.flatMap(VAR.getVariableNode(0)),
      O.exists((n) => isJSXValue(n, jsxCtx, hint))
    );
  }).otherwise(F.constFalse);
}
var isLiteral = AST.isOneOf([AST_NODE_TYPES.Literal, AST_NODE_TYPES.JSXText]);
function isWhiteSpace(node) {
  return isString(node.value) && node.value.trim() === "";
}
function isLineBreak(node) {
  return isLiteral(node) && isWhiteSpace(node) && AST.isMultiLine(node);
}
function isPaddingSpaces(node) {
  return isLiteral(node) && isWhiteSpace(node) && node.raw.includes("\n");
}
function traverseUpProp(node, predicate = F.constTrue) {
  const guard = (node2) => {
    return node2.type === AST_NODE_TYPES.JSXAttribute && predicate(node2);
  };
  return AST.traverseUpGuard(node, guard);
}
var xhtmlEntities = birecord({
  Aacute: "\xC1",
  aacute: "\xE1",
  Acirc: "\xC2",
  acirc: "\xE2",
  acute: "\xB4",
  AElig: "\xC6",
  aelig: "\xE6",
  Agrave: "\xC0",
  agrave: "\xE0",
  alefsym: "\u2135",
  Alpha: "\u0391",
  alpha: "\u03B1",
  amp: "&",
  and: "\u2227",
  ang: "\u2220",
  apos: "'",
  Aring: "\xC5",
  aring: "\xE5",
  asymp: "\u2248",
  Atilde: "\xC3",
  atilde: "\xE3",
  Auml: "\xC4",
  auml: "\xE4",
  bdquo: "\u201E",
  Beta: "\u0392",
  beta: "\u03B2",
  brvbar: "\xA6",
  bull: "\u2022",
  cap: "\u2229",
  Ccedil: "\xC7",
  ccedil: "\xE7",
  cedil: "\xB8",
  cent: "\xA2",
  Chi: "\u03A7",
  chi: "\u03C7",
  circ: "\u02C6",
  clubs: "\u2663",
  cong: "\u2245",
  copy: "\xA9",
  crarr: "\u21B5",
  cup: "\u222A",
  curren: "\xA4",
  dagger: "\u2020",
  Dagger: "\u2021",
  darr: "\u2193",
  dArr: "\u21D3",
  deg: "\xB0",
  Delta: "\u0394",
  delta: "\u03B4",
  diams: "\u2666",
  divide: "\xF7",
  Eacute: "\xC9",
  eacute: "\xE9",
  Ecirc: "\xCA",
  ecirc: "\xEA",
  Egrave: "\xC8",
  egrave: "\xE8",
  empty: "\u2205",
  emsp: "\u2003",
  ensp: "\u2002",
  Epsilon: "\u0395",
  epsilon: "\u03B5",
  equiv: "\u2261",
  Eta: "\u0397",
  eta: "\u03B7",
  ETH: "\xD0",
  eth: "\xF0",
  Euml: "\xCB",
  euml: "\xEB",
  euro: "\u20AC",
  exist: "\u2203",
  fnof: "\u0192",
  forall: "\u2200",
  frac12: "\xBD",
  frac14: "\xBC",
  frac34: "\xBE",
  frasl: "\u2044",
  Gamma: "\u0393",
  gamma: "\u03B3",
  ge: "\u2265",
  gt: ">",
  harr: "\u2194",
  hArr: "\u21D4",
  hearts: "\u2665",
  hellip: "\u2026",
  Iacute: "\xCD",
  iacute: "\xED",
  Icirc: "\xCE",
  icirc: "\xEE",
  iexcl: "\xA1",
  Igrave: "\xCC",
  igrave: "\xEC",
  image: "\u2111",
  infin: "\u221E",
  int: "\u222B",
  Iota: "\u0399",
  iota: "\u03B9",
  iquest: "\xBF",
  isin: "\u2208",
  Iuml: "\xCF",
  iuml: "\xEF",
  Kappa: "\u039A",
  kappa: "\u03BA",
  Lambda: "\u039B",
  lambda: "\u03BB",
  lang: "\u2329",
  laquo: "\xAB",
  larr: "\u2190",
  lArr: "\u21D0",
  lceil: "\u2308",
  ldquo: "\u201C",
  le: "\u2264",
  lfloor: "\u230A",
  lowast: "\u2217",
  loz: "\u25CA",
  lrm: "\u200E",
  lsaquo: "\u2039",
  lsquo: "\u2018",
  lt: "<",
  macr: "\xAF",
  mdash: "\u2014",
  micro: "\xB5",
  middot: "\xB7",
  minus: "\u2212",
  Mu: "\u039C",
  mu: "\u03BC",
  nabla: "\u2207",
  nbsp: "\xA0",
  ndash: "\u2013",
  ne: "\u2260",
  ni: "\u220B",
  not: "\xAC",
  notin: "\u2209",
  nsub: "\u2284",
  Ntilde: "\xD1",
  ntilde: "\xF1",
  Nu: "\u039D",
  nu: "\u03BD",
  Oacute: "\xD3",
  oacute: "\xF3",
  Ocirc: "\xD4",
  ocirc: "\xF4",
  OElig: "\u0152",
  oelig: "\u0153",
  Ograve: "\xD2",
  ograve: "\xF2",
  oline: "\u203E",
  Omega: "\u03A9",
  omega: "\u03C9",
  Omicron: "\u039F",
  omicron: "\u03BF",
  oplus: "\u2295",
  or: "\u2228",
  ordf: "\xAA",
  ordm: "\xBA",
  Oslash: "\xD8",
  oslash: "\xF8",
  Otilde: "\xD5",
  otilde: "\xF5",
  otimes: "\u2297",
  Ouml: "\xD6",
  ouml: "\xF6",
  para: "\xB6",
  part: "\u2202",
  permil: "\u2030",
  perp: "\u22A5",
  Phi: "\u03A6",
  phi: "\u03C6",
  Pi: "\u03A0",
  pi: "\u03C0",
  piv: "\u03D6",
  plusmn: "\xB1",
  pound: "\xA3",
  prime: "\u2032",
  Prime: "\u2033",
  prod: "\u220F",
  prop: "\u221D",
  Psi: "\u03A8",
  psi: "\u03C8",
  quot: '"',
  radic: "\u221A",
  rang: "\u232A",
  raquo: "\xBB",
  rarr: "\u2192",
  rArr: "\u21D2",
  rceil: "\u2309",
  rdquo: "\u201D",
  real: "\u211C",
  reg: "\xAE",
  rfloor: "\u230B",
  Rho: "\u03A1",
  rho: "\u03C1",
  rlm: "\u200F",
  rsaquo: "\u203A",
  rsquo: "\u2019",
  sbquo: "\u201A",
  Scaron: "\u0160",
  scaron: "\u0161",
  sdot: "\u22C5",
  sect: "\xA7",
  shy: "\xAD",
  Sigma: "\u03A3",
  sigma: "\u03C3",
  sigmaf: "\u03C2",
  sim: "\u223C",
  spades: "\u2660",
  sub: "\u2282",
  sube: "\u2286",
  sum: "\u2211",
  sup: "\u2283",
  sup1: "\xB9",
  sup2: "\xB2",
  sup3: "\xB3",
  supe: "\u2287",
  szlig: "\xDF",
  Tau: "\u03A4",
  tau: "\u03C4",
  there4: "\u2234",
  Theta: "\u0398",
  theta: "\u03B8",
  thetasym: "\u03D1",
  thinsp: "\u2009",
  THORN: "\xDE",
  thorn: "\xFE",
  tilde: "\u02DC",
  times: "\xD7",
  trade: "\u2122",
  Uacute: "\xDA",
  uacute: "\xFA",
  uarr: "\u2191",
  uArr: "\u21D1",
  Ucirc: "\xDB",
  ucirc: "\xFB",
  Ugrave: "\xD9",
  ugrave: "\xF9",
  uml: "\xA8",
  upsih: "\u03D2",
  Upsilon: "\u03A5",
  upsilon: "\u03C5",
  Uuml: "\xDC",
  uuml: "\xFC",
  weierp: "\u2118",
  Xi: "\u039E",
  xi: "\u03BE",
  Yacute: "\xDD",
  yacute: "\xFD",
  yen: "\xA5",
  yuml: "\xFF",
  Yuml: "\u0178",
  Zeta: "\u0396",
  zeta: "\u03B6",
  zwj: "\u200D",
  zwnj: "\u200C"
});

// src/unescape-string-literal-text.ts
function unescapeStringLiteralText(text) {
  return text.replaceAll(/&(?:#\d+|#x[\da-fA-F]+|[0-9a-zA-Z]+);/g, (entity) => {
    const item = entity.slice(1, -1);
    if (item[0] === "#") {
      const codePoint = item[1] === "x" ? parseInt(item.slice(2), 16) : parseInt(item.slice(1), 10);
      return codePoint > 1114111 ? entity : String.fromCodePoint(codePoint);
    }
    return xhtmlEntities.has(item) ? xhtmlEntities.get(item) : entity;
  });
}

export { DEFAULT_JSX_VALUE_HINT, JSXValueHint, findPropInAttributes, findPropInProperties, getElementName, getProp, getPropName, getPropValue, hasAnyProp, hasEveryProp, hasProp, isBuiltInElement, isJSXValue, isKeyedElement, isLineBreak, isLiteral, isPaddingSpaces, isUserDefinedElement, isWhiteSpace, traverseUpProp, unescapeStringLiteralText, xhtmlEntities };
