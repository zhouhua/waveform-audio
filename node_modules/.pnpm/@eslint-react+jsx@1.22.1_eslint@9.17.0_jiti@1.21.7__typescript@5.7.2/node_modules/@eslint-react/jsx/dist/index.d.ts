import { TSESTree } from '@typescript-eslint/types';
import { O } from '@eslint-react/eff';
import { Scope } from '@typescript-eslint/scope-manager';
import { TSESTree as TSESTree$1 } from '@typescript-eslint/utils';
import * as birecord from 'birecord';

/**
 * Returns the tag name associated with a JSXOpeningElement.
 * @param node The visited JSXOpeningElement node object.
 * @returns The element's tag name.
 */
declare function getElementName(node: TSESTree.JSXOpeningElement | TSESTree.JSXOpeningFragment): string;

/**
 * Get the name of a JSX attribute with namespace
 * @param node The JSX attribute node
 * @returns string
 */
declare function getPropName(node: TSESTree$1.JSXAttribute): string;
declare function getProp(props: (TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute)[], propName: string, initialScope: Scope): O.Option<TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute>;
/**
 * Gets and resolves the static value of a JSX attribute
 * @param attribute The JSX attribute to get the value of
 * @param initialScope The initial scope to start from
 * @returns  The static value of the given JSX attribute
 */
declare function getPropValue(attribute: TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute, initialScope: Scope): O.None<unknown> | O.Some<unknown>;
/**
 * @param properties The properties to search in
 * @param initialScope The initial scope to start from
 * @param seenProps The properties that have already been seen
 * @returns A function that searches for a property in the given properties
 */
declare function findPropInProperties(properties: (TSESTree$1.Property | TSESTree$1.RestElement | TSESTree$1.SpreadElement)[], initialScope: Scope, seenProps?: string[]): (propName: string) => O.Option<(typeof properties)[number]>;
/**
 * @param attributes The attributes to search in
 * @param initialScope The initial scope to start from
 * @returns A function that searches for a property in the given attributes
 */
declare function findPropInAttributes(attributes: (TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute)[], initialScope: Scope): (propName: string) => O.Option<NonNullable<TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute | undefined>>;

/**
 * Check if the given prop name is present in the given attributes
 * @param attributes The attributes to search in
 * @param propName The prop name to search for
 * @param initialScope The initial scope to start from
 * @returns `true` if the given prop name is present in the given properties
 */
declare function hasProp(attributes: (TSESTree.JSXAttribute | TSESTree.JSXSpreadAttribute)[], propName: string, initialScope: Scope): boolean;
/**
 * Check if any of the given prop names are present in the given attributes
 * @param attributes The attributes to search in
 * @param propNames The prop names to search for
 * @param initialScope The initial scope to start from
 * @returns `true` if any of the given prop names are present in the given attributes
 */
declare function hasAnyProp(attributes: (TSESTree.JSXAttribute | TSESTree.JSXSpreadAttribute)[], propNames: string[], initialScope: Scope): boolean;
/**
 * Check if all of the given prop names are present in the given attributes
 * @param attributes The attributes to search in
 * @param propNames The prop names to search for
 * @param initialScope The initial scope to start from
 * @returns `true` if all of the given prop names are present in the given attributes
 */
declare function hasEveryProp(attributes: (TSESTree.JSXAttribute | TSESTree.JSXSpreadAttribute)[], propNames: string[], initialScope: Scope): boolean;

declare function isKeyedElement(node: TSESTree.Node, initialScope: Scope): boolean;
/**
 * Check if a node is a `JSXFragment` of `Built-in Component` type
 * @param node The AST node to check
 * @returns `true` if the node is a `JSXFragment` of `Built-in Component` type
 */
declare function isBuiltInElement(node: TSESTree.Node): boolean;
/**
 * Check if a node is a `JSXElement` of `User-Defined Component` type
 * @param node The AST node to check
 * @returns `true` if the node is a `JSXElement` of `User-Defined Component` type
 */
declare function isUserDefinedElement(node: TSESTree.Node): boolean;

declare const JSXValueHint: {
    readonly None: 0n;
    readonly SkipNullLiteral: bigint;
    readonly SkipUndefinedLiteral: bigint;
    readonly SkipBooleanLiteral: bigint;
    readonly SkipStringLiteral: bigint;
    readonly SkipNumberLiteral: bigint;
    readonly SkipCreateElement: bigint;
    readonly SkipEmptyArray: bigint;
    readonly StrictArray: bigint;
    readonly StrictLogical: bigint;
    readonly StrictConditional: bigint;
};
declare const DEFAULT_JSX_VALUE_HINT: bigint;
/**
 * Check if a node is a JSX value
 * @param node The AST node to check
 * @param jsxCtx The requirements for the check
 * @param jsxCtx.getScope The function to get the scope of a node
 * @param hint The `JSXValueHint` to use
 * @returns boolean
 */
declare function isJSXValue(node: null | TSESTree$1.Node | undefined, jsxCtx: {
    getScope: (node: TSESTree$1.Node) => Scope;
}, hint?: bigint): boolean;

/**
 * Check if a node is a Literal or JSXText
 * @param node The AST node to check
 * @returns boolean `true` if the node is a Literal or JSXText
 */
declare const isLiteral: (node: TSESTree.Node | null | undefined) => node is TSESTree.BigIntLiteral | TSESTree.BooleanLiteral | TSESTree.NullLiteral | TSESTree.NumberLiteral | TSESTree.RegExpLiteral | TSESTree.StringLiteral | TSESTree.JSXText;
/**
 * Check if a Literal or JSXText node is whitespace
 * @param node The AST node to check
 * @returns boolean `true` if the node is whitespace
 */
declare function isWhiteSpace(node: TSESTree.JSXText | TSESTree.Literal): boolean;
/**
 * Check if a Literal or JSXText node is a line break
 * @param node The AST node to check
 * @returns boolean
 */
declare function isLineBreak(node: TSESTree.Node): boolean;
/**
 * Check if a Literal or JSXText node is padding spaces
 * @param node The AST node to check
 * @returns boolean
 */
declare function isPaddingSpaces(node: TSESTree.Node): boolean;

/**
 * Traverses up prop node
 * @param node The AST node to start traversing from
 * @param predicate The predicate to check each node
 * @returns prop node if found
 */
declare function traverseUpProp(node: TSESTree.Node, predicate?: (node: TSESTree.JSXAttribute) => boolean): O.Option<TSESTree.JSXAttribute>;

/**
 * Unescape the text content of string literals, e.g. &amp; -> &
 * @param text The escaped string literal text.
 * @returns The unescaped string literal text.
 */
declare function unescapeStringLiteralText(text: string): string;

declare const xhtmlEntities: birecord.BiRecord<{
    readonly Aacute: "Á";
    readonly aacute: "á";
    readonly Acirc: "Â";
    readonly acirc: "â";
    readonly acute: "´";
    readonly AElig: "Æ";
    readonly aelig: "æ";
    readonly Agrave: "À";
    readonly agrave: "à";
    readonly alefsym: "ℵ";
    readonly Alpha: "Α";
    readonly alpha: "α";
    readonly amp: "&";
    readonly and: "∧";
    readonly ang: "∠";
    readonly apos: "'";
    readonly Aring: "Å";
    readonly aring: "å";
    readonly asymp: "≈";
    readonly Atilde: "Ã";
    readonly atilde: "ã";
    readonly Auml: "Ä";
    readonly auml: "ä";
    readonly bdquo: "„";
    readonly Beta: "Β";
    readonly beta: "β";
    readonly brvbar: "¦";
    readonly bull: "•";
    readonly cap: "∩";
    readonly Ccedil: "Ç";
    readonly ccedil: "ç";
    readonly cedil: "¸";
    readonly cent: "¢";
    readonly Chi: "Χ";
    readonly chi: "χ";
    readonly circ: "ˆ";
    readonly clubs: "♣";
    readonly cong: "≅";
    readonly copy: "©";
    readonly crarr: "↵";
    readonly cup: "∪";
    readonly curren: "¤";
    readonly dagger: "†";
    readonly Dagger: "‡";
    readonly darr: "↓";
    readonly dArr: "⇓";
    readonly deg: "°";
    readonly Delta: "Δ";
    readonly delta: "δ";
    readonly diams: "♦";
    readonly divide: "÷";
    readonly Eacute: "É";
    readonly eacute: "é";
    readonly Ecirc: "Ê";
    readonly ecirc: "ê";
    readonly Egrave: "È";
    readonly egrave: "è";
    readonly empty: "∅";
    readonly emsp: " ";
    readonly ensp: " ";
    readonly Epsilon: "Ε";
    readonly epsilon: "ε";
    readonly equiv: "≡";
    readonly Eta: "Η";
    readonly eta: "η";
    readonly ETH: "Ð";
    readonly eth: "ð";
    readonly Euml: "Ë";
    readonly euml: "ë";
    readonly euro: "€";
    readonly exist: "∃";
    readonly fnof: "ƒ";
    readonly forall: "∀";
    readonly frac12: "½";
    readonly frac14: "¼";
    readonly frac34: "¾";
    readonly frasl: "⁄";
    readonly Gamma: "Γ";
    readonly gamma: "γ";
    readonly ge: "≥";
    readonly gt: ">";
    readonly harr: "↔";
    readonly hArr: "⇔";
    readonly hearts: "♥";
    readonly hellip: "…";
    readonly Iacute: "Í";
    readonly iacute: "í";
    readonly Icirc: "Î";
    readonly icirc: "î";
    readonly iexcl: "¡";
    readonly Igrave: "Ì";
    readonly igrave: "ì";
    readonly image: "ℑ";
    readonly infin: "∞";
    readonly int: "∫";
    readonly Iota: "Ι";
    readonly iota: "ι";
    readonly iquest: "¿";
    readonly isin: "∈";
    readonly Iuml: "Ï";
    readonly iuml: "ï";
    readonly Kappa: "Κ";
    readonly kappa: "κ";
    readonly Lambda: "Λ";
    readonly lambda: "λ";
    readonly lang: "〈";
    readonly laquo: "«";
    readonly larr: "←";
    readonly lArr: "⇐";
    readonly lceil: "⌈";
    readonly ldquo: "“";
    readonly le: "≤";
    readonly lfloor: "⌊";
    readonly lowast: "∗";
    readonly loz: "◊";
    readonly lrm: "‎";
    readonly lsaquo: "‹";
    readonly lsquo: "‘";
    readonly lt: "<";
    readonly macr: "¯";
    readonly mdash: "—";
    readonly micro: "µ";
    readonly middot: "·";
    readonly minus: "−";
    readonly Mu: "Μ";
    readonly mu: "μ";
    readonly nabla: "∇";
    readonly nbsp: " ";
    readonly ndash: "–";
    readonly ne: "≠";
    readonly ni: "∋";
    readonly not: "¬";
    readonly notin: "∉";
    readonly nsub: "⊄";
    readonly Ntilde: "Ñ";
    readonly ntilde: "ñ";
    readonly Nu: "Ν";
    readonly nu: "ν";
    readonly Oacute: "Ó";
    readonly oacute: "ó";
    readonly Ocirc: "Ô";
    readonly ocirc: "ô";
    readonly OElig: "Œ";
    readonly oelig: "œ";
    readonly Ograve: "Ò";
    readonly ograve: "ò";
    readonly oline: "‾";
    readonly Omega: "Ω";
    readonly omega: "ω";
    readonly Omicron: "Ο";
    readonly omicron: "ο";
    readonly oplus: "⊕";
    readonly or: "∨";
    readonly ordf: "ª";
    readonly ordm: "º";
    readonly Oslash: "Ø";
    readonly oslash: "ø";
    readonly Otilde: "Õ";
    readonly otilde: "õ";
    readonly otimes: "⊗";
    readonly Ouml: "Ö";
    readonly ouml: "ö";
    readonly para: "¶";
    readonly part: "∂";
    readonly permil: "‰";
    readonly perp: "⊥";
    readonly Phi: "Φ";
    readonly phi: "φ";
    readonly Pi: "Π";
    readonly pi: "π";
    readonly piv: "ϖ";
    readonly plusmn: "±";
    readonly pound: "£";
    readonly prime: "′";
    readonly Prime: "″";
    readonly prod: "∏";
    readonly prop: "∝";
    readonly Psi: "Ψ";
    readonly psi: "ψ";
    readonly quot: "\"";
    readonly radic: "√";
    readonly rang: "〉";
    readonly raquo: "»";
    readonly rarr: "→";
    readonly rArr: "⇒";
    readonly rceil: "⌉";
    readonly rdquo: "”";
    readonly real: "ℜ";
    readonly reg: "®";
    readonly rfloor: "⌋";
    readonly Rho: "Ρ";
    readonly rho: "ρ";
    readonly rlm: "‏";
    readonly rsaquo: "›";
    readonly rsquo: "’";
    readonly sbquo: "‚";
    readonly Scaron: "Š";
    readonly scaron: "š";
    readonly sdot: "⋅";
    readonly sect: "§";
    readonly shy: "­";
    readonly Sigma: "Σ";
    readonly sigma: "σ";
    readonly sigmaf: "ς";
    readonly sim: "∼";
    readonly spades: "♠";
    readonly sub: "⊂";
    readonly sube: "⊆";
    readonly sum: "∑";
    readonly sup: "⊃";
    readonly sup1: "¹";
    readonly sup2: "²";
    readonly sup3: "³";
    readonly supe: "⊇";
    readonly szlig: "ß";
    readonly Tau: "Τ";
    readonly tau: "τ";
    readonly there4: "∴";
    readonly Theta: "Θ";
    readonly theta: "θ";
    readonly thetasym: "ϑ";
    readonly thinsp: " ";
    readonly THORN: "Þ";
    readonly thorn: "þ";
    readonly tilde: "˜";
    readonly times: "×";
    readonly trade: "™";
    readonly Uacute: "Ú";
    readonly uacute: "ú";
    readonly uarr: "↑";
    readonly uArr: "⇑";
    readonly Ucirc: "Û";
    readonly ucirc: "û";
    readonly Ugrave: "Ù";
    readonly ugrave: "ù";
    readonly uml: "¨";
    readonly upsih: "ϒ";
    readonly Upsilon: "Υ";
    readonly upsilon: "υ";
    readonly Uuml: "Ü";
    readonly uuml: "ü";
    readonly weierp: "℘";
    readonly Xi: "Ξ";
    readonly xi: "ξ";
    readonly Yacute: "Ý";
    readonly yacute: "ý";
    readonly yen: "¥";
    readonly yuml: "ÿ";
    readonly Yuml: "Ÿ";
    readonly Zeta: "Ζ";
    readonly zeta: "ζ";
    readonly zwj: "‍";
    readonly zwnj: "‌";
}>;

export { DEFAULT_JSX_VALUE_HINT, JSXValueHint, findPropInAttributes, findPropInProperties, getElementName, getProp, getPropName, getPropValue, hasAnyProp, hasEveryProp, hasProp, isBuiltInElement, isJSXValue, isKeyedElement, isLineBreak, isLiteral, isPaddingSpaces, isUserDefinedElement, isWhiteSpace, traverseUpProp, unescapeStringLiteralText, xhtmlEntities };
