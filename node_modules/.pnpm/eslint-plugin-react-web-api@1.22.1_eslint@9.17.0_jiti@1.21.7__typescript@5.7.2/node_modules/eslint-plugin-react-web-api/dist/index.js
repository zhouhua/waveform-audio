'use strict';

var AST2 = require('@eslint-react/ast');
var core = require('@eslint-react/core');
var eff = require('@eslint-react/eff');
var JSX = require('@eslint-react/jsx');
var VAR2 = require('@eslint-react/var');
var utils = require('@typescript-eslint/utils');
var tsPattern = require('ts-pattern');
var shared = require('@eslint-react/shared');
var types = require('@typescript-eslint/types');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var AST2__namespace = /*#__PURE__*/_interopNamespace(AST2);
var JSX__namespace = /*#__PURE__*/_interopNamespace(JSX);
var VAR2__namespace = /*#__PURE__*/_interopNamespace(VAR2);

// package.json
var name = "eslint-plugin-react-web-api";
var version = "1.22.1";
var createRule = shared.createRuleForPlugin("web-api");
function getInstanceID(node, prev) {
  switch (true) {
    case (node.type === types.AST_NODE_TYPES.VariableDeclarator && node.init === prev):
      return eff.O.some(node.id);
    case (node.type === types.AST_NODE_TYPES.AssignmentExpression && node.right === prev):
      return eff.O.some(node.left);
    case (node.type === types.AST_NODE_TYPES.PropertyDefinition && node.value === prev):
      return eff.O.some(node.key);
    case (node.type === types.AST_NODE_TYPES.BlockStatement || node.type === types.AST_NODE_TYPES.Program || node.parent === node):
      return eff.O.none();
    default:
      return getInstanceID(node.parent, node);
  }
}
function getPhaseKindOfFunction(node) {
  return tsPattern.match(node).when(core.isSetupFunction, () => eff.O.some("setup")).when(core.isCleanupFunction, () => eff.O.some("cleanup")).when(core.isComponentDidMountFunction, () => eff.O.some("mount")).when(core.isComponentWillUnmountFunction, () => eff.O.some("unmount")).otherwise(eff.O.none);
}
function isInstanceIDEqual(a, b, context) {
  return AST2__namespace.isNodeEqual(a, b) || VAR2__namespace.isNodeValueEqual(a, b, [
    context.sourceCode.getScope(a),
    context.sourceCode.getScope(b)
  ]);
}
var EventListenerEntry = eff.Data.taggedEnum();
var ObserverEntry = eff.Data.taggedEnum();

// src/rules/no-leaked-event-listener.ts
var RULE_NAME = "no-leaked-event-listener";
var RULE_FEATURES = [
  "CHK"
];
var defaultOptions = {
  capture: eff.O.some(false),
  once: eff.O.some(false),
  signal: eff.O.none()
};
function getCallKind(node) {
  switch (true) {
    case (node.callee.type === utils.AST_NODE_TYPES.Identifier && tsPattern.isMatching(tsPattern.P.union("addEventListener", "removeEventListener", "abort"), node.callee.name)):
      return node.callee.name;
    case (node.callee.type === utils.AST_NODE_TYPES.MemberExpression && node.callee.property.type === utils.AST_NODE_TYPES.Identifier && tsPattern.isMatching(tsPattern.P.union("addEventListener", "removeEventListener", "abort"), node.callee.property.name)):
      return node.callee.property.name;
    default:
      return "other";
  }
}
function getFunctionKind(node) {
  return eff.O.getOrElse(getPhaseKindOfFunction(node), eff.F.constant("other"));
}
function getOptions(node, initialScope) {
  const findProp = (properties, propName) => {
    return JSX__namespace.findPropInProperties(properties, initialScope)(propName);
  };
  const getPropValue = (prop) => {
    if (prop.type !== utils.AST_NODE_TYPES.Property) return eff.O.none();
    const { value } = prop;
    switch (value.type) {
      case utils.AST_NODE_TYPES.Literal: {
        return eff.O.some(value.value);
      }
      default: {
        return VAR2__namespace.getStaticValue(value, initialScope);
      }
    }
  };
  function getOpts(node2) {
    switch (node2.type) {
      case utils.AST_NODE_TYPES.Identifier: {
        return eff.F.pipe(
          VAR2__namespace.findVariable(node2, initialScope),
          eff.O.flatMap(VAR2__namespace.getVariableNode(0)),
          eff.O.filter(AST2__namespace.is(utils.AST_NODE_TYPES.ObjectExpression)),
          eff.O.map(getOpts),
          eff.O.getOrElse(() => defaultOptions)
        );
      }
      case utils.AST_NODE_TYPES.Literal: {
        return { ...defaultOptions, capture: eff.O.some(!!node2.value) };
      }
      case utils.AST_NODE_TYPES.ObjectExpression: {
        const pOnce = findProp(node2.properties, "once");
        const vOnce = eff.O.flatMap(pOnce, getPropValue).pipe(eff.O.filter(eff.isBoolean));
        const pCapture = findProp(node2.properties, "capture");
        const vCapture = eff.O.flatMap(pCapture, getPropValue).pipe(eff.O.filter(eff.isBoolean));
        const pSignal = findProp(node2.properties, "signal");
        const vSignal = eff.O.flatMap(pSignal, (prop) => {
          if (prop.type !== utils.AST_NODE_TYPES.Property) return eff.O.none();
          const { value } = prop;
          const getSignalExp = (node3) => {
            switch (node3.type) {
              case utils.AST_NODE_TYPES.Identifier:
                return eff.F.pipe(
                  VAR2__namespace.findVariable(node3, initialScope),
                  eff.O.flatMap(VAR2__namespace.getVariableNode(0)),
                  eff.O.flatMap(getSignalExp)
                );
              case utils.AST_NODE_TYPES.MemberExpression:
                return eff.O.some(node3);
              default:
                return eff.O.none();
            }
          };
          return getSignalExp(value);
        });
        return { capture: vCapture, once: vOnce, signal: vSignal };
      }
      default: {
        return defaultOptions;
      }
    }
  }
  return getOpts(node);
}
var no_leaked_event_listener_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce that every 'addEventListener' in a component or custom Hook has a corresponding 'removeEventListener'.",
      [Symbol.for("rule_features")]: RULE_FEATURES
    },
    messages: {
      noLeakedEventListenerInEffect: "A 'addEventListener' in '{{effectMethodKind}}' should have a corresponding 'removeEventListener' in its cleanup function.",
      noLeakedEventListenerInLifecycle: "A 'addEventListener' in 'componentDidMount' should have a corresponding 'removeEventListener' in 'componentWillUnmount' method.",
      noLeakedEventListenerOfInlineFunction: "A '{{eventMethodKind}}' should not have an inline listener function."
    },
    schema: []
  },
  name: RULE_NAME,
  create(context) {
    if (!context.sourceCode.text.includes("addEventListener")) return {};
    if (!/use\w*Effect|componentDidMount|componentWillUnmount/u.test(context.sourceCode.text)) return {};
    const fStack = [];
    const aEntries = [];
    const rEntries = [];
    const abortedSignals = [];
    function checkInlineFunction(node, callKind, options) {
      const [_, listener] = node.arguments;
      if (!AST2__namespace.isFunction(listener)) return eff.O.none();
      if (eff.O.isSome(options.signal)) return eff.O.none();
      return eff.O.some({
        messageId: "noLeakedEventListenerOfInlineFunction",
        node: listener,
        data: { eventMethodKind: callKind }
      });
    }
    const isSameObject = eff.F.dual(2, (a, b) => {
      switch (true) {
        case (a.type === utils.AST_NODE_TYPES.MemberExpression && b.type === utils.AST_NODE_TYPES.MemberExpression):
          return AST2__namespace.isNodeEqual(a.object, b.object);
        // TODO: Maybe there other cases to consider here.
        default:
          return false;
      }
    });
    const isInverseEntry = eff.F.dual(2, (aEntry, rEntry) => {
      const { type: aType, callee: aCallee, capture: aCapture, listener: aListener, phase: aPhase } = aEntry;
      const { type: rType, callee: rCallee, capture: rCapture, listener: rListener, phase: rPhase } = rEntry;
      if (!core.isInversePhase(aPhase, rPhase)) return false;
      return isSameObject(aCallee, rCallee) && AST2__namespace.isNodeEqual(aListener, rListener) && VAR2__namespace.isNodeValueEqual(aType, rType, [
        context.sourceCode.getScope(aType),
        context.sourceCode.getScope(rType)
      ]) && eff.O.getOrElse(aCapture, eff.F.constFalse) === eff.O.getOrElse(rCapture, eff.F.constFalse);
    });
    return {
      [":function"](node) {
        const functionKind = getFunctionKind(node);
        fStack.push([node, functionKind]);
      },
      [":function:exit"]() {
        fStack.pop();
      },
      ["CallExpression"](node) {
        const [fNode, fKind] = fStack.findLast((f) => f.at(1) !== "other") ?? [];
        if (!fNode || !fKind) return;
        if (!core.ERPhaseRelevance.has(fKind)) return;
        tsPattern.match(getCallKind(node)).with("addEventListener", (callKind) => {
          const [type, listener, options] = node.arguments;
          if (!type || !listener) return;
          const opts = options ? getOptions(options, context.sourceCode.getScope(options)) : defaultOptions;
          const { callee } = node;
          eff.O.map(checkInlineFunction(node, callKind, opts), context.report);
          aEntries.push(EventListenerEntry.AddEventListener({
            ...opts,
            type,
            node,
            callee,
            listener,
            phase: fKind
          }));
        }).with("removeEventListener", (callKind) => {
          const [type, listener, options] = node.arguments;
          if (!type || !listener) return;
          const opts = options ? getOptions(options, context.sourceCode.getScope(options)) : defaultOptions;
          const { callee } = node;
          eff.O.map(checkInlineFunction(node, callKind, opts), context.report);
          rEntries.push(EventListenerEntry.RemoveEventListener({
            ...opts,
            type,
            node,
            callee,
            listener,
            phase: fKind
          }));
        }).with("abort", () => {
          abortedSignals.push(node.callee);
        }).otherwise(eff.F.constVoid);
      },
      ["Program:exit"]() {
        for (const aEntry of aEntries) {
          if (eff.O.exists(aEntry.signal, (signal) => abortedSignals.some(isSameObject(signal)))) continue;
          if (rEntries.some(isInverseEntry(aEntry))) continue;
          switch (aEntry.phase) {
            case "cleanup":
            case "setup":
              context.report({
                messageId: "noLeakedEventListenerInEffect",
                node: aEntry.node,
                data: {
                  effectMethodKind: "useEffect"
                }
              });
              continue;
            case "mount":
            case "unmount":
              context.report({
                messageId: "noLeakedEventListenerInLifecycle",
                node: aEntry.node
              });
              continue;
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME2 = "no-leaked-interval";
var RULE_FEATURES2 = [
  "CHK"
];
function getCallKind2(node) {
  switch (true) {
    case (node.callee.type === utils.AST_NODE_TYPES.Identifier && tsPattern.isMatching(tsPattern.P.union("setInterval", "clearInterval"), node.callee.name)):
      return node.callee.name;
    case (node.callee.type === utils.AST_NODE_TYPES.MemberExpression && node.callee.property.type === utils.AST_NODE_TYPES.Identifier && tsPattern.isMatching(tsPattern.P.union("setInterval", "clearInterval"), node.callee.property.name)):
      return node.callee.property.name;
    default:
      return "other";
  }
}
var no_leaked_interval_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce that every 'setInterval' in a component or custom Hook has a corresponding 'clearInterval'.",
      [Symbol.for("rule_features")]: RULE_FEATURES2
    },
    messages: {
      noLeakedIntervalInEffect: "A 'setInterval' created in '{{ kind }}' must be cleared with 'clearInterval' in the cleanup function.",
      noLeakedIntervalInLifecycle: "A 'setInterval' created in '{{ kind }}' must be cleared with 'clearInterval' in the 'componentWillUnmount' method.",
      noLeakedIntervalNoIntervalId: "A 'setInterval' must be assigned to a variable for proper cleanup."
    },
    schema: []
  },
  name: RULE_NAME2,
  create(context) {
    if (!context.sourceCode.text.includes("setInterval")) return {};
    const fStack = [];
    const sEntries = [];
    const cEntries = [];
    const isInverseEntry = eff.F.dual(2, (a, b) => {
      return isInstanceIDEqual(a.timerID, b.timerID, context);
    });
    return {
      [":function"](node) {
        const fKind = eff.O.getOrElse(getPhaseKindOfFunction(node), () => "other");
        fStack.push([node, fKind]);
      },
      [":function:exit"]() {
        fStack.pop();
      },
      ["CallExpression"](node) {
        switch (getCallKind2(node)) {
          case "clearInterval": {
            const [fNode, fKind] = fStack.findLast((f) => f.at(1) !== "other") ?? [];
            if (!fNode || !fKind) break;
            if (!core.ERPhaseRelevance.has(fKind)) break;
            const [intervalIdNode] = node.arguments;
            if (!intervalIdNode) break;
            cEntries.push({
              kind: "interval",
              node,
              callee: node.callee,
              phase: fKind,
              timerID: intervalIdNode
            });
            break;
          }
          case "setInterval": {
            const [fNode, fKind] = fStack.findLast((f) => f.at(1) !== "other") ?? [];
            if (!fNode || !fKind) break;
            if (!core.ERPhaseRelevance.has(fKind)) break;
            const intervalIdNode = eff.O.getOrNull(VAR2__namespace.getVariableDeclaratorID(node));
            if (!intervalIdNode) {
              context.report({
                messageId: "noLeakedIntervalNoIntervalId",
                node
              });
              break;
            }
            sEntries.push({
              kind: "interval",
              node,
              callee: node.callee,
              phase: fKind,
              timerID: intervalIdNode
            });
            break;
          }
        }
      },
      ["Program:exit"]() {
        for (const sEntry of sEntries) {
          if (cEntries.some(isInverseEntry(sEntry))) continue;
          switch (sEntry.phase) {
            case "cleanup":
            case "setup":
              context.report({
                messageId: "noLeakedIntervalInEffect",
                node: sEntry.node,
                data: {
                  kind: "useEffect"
                }
              });
              continue;
            case "mount":
            case "unmount":
              context.report({
                messageId: "noLeakedIntervalInLifecycle",
                node: sEntry.node,
                data: {
                  kind: "componentDidMount"
                }
              });
              continue;
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME3 = "no-leaked-resize-observer";
var RULE_FEATURES3 = [
  "CHK"
];
function isNewResizeObserver(node) {
  return node.type === utils.AST_NODE_TYPES.NewExpression && node.callee.type === utils.AST_NODE_TYPES.Identifier && node.callee.name === "ResizeObserver";
}
function isFromObserver(node, context) {
  switch (true) {
    case node.type === utils.AST_NODE_TYPES.Identifier:
      return eff.F.pipe(
        VAR2__namespace.findVariable(node, context.sourceCode.getScope(node)),
        eff.O.flatMap(VAR2__namespace.getVariableNode(0)),
        eff.O.exists(isNewResizeObserver)
      );
    case node.type === utils.AST_NODE_TYPES.MemberExpression:
      return isFromObserver(node.object, context);
    default:
      return false;
  }
}
function getCallKind3(node, context) {
  switch (true) {
    case (node.callee.type === utils.AST_NODE_TYPES.Identifier && tsPattern.isMatching(tsPattern.P.union("observe", "unobserve", "disconnect"), node.callee.name) && isFromObserver(node.callee, context)):
      return node.callee.name;
    case (node.callee.type === utils.AST_NODE_TYPES.MemberExpression && node.callee.property.type === utils.AST_NODE_TYPES.Identifier && tsPattern.isMatching(tsPattern.P.union("observe", "unobserve", "disconnect"), node.callee.property.name) && isFromObserver(node.callee, context)):
      return node.callee.property.name;
    default:
      return "other";
  }
}
function getFunctionKind2(node) {
  return eff.O.getOrElse(getPhaseKindOfFunction(node), eff.F.constant("other"));
}
var no_leaked_resize_observer_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce cleanup of 'ResizeObserver' instances in components and custom Hooks.",
      [Symbol.for("rule_features")]: RULE_FEATURES3
    },
    messages: {
      noLeakedResizeObserver: "A 'ResizeObserver' instance created in 'useEffect' must be disconnected in the cleanup function.",
      noLeakedResizeObserverInControlFlow: "Dynamically added 'ResizeObserver.observe' should be cleared all at once using 'ResizeObserver.disconnect' in the cleanup function.",
      noLeakedResizeObserverNoFloatingInstance: "A 'ResizeObserver' instance created in component or custom Hook must be assigned to a variable for proper cleanup."
    },
    schema: []
  },
  name: RULE_NAME3,
  create(context) {
    if (!context.sourceCode.text.includes("ResizeObserver")) return {};
    const fStack = [];
    const observers = [];
    const oEntries = [];
    const uEntries = [];
    const dEntries = [];
    return {
      [":function"](node) {
        const functionKind = getFunctionKind2(node);
        fStack.push([node, functionKind]);
      },
      [":function:exit"]() {
        fStack.pop();
      },
      ["CallExpression"](node) {
        const [_, fKind] = fStack.findLast((f) => f.at(1) !== "other") ?? [];
        if (node.callee.type !== utils.AST_NODE_TYPES.MemberExpression) return;
        if (!core.ERPhaseRelevance.has(fKind)) return;
        const { object } = node.callee;
        tsPattern.match(getCallKind3(node, context)).with("disconnect", () => {
          dEntries.push(
            ObserverEntry.Disconnect({
              kind: "ResizeObserver",
              node,
              callee: node.callee,
              observer: object,
              phase: fKind
            })
          );
        }).with("observe", () => {
          const [element] = node.arguments;
          if (!element) return;
          oEntries.push(
            ObserverEntry.Observe({
              kind: "ResizeObserver",
              node,
              callee: node.callee,
              element,
              observer: object,
              phase: fKind
            })
          );
        }).with("unobserve", () => {
          const [element] = node.arguments;
          if (!element) return;
          uEntries.push(
            ObserverEntry.Unobserve({
              kind: "ResizeObserver",
              node,
              callee: node.callee,
              element,
              observer: object,
              phase: fKind
            })
          );
        }).otherwise(eff.F.constVoid);
      },
      ["NewExpression"](node) {
        const [fNode, fKind] = fStack.findLast((f) => f.at(1) !== "other") ?? [];
        if (!fNode || !core.ERPhaseRelevance.has(fKind)) return;
        if (!isNewResizeObserver(node)) return;
        const id = getInstanceID(node);
        if (eff.O.isNone(id)) {
          context.report({
            messageId: "noLeakedResizeObserverNoFloatingInstance",
            node
          });
          return;
        }
        observers.push([node, id.value, fKind, fNode]);
      },
      ["Program:exit"]() {
        for (const [node, id, _, phaseNode] of observers) {
          if (dEntries.some((e) => isInstanceIDEqual(e.observer, id, context))) continue;
          const oentries = oEntries.filter((e) => isInstanceIDEqual(e.observer, id, context));
          const uentries = uEntries.filter((e) => isInstanceIDEqual(e.observer, id, context));
          const isDynamic = eff.or(AST2__namespace.isConditional, AST2__namespace.is(utils.AST_NODE_TYPES.CallExpression));
          const isPhaseNode = (node2) => node2 === phaseNode;
          const hasDynamicallyAdded = oentries.some((e) => eff.O.exists(AST2__namespace.traverseUp(e.node, eff.or(isDynamic, isPhaseNode)), eff.not(isPhaseNode)));
          if (hasDynamicallyAdded) {
            context.report({ messageId: "noLeakedResizeObserverInControlFlow", node });
            continue;
          }
          for (const oEntry of oentries) {
            if (uentries.some((uEntry) => isInstanceIDEqual(uEntry.element, oEntry.element, context))) continue;
            context.report({ messageId: "noLeakedResizeObserver", node: oEntry.node });
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME4 = "no-leaked-timeout";
var RULE_FEATURES4 = [
  "CHK"
];
function getCallKind4(node) {
  switch (true) {
    case (node.callee.type === utils.AST_NODE_TYPES.Identifier && tsPattern.isMatching(tsPattern.P.union("setTimeout", "clearTimeout"), node.callee.name)):
      return node.callee.name;
    case (node.callee.type === utils.AST_NODE_TYPES.MemberExpression && node.callee.property.type === utils.AST_NODE_TYPES.Identifier && tsPattern.isMatching(tsPattern.P.union("setTimeout", "clearTimeout"), node.callee.property.name)):
      return node.callee.property.name;
    default:
      return "other";
  }
}
var no_leaked_timeout_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce that every 'setTimeout' in a component or custom Hook has a corresponding 'clearTimeout'.",
      [Symbol.for("rule_features")]: RULE_FEATURES4
    },
    messages: {
      noLeakedTimeoutInEffect: "A 'setTimeout' created in '{{ kind }}' must be cleared with 'clearTimeout' in the cleanup function.",
      noLeakedTimeoutInLifecycle: "A 'setTimeout' created in '{{ kind }}' must be cleared with 'clearTimeout' in the 'componentWillUnmount' method.",
      noLeakedTimeoutNoTimeoutId: "A 'setTimeout' must be assigned to a variable for proper cleanup."
    },
    schema: []
  },
  name: RULE_NAME4,
  create(context) {
    if (!context.sourceCode.text.includes("setTimeout")) return {};
    const fStack = [];
    const sEntries = [];
    const rEntries = [];
    const isInverseEntry = eff.F.dual(2, (a, b) => {
      return isInstanceIDEqual(a.timerID, b.timerID, context);
    });
    return {
      [":function"](node) {
        const fKind = eff.O.getOrElse(getPhaseKindOfFunction(node), () => "other");
        fStack.push([node, fKind]);
      },
      [":function:exit"]() {
        fStack.pop();
      },
      ["CallExpression"](node) {
        const [fNode, fKind] = fStack.findLast((f) => f.at(1) !== "other") ?? [];
        if (!fNode || !fKind) return;
        if (!core.ERPhaseRelevance.has(fKind)) return;
        switch (getCallKind4(node)) {
          case "clearTimeout": {
            const [timeoutIdNode] = node.arguments;
            if (!timeoutIdNode) break;
            rEntries.push({
              kind: "timeout",
              node,
              callee: node.callee,
              phase: fKind,
              timerID: timeoutIdNode
            });
            break;
          }
          case "setTimeout": {
            const timeoutIdNode = eff.O.getOrNull(VAR2__namespace.getVariableDeclaratorID(node));
            if (!timeoutIdNode) {
              context.report({
                messageId: "noLeakedTimeoutNoTimeoutId",
                node
              });
              break;
            }
            sEntries.push({
              kind: "timeout",
              node,
              callee: node.callee,
              phase: fKind,
              timerID: timeoutIdNode
            });
            break;
          }
        }
      },
      ["Program:exit"]() {
        for (const sEntry of sEntries) {
          if (rEntries.some(isInverseEntry(sEntry))) continue;
          switch (sEntry.phase) {
            case "cleanup":
            case "setup":
              context.report({
                messageId: "noLeakedTimeoutInEffect",
                node: sEntry.node,
                data: {
                  kind: "useEffect"
                }
              });
              continue;
            case "mount":
            case "unmount":
              context.report({
                messageId: "noLeakedTimeoutInLifecycle",
                node: sEntry.node,
                data: {
                  kind: "componentDidMount"
                }
              });
              continue;
          }
        }
      }
    };
  },
  defaultOptions: []
});

// src/index.ts
var index_default = {
  meta: {
    name,
    version
  },
  rules: {
    "no-leaked-event-listener": no_leaked_event_listener_default,
    "no-leaked-interval": no_leaked_interval_default,
    "no-leaked-resize-observer": no_leaked_resize_observer_default,
    "no-leaked-timeout": no_leaked_timeout_default
  }
};

module.exports = index_default;
