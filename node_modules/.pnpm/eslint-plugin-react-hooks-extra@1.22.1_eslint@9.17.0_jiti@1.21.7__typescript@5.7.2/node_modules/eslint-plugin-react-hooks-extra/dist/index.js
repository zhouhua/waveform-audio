'use strict';

var AST2 = require('@eslint-react/ast');
var core = require('@eslint-react/core');
var eff = require('@eslint-react/eff');
var shared = require('@eslint-react/shared');
var VAR5 = require('@eslint-react/var');
var types = require('@typescript-eslint/types');
var tsPattern = require('ts-pattern');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var AST2__namespace = /*#__PURE__*/_interopNamespace(AST2);
var VAR5__namespace = /*#__PURE__*/_interopNamespace(VAR5);

// package.json
var name = "eslint-plugin-react-hooks-extra";
var version = "1.22.1";
var createRule = shared.createRuleForPlugin("hooks-extra");
function isFromHookCall(name2, context, settings, predicate = eff.F.constTrue) {
  const hookAlias = settings.additionalHooks?.[name2] ?? [];
  return (topLevelId) => eff.F.pipe(
    VAR5__namespace.findVariable(topLevelId, context.sourceCode.getScope(topLevelId)),
    eff.O.flatMap(VAR5__namespace.getVariableNode(0)),
    eff.O.filter(AST2__namespace.is(types.AST_NODE_TYPES.CallExpression)),
    eff.O.filter(core.isReactHookCallWithNameAlias(name2, context, hookAlias)),
    eff.O.exists((call) => predicate(topLevelId, call))
  );
}
function isFromUseStateCall(context, settings) {
  const predicate = (topLevelId, call) => {
    const { parent } = call;
    if (!("id" in parent && parent.id?.type === types.AST_NODE_TYPES.ArrayPattern)) return true;
    return parent.id.elements.findIndex((e) => e?.type === types.AST_NODE_TYPES.Identifier && e.name === topLevelId.name) === 1;
  };
  return isFromHookCall("useState", context, settings, predicate);
}
function isSetFunctionCall(context, settings) {
  const isIdFromUseStateCall = isFromUseStateCall(context, settings);
  return (node) => {
    switch (node.callee.type) {
      // const data = useState();
      // data.at(1)();
      case types.AST_NODE_TYPES.CallExpression: {
        const { callee } = node.callee;
        if (callee.type !== types.AST_NODE_TYPES.MemberExpression) return false;
        if (!("name" in callee.object)) return false;
        const isAt = tsPattern.isMatching({
          type: types.AST_NODE_TYPES.MemberExpression,
          property: {
            type: types.AST_NODE_TYPES.Identifier,
            name: "at"
          }
        }, callee);
        const [index] = node.callee.arguments;
        if (!isAt || !index) return false;
        const initialScope = context.sourceCode.getScope(node);
        return eff.O.exists(VAR5__namespace.getStaticValue(index, initialScope), (v) => v === 1) && isIdFromUseStateCall(callee.object);
      }
      // const [data, setData] = useState();
      // setData();
      case types.AST_NODE_TYPES.Identifier: {
        return isIdFromUseStateCall(node.callee);
      }
      // const data = useState();
      // data[1]();
      case types.AST_NODE_TYPES.MemberExpression: {
        if (!("name" in node.callee.object)) return false;
        const initialScope = context.sourceCode.getScope(node);
        return eff.O.exists(VAR5__namespace.getStaticValue(node.callee.property, initialScope), (v) => v === 1) && isIdFromUseStateCall(node.callee.object);
      }
      default: {
        return false;
      }
    }
  };
}
function isThenCall(node) {
  return node.callee.type === types.AST_NODE_TYPES.MemberExpression && node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === "then";
}
function isVariableDeclaratorFromHookCall(node) {
  if (node.type !== types.AST_NODE_TYPES.VariableDeclarator) return false;
  if (node.id.type !== types.AST_NODE_TYPES.Identifier) return false;
  if (node.init?.type !== types.AST_NODE_TYPES.CallExpression) return false;
  switch (node.init.callee.type) {
    case types.AST_NODE_TYPES.Identifier:
      return core.isReactHookName(node.init.callee.name);
    case types.AST_NODE_TYPES.MemberExpression:
      return node.init.callee.property.type === types.AST_NODE_TYPES.Identifier && core.isReactHookName(node.init.callee.property.name);
    default:
      return false;
  }
}

// src/rules/no-direct-set-state-in-use-effect.ts
var RULE_NAME = "no-direct-set-state-in-use-effect";
var RULE_FEATURES = [
  "CHK"
];
var no_direct_set_state_in_use_effect_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow direct calls to the 'set' function of 'useState' in 'useEffect'",
      [Symbol.for("rule_features")]: RULE_FEATURES
    },
    messages: {
      noDirectSetStateInUseEffect: "Do not call the 'set' function '{{name}}' of 'useState' directly in 'useEffect'."
    },
    schema: []
  },
  name: RULE_NAME,
  create(context) {
    if (!/use\w*Effect/u.test(context.sourceCode.text)) return {};
    const settings = shared.decodeSettings(context.settings);
    const additionalHooks = settings.additionalHooks ?? {};
    const isUseEffectLikeCall = core.isReactHookCallWithNameAlias("useEffect", context, additionalHooks.useEffect ?? []);
    const isUseStateCall2 = core.isReactHookCallWithNameAlias("useState", context, additionalHooks.useState ?? []);
    const isUseMemoCall2 = core.isReactHookCallWithNameAlias("useMemo", context, additionalHooks.useMemo ?? []);
    const isUseCallbackCall2 = core.isReactHookCallWithNameAlias("useCallback", context, additionalHooks.useCallback ?? []);
    const isSetStateCall = isSetFunctionCall(context, settings);
    const isIdFromUseStateCall = isFromUseStateCall(context, settings);
    const functionStack = [];
    const setupFunctionRef = eff.MutRef.make(null);
    const setupFunctionIdentifiers = [];
    const indirectFunctionCalls = [];
    const indirectSetStateCalls = /* @__PURE__ */ new WeakMap();
    const indirectSetStateCallsAsArgs = /* @__PURE__ */ new WeakMap();
    const indirectSetStateCallsAsSetups = /* @__PURE__ */ new Map();
    const indirectSetStateCallsInHooks = /* @__PURE__ */ new WeakMap();
    const onSetupFunctionEnter = (node) => {
      eff.MutRef.set(setupFunctionRef, node);
    };
    const onSetupFunctionExit = (node) => {
      eff.MutRef.update(setupFunctionRef, (current) => current === node ? null : current);
    };
    function isSetupFunction(node) {
      return node.parent?.type === types.AST_NODE_TYPES.CallExpression && node.parent.callee !== node && isUseEffectLikeCall(node.parent);
    }
    function getCallKind(node) {
      return tsPattern.match(node).when(isUseStateCall2, () => "useState").when(isUseEffectLikeCall, () => "useEffect").when(isSetStateCall, () => "setState").when(isThenCall, () => "then").otherwise(() => "other");
    }
    function getFunctionKind(node) {
      return tsPattern.match(node).when(isSetupFunction, () => "setup").when(AST2__namespace.isFunctionOfImmediatelyInvoked, () => "immediate").otherwise(() => "other");
    }
    return {
      ":function"(node) {
        const functionKind = getFunctionKind(node);
        functionStack.push([node, functionKind]);
        if (functionKind === "setup") onSetupFunctionEnter(node);
      },
      ":function:exit"(node) {
        const [_, functionKind] = functionStack.at(-1) ?? [];
        functionStack.pop();
        if (functionKind === "setup") onSetupFunctionExit(node);
      },
      CallExpression(node) {
        const effectFn = eff.MutRef.get(setupFunctionRef);
        const [parentFn, parentFnKind] = functionStack.at(-1) ?? [];
        if (parentFn?.async) return;
        tsPattern.match(getCallKind(node)).with("setState", () => {
          if (!parentFn) return;
          if (parentFn !== effectFn && parentFnKind !== "immediate") {
            const maybeVd = AST2__namespace.traverseUpGuard(node, isVariableDeclaratorFromHookCall);
            if (eff.O.isSome(maybeVd)) {
              const vd = maybeVd.value;
              const calls2 = indirectSetStateCallsInHooks.get(vd.init) ?? [];
              indirectSetStateCallsInHooks.set(vd.init, [...calls2, node]);
              return;
            }
            const calls = indirectSetStateCalls.get(parentFn) ?? [];
            indirectSetStateCalls.set(parentFn, [...calls, node]);
            return;
          }
          context.report({
            messageId: "noDirectSetStateInUseEffect",
            node,
            data: { name: context.sourceCode.getText(node.callee) }
          });
        }).with("useEffect", () => {
          const [firstArg] = node.arguments;
          if (AST2__namespace.isFunction(firstArg)) return;
          const identifiers = AST2__namespace.getNestedIdentifiers(node);
          setupFunctionIdentifiers.push(...identifiers);
        }).with("other", () => {
          const isInSetupFunction = effectFn === parentFn;
          if (!isInSetupFunction) return;
          indirectFunctionCalls.push(node);
        }).otherwise(eff.F.constVoid);
      },
      Identifier(node) {
        if (node.parent.type === types.AST_NODE_TYPES.CallExpression && node.parent.callee === node) return;
        if (!isIdFromUseStateCall(node)) return;
        switch (node.parent.type) {
          case types.AST_NODE_TYPES.ArrowFunctionExpression: {
            const parent = node.parent.parent;
            if (parent.type !== types.AST_NODE_TYPES.CallExpression) break;
            if (!isUseMemoCall2(parent)) break;
            const maybeVd = AST2__namespace.traverseUpGuard(parent, isVariableDeclaratorFromHookCall);
            if (eff.O.isNone(maybeVd)) break;
            const vd = maybeVd.value;
            const calls = indirectSetStateCallsAsArgs.get(vd.init) ?? [];
            indirectSetStateCallsAsArgs.set(vd.init, [...calls, node]);
            break;
          }
          case types.AST_NODE_TYPES.CallExpression: {
            const [firstArg] = node.parent.arguments;
            if (node !== firstArg) break;
            if (isUseCallbackCall2(node.parent)) {
              const maybeVd = AST2__namespace.traverseUpGuard(node.parent, isVariableDeclaratorFromHookCall);
              if (eff.O.isNone(maybeVd)) break;
              const vd = maybeVd.value;
              const calls = indirectSetStateCallsAsArgs.get(vd.init) ?? [];
              indirectSetStateCallsAsArgs.set(vd.init, [...calls, node]);
            }
            if (isUseEffectLikeCall(node.parent)) {
              const calls = indirectSetStateCallsAsArgs.get(node.parent) ?? [];
              indirectSetStateCallsAsSetups.set(node.parent, [...calls, node]);
            }
            break;
          }
        }
      },
      "Program:exit"() {
        const getSetStateCalls = (id, initialScope) => {
          const node = eff.O.flatMap(VAR5__namespace.findVariable(id, initialScope), VAR5__namespace.getVariableNode(0)).pipe(eff.O.getOrNull);
          switch (node?.type) {
            case types.AST_NODE_TYPES.ArrowFunctionExpression:
            case types.AST_NODE_TYPES.FunctionDeclaration:
            case types.AST_NODE_TYPES.FunctionExpression:
              return indirectSetStateCalls.get(node) ?? [];
            case types.AST_NODE_TYPES.CallExpression:
              return indirectSetStateCallsInHooks.get(node) ?? indirectSetStateCallsAsArgs.get(node) ?? [];
          }
          return [];
        };
        for (const [_, calls] of indirectSetStateCallsAsSetups) {
          for (const call of calls) {
            context.report({
              messageId: "noDirectSetStateInUseEffect",
              node: call,
              data: { name: call.name }
            });
          }
        }
        for (const { callee } of indirectFunctionCalls) {
          if (!("name" in callee)) continue;
          const { name: name2 } = callee;
          const setStateCalls = getSetStateCalls(name2, context.sourceCode.getScope(callee));
          for (const setStateCall of setStateCalls) {
            context.report({
              messageId: "noDirectSetStateInUseEffect",
              node: setStateCall,
              data: {
                name: AST2__namespace.toReadableNodeName(setStateCall, (n) => context.sourceCode.getText(n))
              }
            });
          }
        }
        for (const id of setupFunctionIdentifiers) {
          const setStateCalls = getSetStateCalls(id.name, context.sourceCode.getScope(id));
          for (const setStateCall of setStateCalls) {
            context.report({
              messageId: "noDirectSetStateInUseEffect",
              node: setStateCall,
              data: {
                name: AST2__namespace.toReadableNodeName(setStateCall, (n) => context.sourceCode.getText(n))
              }
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME2 = "no-direct-set-state-in-use-layout-effect";
var RULE_FEATURES2 = [
  "CHK"
];
var no_direct_set_state_in_use_layout_effect_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow direct calls to the 'set' function of 'useState' in 'useLayoutEffect'",
      [Symbol.for("rule_features")]: RULE_FEATURES2
    },
    messages: {
      noDirectSetStateInUseLayoutEffect: "Do not call the 'set' function '{{name}}' of 'useState' directly in 'useLayoutEffect'."
    },
    schema: []
  },
  name: RULE_NAME2,
  create(context) {
    if (!/use\w*Effect/u.test(context.sourceCode.text)) return {};
    const settings = shared.decodeSettings(context.settings);
    const additionalHooks = settings.additionalHooks ?? {};
    const isUseEffectLikeCall = core.isReactHookCallWithNameAlias(
      "useLayoutEffect",
      context,
      additionalHooks.useLayoutEffect ?? []
    );
    const isUseStateCall2 = core.isReactHookCallWithNameAlias("useState", context, additionalHooks.useState ?? []);
    const isUseMemoCall2 = core.isReactHookCallWithNameAlias("useMemo", context, additionalHooks.useMemo ?? []);
    const isUseCallbackCall2 = core.isReactHookCallWithNameAlias("useCallback", context, additionalHooks.useCallback ?? []);
    const isSetStateCall = isSetFunctionCall(context, settings);
    const isIdFromUseStateCall = isFromUseStateCall(context, settings);
    const functionStack = [];
    const setupFunctionRef = eff.MutRef.make(null);
    const setupFunctionIdentifiers = [];
    const indirectFunctionCalls = [];
    const indirectSetStateCalls = /* @__PURE__ */ new WeakMap();
    const indirectSetStateCallsAsArgs = /* @__PURE__ */ new WeakMap();
    const indirectSetStateCallsAsSetups = /* @__PURE__ */ new Map();
    const indirectSetStateCallsInHooks = /* @__PURE__ */ new WeakMap();
    const onSetupFunctionEnter = (node) => {
      eff.MutRef.set(setupFunctionRef, node);
    };
    const onSetupFunctionExit = (node) => {
      eff.MutRef.update(setupFunctionRef, (current) => current === node ? null : current);
    };
    function isSetupFunction(node) {
      return node.parent?.type === types.AST_NODE_TYPES.CallExpression && node.parent.callee !== node && isUseEffectLikeCall(node.parent);
    }
    function getCallKind(node) {
      return tsPattern.match(node).when(isUseStateCall2, () => "useState").when(isUseEffectLikeCall, () => "useLayoutEffect").when(isSetStateCall, () => "setState").when(isThenCall, () => "then").otherwise(() => "other");
    }
    function getFunctionKind(node) {
      return tsPattern.match(node).when(isSetupFunction, () => "setup").when(AST2__namespace.isFunctionOfImmediatelyInvoked, () => "immediate").otherwise(() => "other");
    }
    return {
      ":function"(node) {
        const functionKind = getFunctionKind(node);
        functionStack.push([node, functionKind]);
        if (functionKind === "setup") onSetupFunctionEnter(node);
      },
      ":function:exit"(node) {
        const [_, functionKind] = functionStack.at(-1) ?? [];
        functionStack.pop();
        if (functionKind === "setup") onSetupFunctionExit(node);
      },
      CallExpression(node) {
        const effectFn = eff.MutRef.get(setupFunctionRef);
        const [parentFn, parentFnKind] = functionStack.at(-1) ?? [];
        if (parentFn?.async) return;
        tsPattern.match(getCallKind(node)).with("setState", () => {
          if (!parentFn) return;
          if (parentFn !== effectFn && parentFnKind !== "immediate") {
            const maybeVd = AST2__namespace.traverseUpGuard(node, isVariableDeclaratorFromHookCall);
            if (eff.O.isSome(maybeVd)) {
              const vd = maybeVd.value;
              const calls2 = indirectSetStateCallsInHooks.get(vd.init) ?? [];
              indirectSetStateCallsInHooks.set(vd.init, [...calls2, node]);
              return;
            }
            const calls = indirectSetStateCalls.get(parentFn) ?? [];
            indirectSetStateCalls.set(parentFn, [...calls, node]);
            return;
          }
          context.report({
            messageId: "noDirectSetStateInUseLayoutEffect",
            node,
            data: { name: context.sourceCode.getText(node.callee) }
          });
        }).with("useLayoutEffect", () => {
          const [firstArg] = node.arguments;
          if (AST2__namespace.isFunction(firstArg)) return;
          const identifiers = AST2__namespace.getNestedIdentifiers(node);
          setupFunctionIdentifiers.push(...identifiers);
        }).with("other", () => {
          const isInSetupFunction = effectFn === parentFn;
          if (!isInSetupFunction) return;
          indirectFunctionCalls.push(node);
        }).otherwise(eff.F.constVoid);
      },
      Identifier(node) {
        if (node.parent.type === types.AST_NODE_TYPES.CallExpression && node.parent.callee === node) return;
        if (!isIdFromUseStateCall(node)) return;
        switch (node.parent.type) {
          case types.AST_NODE_TYPES.ArrowFunctionExpression: {
            const parent = node.parent.parent;
            if (parent.type !== types.AST_NODE_TYPES.CallExpression) break;
            if (!isUseMemoCall2(parent)) break;
            const maybeVd = AST2__namespace.traverseUpGuard(parent, isVariableDeclaratorFromHookCall);
            if (eff.O.isNone(maybeVd)) break;
            const vd = maybeVd.value;
            const calls = indirectSetStateCallsAsArgs.get(vd.init) ?? [];
            indirectSetStateCallsAsArgs.set(vd.init, [...calls, node]);
            break;
          }
          case types.AST_NODE_TYPES.CallExpression: {
            const [firstArg] = node.parent.arguments;
            if (node !== firstArg) break;
            if (isUseCallbackCall2(node.parent)) {
              const maybeVd = AST2__namespace.traverseUpGuard(node.parent, isVariableDeclaratorFromHookCall);
              if (eff.O.isNone(maybeVd)) break;
              const vd = maybeVd.value;
              const calls = indirectSetStateCallsAsArgs.get(vd.init) ?? [];
              indirectSetStateCallsAsArgs.set(vd.init, [...calls, node]);
            }
            if (isUseEffectLikeCall(node.parent)) {
              const calls = indirectSetStateCallsAsArgs.get(node.parent) ?? [];
              indirectSetStateCallsAsSetups.set(node.parent, [...calls, node]);
            }
            break;
          }
        }
      },
      "Program:exit"() {
        const getSetStateCalls = (id, initialScope) => {
          const node = eff.O.flatMap(VAR5__namespace.findVariable(id, initialScope), VAR5__namespace.getVariableNode(0)).pipe(eff.O.getOrNull);
          switch (node?.type) {
            case types.AST_NODE_TYPES.ArrowFunctionExpression:
            case types.AST_NODE_TYPES.FunctionDeclaration:
            case types.AST_NODE_TYPES.FunctionExpression:
              return indirectSetStateCalls.get(node) ?? [];
            case types.AST_NODE_TYPES.CallExpression:
              return indirectSetStateCallsInHooks.get(node) ?? indirectSetStateCallsAsArgs.get(node) ?? [];
          }
          return [];
        };
        for (const [_, calls] of indirectSetStateCallsAsSetups) {
          for (const call of calls) {
            context.report({
              messageId: "noDirectSetStateInUseLayoutEffect",
              node: call,
              data: { name: call.name }
            });
          }
        }
        for (const { callee } of indirectFunctionCalls) {
          if (!("name" in callee)) continue;
          const { name: name2 } = callee;
          const setStateCalls = getSetStateCalls(name2, context.sourceCode.getScope(callee));
          for (const setStateCall of setStateCalls) {
            context.report({
              messageId: "noDirectSetStateInUseLayoutEffect",
              node: setStateCall,
              data: {
                name: AST2__namespace.toReadableNodeName(setStateCall, (n) => context.sourceCode.getText(n))
              }
            });
          }
        }
        for (const id of setupFunctionIdentifiers) {
          const setStateCalls = getSetStateCalls(id.name, context.sourceCode.getScope(id));
          for (const setStateCall of setStateCalls) {
            context.report({
              messageId: "noDirectSetStateInUseLayoutEffect",
              node: setStateCall,
              data: {
                name: AST2__namespace.toReadableNodeName(setStateCall, (n) => context.sourceCode.getText(n))
              }
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME3 = "no-unnecessary-use-callback";
var RULE_FEATURES3 = [
  "CHK"
];
var no_unnecessary_use_callback_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow unnecessary usage of 'useCallback'",
      [Symbol.for("rule_features")]: RULE_FEATURES3
    },
    messages: {
      noUnnecessaryUseCallback: "An 'useCallback' with empty deps and no references to the component scope may be unnecessary."
    },
    schema: []
  },
  name: RULE_NAME3,
  create(context) {
    if (!context.sourceCode.text.includes("use")) return {};
    const alias = shared.decodeSettings(context.settings).additionalHooks?.useCallback ?? [];
    return {
      CallExpression(node) {
        if (!core.isReactHookCall(node)) return;
        const initialScope = context.sourceCode.getScope(node);
        if (!core.isUseCallbackCall(node, context) && !alias.some(core.isReactHookCallWithNameLoose(node))) {
          return;
        }
        const scope = context.sourceCode.getScope(node);
        const component = scope.block;
        if (!AST2__namespace.isFunction(component)) return;
        const [cb, deps] = node.arguments;
        if (!deps) {
          context.report({
            messageId: "noUnnecessaryUseCallback",
            node
          });
          return;
        }
        const hasEmptyDeps = eff.F.pipe(
          tsPattern.match(deps).with({ type: types.AST_NODE_TYPES.ArrayExpression }, eff.O.some).with({ type: types.AST_NODE_TYPES.Identifier }, (n) => {
            return eff.F.pipe(
              VAR5__namespace.findVariable(n.name, initialScope),
              eff.O.flatMap(VAR5__namespace.getVariableNode(0)),
              eff.O.filter(AST2__namespace.is(types.AST_NODE_TYPES.ArrayExpression))
            );
          }).otherwise(eff.O.none),
          eff.O.exists((x) => x.elements.length === 0)
        );
        if (!hasEmptyDeps) return;
        if (!cb) {
          context.report({
            messageId: "noUnnecessaryUseCallback",
            node
          });
          return;
        }
        const isReferencedToComponentScope = eff.F.pipe(
          tsPattern.match(cb).with({ type: types.AST_NODE_TYPES.ArrowFunctionExpression }, (n) => {
            if (n.body.type === types.AST_NODE_TYPES.ArrowFunctionExpression) {
              return eff.O.some(n.body);
            }
            return eff.O.some(n);
          }).with({ type: types.AST_NODE_TYPES.FunctionExpression }, eff.O.some).with({ type: types.AST_NODE_TYPES.Identifier }, (n) => {
            return eff.F.pipe(
              VAR5__namespace.findVariable(n.name, initialScope),
              eff.O.flatMap(VAR5__namespace.getVariableNode(0)),
              eff.O.filter(AST2__namespace.isFunction)
            );
          }).otherwise(eff.O.none),
          eff.O.map((n) => context.sourceCode.getScope(n)),
          eff.O.map((s) => VAR5__namespace.getChidScopes(s).flatMap((x) => x.references)),
          eff.O.exists((refs) => refs.some((x) => x.resolved?.scope.block === component))
        );
        if (isReferencedToComponentScope) return;
        context.report({
          messageId: "noUnnecessaryUseCallback",
          node
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME4 = "no-unnecessary-use-memo";
var RULE_FEATURES4 = [
  "CHK"
];
var no_unnecessary_use_memo_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow unnecessary usage of 'useMemo'",
      [Symbol.for("rule_features")]: RULE_FEATURES4
    },
    messages: {
      noUnnecessaryUseMemo: "An 'useMemo' with empty deps and no references to the component scope may be unnecessary."
    },
    schema: []
  },
  name: RULE_NAME4,
  create(context) {
    if (!context.sourceCode.text.includes("use")) return {};
    const alias = shared.decodeSettings(context.settings).additionalHooks?.useMemo ?? [];
    return {
      CallExpression(node) {
        if (!core.isReactHookCall(node)) return;
        const initialScope = context.sourceCode.getScope(node);
        if (!core.isUseMemoCall(node, context) && !alias.some(core.isReactHookCallWithNameLoose(node))) {
          return;
        }
        const scope = context.sourceCode.getScope(node);
        const component = scope.block;
        if (!AST2__namespace.isFunction(component)) return;
        const [cb, deps] = node.arguments;
        if (!deps) {
          context.report({
            messageId: "noUnnecessaryUseMemo",
            node
          });
          return;
        }
        const hasEmptyDeps = eff.F.pipe(
          tsPattern.match(deps).with({ type: types.AST_NODE_TYPES.ArrayExpression }, eff.O.some).with({ type: types.AST_NODE_TYPES.Identifier }, (n) => {
            return eff.F.pipe(
              VAR5__namespace.findVariable(n.name, initialScope),
              eff.O.flatMap(VAR5__namespace.getVariableNode(0)),
              eff.O.filter(AST2__namespace.is(types.AST_NODE_TYPES.ArrayExpression))
            );
          }).otherwise(eff.O.none),
          eff.O.exists((x) => x.elements.length === 0)
        );
        if (!hasEmptyDeps) return;
        if (!cb) {
          context.report({
            messageId: "noUnnecessaryUseMemo",
            node
          });
          return;
        }
        const isReferencedToComponentScope = eff.F.pipe(
          tsPattern.match(cb).with({ type: types.AST_NODE_TYPES.ArrowFunctionExpression }, (n) => {
            if (n.body.type === types.AST_NODE_TYPES.ArrowFunctionExpression) {
              return eff.O.some(n.body);
            }
            return eff.O.some(n);
          }).with({ type: types.AST_NODE_TYPES.FunctionExpression }, eff.O.some).with({ type: types.AST_NODE_TYPES.Identifier }, (n) => {
            return eff.F.pipe(
              VAR5__namespace.findVariable(n.name, initialScope),
              eff.O.flatMap(VAR5__namespace.getVariableNode(0)),
              eff.O.filter(AST2__namespace.isFunction)
            );
          }).otherwise(eff.O.none),
          eff.O.map((n) => context.sourceCode.getScope(n)),
          eff.O.map((s) => VAR5__namespace.getChidScopes(s).flatMap((x) => x.references)),
          eff.O.exists((refs) => refs.some((x) => x.resolved?.scope.block === component))
        );
        if (isReferencedToComponentScope) return;
        context.report({
          messageId: "noUnnecessaryUseMemo",
          node
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME5 = "no-useless-custom-hooks";
var RULE_FEATURES5 = [
  "CHK"
];
function isNodeContainsUseCallComments(node, context) {
  return context.sourceCode.getCommentsInside(node).some((comment) => /use\w+\(/u.test(comment.value));
}
var no_useless_custom_hooks_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce custom Hooks to use at least one other hook inside",
      [Symbol.for("rule_features")]: RULE_FEATURES5
    },
    messages: {
      noUselessCustomHooks: "A custom Hook '{{name}}' should use at least one other hook."
    },
    schema: []
  },
  name: RULE_NAME5,
  create(context) {
    const { ctx, listeners } = core.useHookCollector();
    return {
      ...listeners,
      "Program:exit"(node) {
        const allHooks = ctx.getAllHooks(node);
        for (const { name: name2, node: node2, hookCalls } of allHooks.values()) {
          if (AST2__namespace.isEmptyFunction(node2)) continue;
          if (hookCalls.length > 0) continue;
          if (isNodeContainsUseCallComments(node2, context)) continue;
          context.report({
            messageId: "noUselessCustomHooks",
            node: node2,
            data: {
              name: name2.value
            }
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME6 = "prefer-use-state-lazy-initialization";
var RULE_FEATURES6 = [
  "CHK"
];
var ALLOW_LIST = ["Boolean", "String", "Number"];
var prefer_use_state_lazy_initialization_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow function calls in 'useState' that aren't wrapped in an initializer function",
      [Symbol.for("rule_features")]: RULE_FEATURES6
    },
    messages: {
      preferUseStateLazyInitialization: "To prevent re-computation, consider using lazy initial state for useState calls that involve function calls. Ex: 'useState(() => getValue())'."
    },
    schema: []
  },
  name: RULE_NAME6,
  create(context) {
    if (!context.sourceCode.text.includes("use")) return {};
    const alias = shared.decodeSettings(context.settings).additionalHooks?.useState ?? [];
    return {
      CallExpression(node) {
        if (!core.isReactHookCall(node)) return;
        if (!core.isUseStateCall(node, context) && !alias.some(core.isReactHookCallWithNameLoose(node))) return;
        const [useStateInput] = node.arguments;
        if (!useStateInput) return;
        const nestedCallExpressions = AST2__namespace.getNestedCallExpressions(useStateInput);
        const hasFunctionCall = nestedCallExpressions.some((n) => {
          return "name" in n.callee && !ALLOW_LIST.includes(n.callee.name);
        });
        const hasNewCall = AST2__namespace.getNestedNewExpressions(useStateInput).some((n) => {
          return "name" in n.callee && !ALLOW_LIST.includes(n.callee.name);
        });
        if (!hasFunctionCall && !hasNewCall) return;
        context.report({
          messageId: "preferUseStateLazyInitialization",
          node: useStateInput
        });
      }
    };
  },
  defaultOptions: []
});

// src/index.ts
var index_default = {
  meta: {
    name,
    version
  },
  rules: {
    "no-direct-set-state-in-use-effect": no_direct_set_state_in_use_effect_default,
    "no-direct-set-state-in-use-layout-effect": no_direct_set_state_in_use_layout_effect_default,
    "no-unnecessary-use-callback": no_unnecessary_use_callback_default,
    "no-unnecessary-use-memo": no_unnecessary_use_memo_default,
    "no-useless-custom-hooks": no_useless_custom_hooks_default,
    "prefer-use-state-lazy-initialization": prefer_use_state_lazy_initialization_default,
    // Part: deprecated rules
    /** @deprecated Use `no-useless-custom-hooks` instead */
    "ensure-custom-hooks-using-other-hooks": no_useless_custom_hooks_default,
    /** @deprecated Use `no-unnecessary-use-callback` instead */
    "ensure-use-callback-has-non-empty-deps": no_unnecessary_use_callback_default,
    /** @deprecated Use `no-unnecessary-use-memo` instead */
    "ensure-use-memo-has-non-empty-deps": no_unnecessary_use_memo_default,
    /** @deprecated Use `no-useless-custom-hooks` instead */
    "no-redundant-custom-hook": no_useless_custom_hooks_default
  }
};

module.exports = index_default;
