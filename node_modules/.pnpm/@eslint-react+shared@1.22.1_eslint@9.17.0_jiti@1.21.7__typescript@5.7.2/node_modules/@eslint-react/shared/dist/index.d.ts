import { ESLintUtils } from '@typescript-eslint/utils';
import { E } from '@eslint-react/eff';
import * as valibot from 'valibot';
import { InferOutput } from 'valibot';
import * as micro_memoize from 'micro-memoize';

/**
 * The NPM scope for this project.
 */
declare const NPM_SCOPE = "@eslint-react";
/**
 * The GitHub repository for this project.
 */
declare const GITHUB_URL = "https://github.com/rel1cx/eslint-react";
/**
 * The URL to the project's website.
 */
declare const WEBSITE_URL = "https://eslint-react.xyz";
/**
 * Regular expression for matching a PascalCase string.
 */
declare const RE_PASCAL_CASE: RegExp;
/**
 * Regular expression for matching a camelCase string.
 */
declare const RE_CAMEL_CASE: RegExp;
/**
 * Regular expression for matching a kebab-case string.
 */
declare const RE_KEBAB_CASE: RegExp;
/**
 * Regular expression for matching a snake_case string.
 */
declare const RE_SNAKE_CASE: RegExp;
/**
 * Regular expression for matching a CONSTANT_CASE string.
 */
declare const RE_CONSTANT_CASE: RegExp;
declare const RE_JAVASCRIPT_PROTOCOL: RegExp;
/**
 * @internal
 */
declare const HOST_HTML_COMPONENT_TYPES: readonly ["aside", "audio", "b", "base", "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "link", "main", "map", "mark", "menu", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr"];
/**
 * @internal
 */
declare const HOST_SVG_COMPONENT_TYPES: readonly ["a", "animate", "animateMotion", "animateTransform", "circle", "clipPath", "defs", "desc", "discard", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "foreignObject", "g", "hatch", "hatchpath", "image", "line", "linearGradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "script", "set", "stop", "style", "svg", "switch", "symbol", "text", "textPath", "title", "tspan", "use", "view"];
declare const REACT_BUILD_IN_HOOKS: readonly ["use", "useActionState", "useCallback", "useContext", "useDebugValue", "useDeferredValue", "useEffect", "useFormStatus", "useId", "useImperativeHandle", "useInsertionEffect", "useLayoutEffect", "useMemo", "useOptimistic", "useReducer", "useRef", "useState", "useSyncExternalStore", "useTransition"];

/**
 * Get the ESLint rule creator for a plugin.
 * @internal
 * @param pluginName The name of the plugin.
 * @returns The ESLint rule creator.
 */
declare const createRuleForPlugin: (pluginName: string) => <Options extends readonly unknown[], MessageIds extends string>({ meta, name, ...rule }: Readonly<ESLintUtils.RuleWithMetaAndName<Options, MessageIds, unknown>>) => ESLintUtils.RuleModule<MessageIds, Options, unknown, ESLintUtils.RuleListener>;

declare function getReactVersion(at?: string): E.Either<string, unknown>;

/**
 * @internal
 * @description
 * This allows the rule to know some key information before checking for user-defined hooks.
 * For example, the position of the `deps` argument for the user-defined `useCustomEffect` hook that represents the built-in `useEffect` hook.
 */
declare const CustomHookSchema: valibot.ObjectSchema<{}, undefined>;
/**
 * @internal
 */
declare const CustomAttributeSchema: valibot.ObjectSchema<{
    /**
     * The name of the attribute in the user-defined component.
     * @example
     * "to"
     */
    readonly name: valibot.StringSchema<undefined>;
    /**
     * The name of the attribute in the built-in component.
     * @example
     * "href"
     */
    readonly as: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
    /**
     * Whether the attribute is controlled or not in the user-defined component.
     * @example
     * `true`
     */
    readonly controlled: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, undefined>;
    /**
     * The default value of the attribute in the user-defined component.
     * @example
     * `"/"`
     */
    readonly defaultValue: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
}, undefined>;
/**
 * @internal
 * @description
 * This will provide some key information to the rule before checking for user-defined components.
 * For example:
 * Which attribute is used as the `href` prop for the user-defined `Link` component that represents the built-in `a` element.
 * Which attributes are used as `children` props for a user-defined `Button` component to receive children of that component.
 */
declare const CustomComponentSchema: valibot.ObjectSchema<{
    /**
     * The name of the user-defined component.
     * @example
     * "Link"
     */
    readonly name: valibot.StringSchema<undefined>;
    /**
     * The ESQuery selector to select the component precisely.
     * @example
     * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
     */
    readonly selector: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
    /**
     * The name of the built-in component that the user-defined component represents.
     * @example
     * "a"
     */
    readonly as: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
    /**
     * Pre-defined attributes that are used in the user-defined component.
     * @example
     * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
     */
    readonly attributes: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
        /**
         * The name of the attribute in the user-defined component.
         * @example
         * "to"
         */
        readonly name: valibot.StringSchema<undefined>;
        /**
         * The name of the attribute in the built-in component.
         * @example
         * "href"
         */
        readonly as: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * Whether the attribute is controlled or not in the user-defined component.
         * @example
         * `true`
         */
        readonly controlled: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, undefined>;
        /**
         * The default value of the attribute in the user-defined component.
         * @example
         * `"/"`
         */
        readonly defaultValue: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
    }, undefined>, undefined>, undefined>;
}, undefined>;
declare const CustomComponentNormalizedSchema: valibot.ObjectSchema<{
    readonly name: valibot.StringSchema<undefined>;
    readonly as: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
    readonly attributes: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
        /**
         * The name of the attribute in the user-defined component.
         * @example
         * "to"
         */
        readonly name: valibot.StringSchema<undefined>;
        /**
         * The name of the attribute in the built-in component.
         * @example
         * "href"
         */
        readonly as: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * Whether the attribute is controlled or not in the user-defined component.
         * @example
         * `true`
         */
        readonly controlled: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, undefined>;
        /**
         * The default value of the attribute in the user-defined component.
         * @example
         * `"/"`
         */
        readonly defaultValue: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
    }, undefined>, undefined>, readonly []>;
    readonly re: valibot.InstanceSchema<RegExpConstructor, undefined>;
    readonly selector: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
}, undefined>;
/**
 * @internal
 */
declare const ESLintReactSettingsSchema: valibot.ObjectSchema<{
    /**
     * The source where React is imported from.
     * @description This allows to specify a custom import location for React when not using the official distribution.
     * @default `"react"`
     * @example `"@pika/react"`
     */
    readonly importSource: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
    /**
     * The identifier that’s used for JSX Element creation.
     * @default `"createElement"`
     */
    readonly jsxPragma: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
    /**
     * The identifier that’s used for JSX fragment elements.
     * @description This should not be a member expression (i.e. use "Fragment" instead of "React.Fragment").
     * @default `"Fragment"`
     */
    readonly jsxPragmaFrag: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
    /**
     * The name of the prop that is used for polymorphic components.
     * @description This is used to determine the type of the component.
     * @example `"as"`
     */
    readonly polymorphicPropName: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
    /**
     * @internal
     */
    readonly strict: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, undefined>;
    /**
     * @internal
     */
    readonly strictImportCheck: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, undefined>;
    /**
     * React version to use, "detect" means auto detect React version from the project’s dependencies.
     * If `importSource` is specified, an equivalent version of React should be provided here.
     * @example `"18.3.1"`
     * @default `"detect"`
     */
    readonly version: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
    /**
     * An array of user-defined components
     * @description This is used to inform the ESLint React plugins how to treat these components during checks.
     * @example `[{ name: "Link", as: "a", attributes: [{ name: "to", as: "href" }, { name: "rel", defaultValue: "noopener noreferrer" }] }]`
     */
    readonly additionalComponents: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
        /**
         * The name of the user-defined component.
         * @example
         * "Link"
         */
        readonly name: valibot.StringSchema<undefined>;
        /**
         * The ESQuery selector to select the component precisely.
         * @example
         * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
         */
        readonly selector: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * The name of the built-in component that the user-defined component represents.
         * @example
         * "a"
         */
        readonly as: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * Pre-defined attributes that are used in the user-defined component.
         * @example
         * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
         */
        readonly attributes: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            /**
             * The name of the attribute in the user-defined component.
             * @example
             * "to"
             */
            readonly name: valibot.StringSchema<undefined>;
            /**
             * The name of the attribute in the built-in component.
             * @example
             * "href"
             */
            readonly as: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
            /**
             * Whether the attribute is controlled or not in the user-defined component.
             * @example
             * `true`
             */
            readonly controlled: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, undefined>;
            /**
             * The default value of the attribute in the user-defined component.
             * @example
             * `"/"`
             */
            readonly defaultValue: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        }, undefined>, undefined>, undefined>;
    }, undefined>, undefined>, undefined>;
    /**
     * A object of aliases for React built-in hooks.
     * @description ESLint React will recognize these aliases as equivalent to the built-in hooks in all its rules.
     * @example `{ useLayoutEffect: ["useIsomorphicLayoutEffect"] }`
     */
    readonly additionalHooks: valibot.OptionalSchema<valibot.ObjectSchema<{
        readonly use: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useActionState: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useCallback: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useContext: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useDebugValue: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useDeferredValue: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useEffect: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useFormStatus: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useId: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useImperativeHandle: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useInsertionEffect: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useLayoutEffect: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useMemo: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useOptimistic: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useReducer: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useRef: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useState: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useSyncExternalStore: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        readonly useTransition: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
    }, undefined>, undefined>;
}, undefined>;
/**
 * @internal
 */
declare const ESLintSettingsSchema: valibot.OptionalSchema<valibot.ObjectSchema<{
    readonly "react-x": valibot.OptionalSchema<valibot.ObjectSchema<{
        /**
         * The source where React is imported from.
         * @description This allows to specify a custom import location for React when not using the official distribution.
         * @default `"react"`
         * @example `"@pika/react"`
         */
        readonly importSource: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * The identifier that’s used for JSX Element creation.
         * @default `"createElement"`
         */
        readonly jsxPragma: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * The identifier that’s used for JSX fragment elements.
         * @description This should not be a member expression (i.e. use "Fragment" instead of "React.Fragment").
         * @default `"Fragment"`
         */
        readonly jsxPragmaFrag: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * The name of the prop that is used for polymorphic components.
         * @description This is used to determine the type of the component.
         * @example `"as"`
         */
        readonly polymorphicPropName: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * @internal
         */
        readonly strict: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, undefined>;
        /**
         * @internal
         */
        readonly strictImportCheck: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, undefined>;
        /**
         * React version to use, "detect" means auto detect React version from the project’s dependencies.
         * If `importSource` is specified, an equivalent version of React should be provided here.
         * @example `"18.3.1"`
         * @default `"detect"`
         */
        readonly version: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * An array of user-defined components
         * @description This is used to inform the ESLint React plugins how to treat these components during checks.
         * @example `[{ name: "Link", as: "a", attributes: [{ name: "to", as: "href" }, { name: "rel", defaultValue: "noopener noreferrer" }] }]`
         */
        readonly additionalComponents: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            /**
             * The name of the user-defined component.
             * @example
             * "Link"
             */
            readonly name: valibot.StringSchema<undefined>;
            /**
             * The ESQuery selector to select the component precisely.
             * @example
             * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
             */
            readonly selector: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
            /**
             * The name of the built-in component that the user-defined component represents.
             * @example
             * "a"
             */
            readonly as: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
            /**
             * Pre-defined attributes that are used in the user-defined component.
             * @example
             * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
             */
            readonly attributes: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                /**
                 * The name of the attribute in the user-defined component.
                 * @example
                 * "to"
                 */
                readonly name: valibot.StringSchema<undefined>;
                /**
                 * The name of the attribute in the built-in component.
                 * @example
                 * "href"
                 */
                readonly as: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
                /**
                 * Whether the attribute is controlled or not in the user-defined component.
                 * @example
                 * `true`
                 */
                readonly controlled: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, undefined>;
                /**
                 * The default value of the attribute in the user-defined component.
                 * @example
                 * `"/"`
                 */
                readonly defaultValue: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
            }, undefined>, undefined>, undefined>;
        }, undefined>, undefined>, undefined>;
        /**
         * A object of aliases for React built-in hooks.
         * @description ESLint React will recognize these aliases as equivalent to the built-in hooks in all its rules.
         * @example `{ useLayoutEffect: ["useIsomorphicLayoutEffect"] }`
         */
        readonly additionalHooks: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly use: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useActionState: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useCallback: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useContext: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useDebugValue: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useDeferredValue: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useEffect: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useFormStatus: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useId: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useImperativeHandle: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useInsertionEffect: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useLayoutEffect: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useMemo: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useOptimistic: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useReducer: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useRef: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useState: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useSyncExternalStore: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useTransition: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        }, undefined>, undefined>;
    }, undefined>, undefined>;
    /** @deprecated Use `react-x` instead */
    readonly reactOptions: valibot.OptionalSchema<valibot.ObjectSchema<{
        /**
         * The source where React is imported from.
         * @description This allows to specify a custom import location for React when not using the official distribution.
         * @default `"react"`
         * @example `"@pika/react"`
         */
        readonly importSource: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * The identifier that’s used for JSX Element creation.
         * @default `"createElement"`
         */
        readonly jsxPragma: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * The identifier that’s used for JSX fragment elements.
         * @description This should not be a member expression (i.e. use "Fragment" instead of "React.Fragment").
         * @default `"Fragment"`
         */
        readonly jsxPragmaFrag: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * The name of the prop that is used for polymorphic components.
         * @description This is used to determine the type of the component.
         * @example `"as"`
         */
        readonly polymorphicPropName: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * @internal
         */
        readonly strict: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, undefined>;
        /**
         * @internal
         */
        readonly strictImportCheck: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, undefined>;
        /**
         * React version to use, "detect" means auto detect React version from the project’s dependencies.
         * If `importSource` is specified, an equivalent version of React should be provided here.
         * @example `"18.3.1"`
         * @default `"detect"`
         */
        readonly version: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
        /**
         * An array of user-defined components
         * @description This is used to inform the ESLint React plugins how to treat these components during checks.
         * @example `[{ name: "Link", as: "a", attributes: [{ name: "to", as: "href" }, { name: "rel", defaultValue: "noopener noreferrer" }] }]`
         */
        readonly additionalComponents: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            /**
             * The name of the user-defined component.
             * @example
             * "Link"
             */
            readonly name: valibot.StringSchema<undefined>;
            /**
             * The ESQuery selector to select the component precisely.
             * @example
             * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
             */
            readonly selector: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
            /**
             * The name of the built-in component that the user-defined component represents.
             * @example
             * "a"
             */
            readonly as: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
            /**
             * Pre-defined attributes that are used in the user-defined component.
             * @example
             * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
             */
            readonly attributes: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                /**
                 * The name of the attribute in the user-defined component.
                 * @example
                 * "to"
                 */
                readonly name: valibot.StringSchema<undefined>;
                /**
                 * The name of the attribute in the built-in component.
                 * @example
                 * "href"
                 */
                readonly as: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
                /**
                 * Whether the attribute is controlled or not in the user-defined component.
                 * @example
                 * `true`
                 */
                readonly controlled: valibot.OptionalSchema<valibot.BooleanSchema<undefined>, undefined>;
                /**
                 * The default value of the attribute in the user-defined component.
                 * @example
                 * `"/"`
                 */
                readonly defaultValue: valibot.OptionalSchema<valibot.StringSchema<undefined>, undefined>;
            }, undefined>, undefined>, undefined>;
        }, undefined>, undefined>, undefined>;
        /**
         * A object of aliases for React built-in hooks.
         * @description ESLint React will recognize these aliases as equivalent to the built-in hooks in all its rules.
         * @example `{ useLayoutEffect: ["useIsomorphicLayoutEffect"] }`
         */
        readonly additionalHooks: valibot.OptionalSchema<valibot.ObjectSchema<{
            readonly use: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useActionState: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useCallback: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useContext: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useDebugValue: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useDeferredValue: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useEffect: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useFormStatus: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useId: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useImperativeHandle: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useInsertionEffect: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useLayoutEffect: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useMemo: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useOptimistic: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useReducer: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useRef: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useState: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useSyncExternalStore: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
            readonly useTransition: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<undefined>, undefined>, undefined>;
        }, undefined>, undefined>;
    }, undefined>, undefined>;
}, undefined>, {}>;
type CustomHook = InferOutput<typeof CustomHookSchema>;
type CustomAttribute = InferOutput<typeof CustomAttributeSchema>;
type CustomComponent = InferOutput<typeof CustomComponentSchema>;
type CustomComponentNormalized = InferOutput<typeof CustomComponentNormalizedSchema>;
type ESLintReactSettings = InferOutput<typeof ESLintReactSettingsSchema>;
type ESLintSettings = InferOutput<typeof ESLintSettingsSchema>;
/**
 * This is an expanded version of `ESLintReactSettings` with all shorthand properties expanded.
 * @internal
 */
interface ESLintReactSettingsNormalized extends ESLintReactSettings {
    additionalComponents: CustomComponentNormalized[];
    components: Map<string, string>;
    version: string;
}

/**
Matches any [primitive value](https://developer.mozilla.org/en-US/docs/Glossary/Primitive).

@category Type
*/
type Primitive =
	| null
	| undefined
	| string
	| number
	| boolean
	| symbol
	| bigint;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

/**
Matches any primitive, `void`, `Date`, or `RegExp` value.
*/
type BuiltIns = Primitive | void | Date | RegExp;

/**
@see PartialDeep
*/
type PartialDeepOptions = {
	/**
	Whether to affect the individual elements of arrays and tuples.

	@default false
	*/
	readonly recurseIntoArrays?: boolean;
};

/**
Create a type from another type with all keys and nested keys set to optional.

Use-cases:
- Merging a default settings/config object with another object, the second object would be a deep partial of the default object.
- Mocking and testing complex entities, where populating an entire object with its keys would be redundant in terms of the mock or test.

@example
```
import type {PartialDeep} from 'type-fest';

const settings: Settings = {
	textEditor: {
		fontSize: 14;
		fontColor: '#000000';
		fontWeight: 400;
	}
	autocomplete: false;
	autosave: true;
};

const applySavedSettings = (savedSettings: PartialDeep<Settings>) => {
	return {...settings, ...savedSettings};
}

settings = applySavedSettings({textEditor: {fontWeight: 500}});
```

By default, this does not affect elements in array and tuple types. You can change this by passing `{recurseIntoArrays: true}` as the second type argument:

```
import type {PartialDeep} from 'type-fest';

interface Settings {
	languages: string[];
}

const partialSettings: PartialDeep<Settings, {recurseIntoArrays: true}> = {
	languages: [undefined]
};
```

@category Object
@category Array
@category Set
@category Map
*/
type PartialDeep<T, Options extends PartialDeepOptions = {}> = T extends BuiltIns | (((...arguments_: any[]) => unknown)) | (new (...arguments_: any[]) => unknown)
	? T
	: T extends Map<infer KeyType, infer ValueType>
		? PartialMapDeep<KeyType, ValueType, Options>
		: T extends Set<infer ItemType>
			? PartialSetDeep<ItemType, Options>
			: T extends ReadonlyMap<infer KeyType, infer ValueType>
				? PartialReadonlyMapDeep<KeyType, ValueType, Options>
				: T extends ReadonlySet<infer ItemType>
					? PartialReadonlySetDeep<ItemType, Options>
					: T extends object
						? T extends ReadonlyArray<infer ItemType> // Test for arrays/tuples, per https://github.com/microsoft/TypeScript/issues/35156
							? Options['recurseIntoArrays'] extends true
								? ItemType[] extends T // Test for arrays (non-tuples) specifically
									? readonly ItemType[] extends T // Differentiate readonly and mutable arrays
										? ReadonlyArray<PartialDeep<ItemType | undefined, Options>>
										: Array<PartialDeep<ItemType | undefined, Options>>
									: PartialObjectDeep<T, Options> // Tuples behave properly
								: T // If they don't opt into array testing, just use the original type
							: PartialObjectDeep<T, Options>
						: unknown;

/**
Same as `PartialDeep`, but accepts only `Map`s and as inputs. Internal helper for `PartialDeep`.
*/
type PartialMapDeep<KeyType, ValueType, Options extends PartialDeepOptions> = {} & Map<PartialDeep<KeyType, Options>, PartialDeep<ValueType, Options>>;

/**
Same as `PartialDeep`, but accepts only `Set`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialSetDeep<T, Options extends PartialDeepOptions> = {} & Set<PartialDeep<T, Options>>;

/**
Same as `PartialDeep`, but accepts only `ReadonlyMap`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialReadonlyMapDeep<KeyType, ValueType, Options extends PartialDeepOptions> = {} & ReadonlyMap<PartialDeep<KeyType, Options>, PartialDeep<ValueType, Options>>;

/**
Same as `PartialDeep`, but accepts only `ReadonlySet`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialReadonlySetDeep<T, Options extends PartialDeepOptions> = {} & ReadonlySet<PartialDeep<T, Options>>;

/**
Same as `PartialDeep`, but accepts only `object`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialObjectDeep<ObjectType extends object, Options extends PartialDeepOptions> = {
	[KeyType in keyof ObjectType]?: PartialDeep<ObjectType[KeyType], Options>
};

/**
 * The default ESLint settings for "react-x".
 */
declare const DEFAULT_ESLINT_REACT_SETTINGS: {
    readonly additionalHooks: {
        readonly useLayoutEffect: ["useIsomorphicLayoutEffect"];
    };
    readonly polymorphicPropName: "as";
    readonly strictImportCheck: false;
    readonly version: "detect";
};
/**
 * Unsafely casts settings from a data object from `context.settings`.
 * @internal
 * @param data The data object.
 * @returns settings The settings.
 */
declare function unsafeReadSettings(data: unknown): PartialDeep<ESLintReactSettings>;
/**
 * Decodes settings from a data object from `context.settings`.
 * @internal
 * @param data The data object.
 * @returns settings The settings.
 */
declare const decodeSettings: micro_memoize.Memoized<(data: unknown) => ESLintReactSettings>;
/**
 * Normalizes the settings by converting all shorthand properties to their full form.
 * @param settings The settings.
 * @returns The normalized settings.
 * @internal
 */
declare const normalizeSettings: micro_memoize.Memoized<(settings: ESLintReactSettings) => ESLintReactSettingsNormalized>;
/**
 * A helper function to define settings for "react-x" with type checking in JavaScript files.
 * @param settings The settings.
 * @returns The settings.
 */
declare const defineSettings: (settings: ESLintReactSettings) => ESLintReactSettings;
declare module "@typescript-eslint/utils/ts-eslint" {
    interface SharedConfigurationSettings {
        "react-x"?: Partial<ESLintReactSettings>;
    }
}

export { type CustomAttribute, CustomAttributeSchema, type CustomComponent, type CustomComponentNormalized, CustomComponentNormalizedSchema, CustomComponentSchema, type CustomHook, CustomHookSchema, DEFAULT_ESLINT_REACT_SETTINGS, type ESLintReactSettings, type ESLintReactSettingsNormalized, ESLintReactSettingsSchema, type ESLintSettings, ESLintSettingsSchema, GITHUB_URL, HOST_HTML_COMPONENT_TYPES, HOST_SVG_COMPONENT_TYPES, NPM_SCOPE, REACT_BUILD_IN_HOOKS, RE_CAMEL_CASE, RE_CONSTANT_CASE, RE_JAVASCRIPT_PROTOCOL, RE_KEBAB_CASE, RE_PASCAL_CASE, RE_SNAKE_CASE, WEBSITE_URL, createRuleForPlugin, decodeSettings, defineSettings, getReactVersion, normalizeSettings, unsafeReadSettings };
