import * as effect_Unify from 'effect/Unify';
import { Data, O } from '@eslint-react/eff';
import * as _typescript_eslint_scope_manager from '@typescript-eslint/scope-manager';
import { Scope, Variable, ScopeManager } from '@typescript-eslint/scope-manager';
import { TSESTree } from '@typescript-eslint/types';

type Construction = Data.TaggedEnum<{
    Array: {
        node: TSESTree.ArrayExpression;
        usage: O.Option<TSESTree.Node>;
    };
    AssignmentExpression: {
        node: TSESTree.Node;
        usage: O.Option<TSESTree.Node>;
    };
    AssignmentPattern: {
        node: TSESTree.Node;
        usage: O.Option<TSESTree.Node>;
    };
    CallExpression: {
        node: TSESTree.CallExpression;
        usage: O.Option<TSESTree.Node>;
    };
    ClassExpression: {
        node: TSESTree.ClassExpression;
        usage: O.Option<TSESTree.Node>;
    };
    FunctionDeclaration: {
        node: TSESTree.FunctionDeclaration;
        usage: O.Option<TSESTree.Expression | TSESTree.Identifier>;
    };
    FunctionExpression: {
        node: TSESTree.ArrowFunctionExpression | TSESTree.FunctionExpression;
        usage: O.Option<TSESTree.Node>;
    };
    JSXElement: {
        node: TSESTree.JSXElement;
        usage: O.Option<TSESTree.Node>;
    };
    JSXFragment: {
        node: TSESTree.JSXFragment;
        usage: O.Option<TSESTree.Node>;
    };
    NewExpression: {
        node: TSESTree.NewExpression;
        usage: O.Option<TSESTree.Node>;
    };
    None: {};
    ObjectExpression: {
        node: TSESTree.ObjectExpression;
        usage: O.Option<TSESTree.Node>;
    };
    RegExpLiteral: {
        node: TSESTree.Literal;
        usage: O.Option<TSESTree.Node>;
    };
}>;
declare const Construction: {
    readonly Array: Data.Case.Constructor<{
        readonly _tag: "Array";
        readonly node: TSESTree.ArrayExpression;
        readonly usage: O.Option<TSESTree.Node>;
    }, "_tag">;
    readonly AssignmentExpression: Data.Case.Constructor<{
        readonly _tag: "AssignmentExpression";
        readonly node: TSESTree.Node;
        readonly usage: O.Option<TSESTree.Node>;
    }, "_tag">;
    readonly AssignmentPattern: Data.Case.Constructor<{
        readonly _tag: "AssignmentPattern";
        readonly node: TSESTree.Node;
        readonly usage: O.Option<TSESTree.Node>;
    }, "_tag">;
    readonly CallExpression: Data.Case.Constructor<{
        readonly _tag: "CallExpression";
        readonly node: TSESTree.CallExpression;
        readonly usage: O.Option<TSESTree.Node>;
    }, "_tag">;
    readonly ClassExpression: Data.Case.Constructor<{
        readonly _tag: "ClassExpression";
        readonly node: TSESTree.ClassExpression;
        readonly usage: O.Option<TSESTree.Node>;
    }, "_tag">;
    readonly FunctionDeclaration: Data.Case.Constructor<{
        readonly _tag: "FunctionDeclaration";
        readonly node: TSESTree.FunctionDeclaration;
        readonly usage: O.Option<TSESTree.Expression | TSESTree.Identifier>;
    }, "_tag">;
    readonly FunctionExpression: Data.Case.Constructor<{
        readonly _tag: "FunctionExpression";
        readonly node: TSESTree.ArrowFunctionExpression | TSESTree.FunctionExpression;
        readonly usage: O.Option<TSESTree.Node>;
    }, "_tag">;
    readonly JSXElement: Data.Case.Constructor<{
        readonly _tag: "JSXElement";
        readonly node: TSESTree.JSXElement;
        readonly usage: O.Option<TSESTree.Node>;
    }, "_tag">;
    readonly JSXFragment: Data.Case.Constructor<{
        readonly _tag: "JSXFragment";
        readonly node: TSESTree.JSXFragment;
        readonly usage: O.Option<TSESTree.Node>;
    }, "_tag">;
    readonly NewExpression: Data.Case.Constructor<{
        readonly _tag: "NewExpression";
        readonly node: TSESTree.NewExpression;
        readonly usage: O.Option<TSESTree.Node>;
    }, "_tag">;
    readonly None: Data.Case.Constructor<{
        readonly _tag: "None";
    }, "_tag">;
    readonly ObjectExpression: Data.Case.Constructor<{
        readonly _tag: "ObjectExpression";
        readonly node: TSESTree.ObjectExpression;
        readonly usage: O.Option<TSESTree.Node>;
    }, "_tag">;
    readonly RegExpLiteral: Data.Case.Constructor<{
        readonly _tag: "RegExpLiteral";
        readonly node: TSESTree.Literal;
        readonly usage: O.Option<TSESTree.Node>;
    }, "_tag">;
    readonly $is: <Tag extends "Array" | "AssignmentExpression" | "AssignmentPattern" | "CallExpression" | "ClassExpression" | "FunctionDeclaration" | "FunctionExpression" | "JSXElement" | "JSXFragment" | "NewExpression" | "None" | "ObjectExpression" | "RegExpLiteral">(tag: Tag) => (u: unknown) => u is Extract<{
        readonly _tag: "Array";
        readonly node: TSESTree.ArrayExpression;
        readonly usage: O.Option<TSESTree.Node>;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "AssignmentExpression";
        readonly node: TSESTree.Node;
        readonly usage: O.Option<TSESTree.Node>;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "AssignmentPattern";
        readonly node: TSESTree.Node;
        readonly usage: O.Option<TSESTree.Node>;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "CallExpression";
        readonly node: TSESTree.CallExpression;
        readonly usage: O.Option<TSESTree.Node>;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "ClassExpression";
        readonly node: TSESTree.ClassExpression;
        readonly usage: O.Option<TSESTree.Node>;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "FunctionDeclaration";
        readonly node: TSESTree.FunctionDeclaration;
        readonly usage: O.Option<TSESTree.Expression | TSESTree.Identifier>;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "FunctionExpression";
        readonly node: TSESTree.ArrowFunctionExpression | TSESTree.FunctionExpression;
        readonly usage: O.Option<TSESTree.Node>;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "JSXElement";
        readonly node: TSESTree.JSXElement;
        readonly usage: O.Option<TSESTree.Node>;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "JSXFragment";
        readonly node: TSESTree.JSXFragment;
        readonly usage: O.Option<TSESTree.Node>;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "NewExpression";
        readonly node: TSESTree.NewExpression;
        readonly usage: O.Option<TSESTree.Node>;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "None";
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "ObjectExpression";
        readonly node: TSESTree.ObjectExpression;
        readonly usage: O.Option<TSESTree.Node>;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "RegExpLiteral";
        readonly node: TSESTree.Literal;
        readonly usage: O.Option<TSESTree.Node>;
    }, {
        readonly _tag: Tag;
    }>;
    readonly $match: {
        <Cases extends {
            readonly Array: (args: {
                readonly _tag: "Array";
                readonly node: TSESTree.ArrayExpression;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly AssignmentExpression: (args: {
                readonly _tag: "AssignmentExpression";
                readonly node: TSESTree.Node;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly AssignmentPattern: (args: {
                readonly _tag: "AssignmentPattern";
                readonly node: TSESTree.Node;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly CallExpression: (args: {
                readonly _tag: "CallExpression";
                readonly node: TSESTree.CallExpression;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly ClassExpression: (args: {
                readonly _tag: "ClassExpression";
                readonly node: TSESTree.ClassExpression;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly FunctionDeclaration: (args: {
                readonly _tag: "FunctionDeclaration";
                readonly node: TSESTree.FunctionDeclaration;
                readonly usage: O.Option<TSESTree.Expression | TSESTree.Identifier>;
            }) => any;
            readonly FunctionExpression: (args: {
                readonly _tag: "FunctionExpression";
                readonly node: TSESTree.ArrowFunctionExpression | TSESTree.FunctionExpression;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly JSXElement: (args: {
                readonly _tag: "JSXElement";
                readonly node: TSESTree.JSXElement;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly JSXFragment: (args: {
                readonly _tag: "JSXFragment";
                readonly node: TSESTree.JSXFragment;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly NewExpression: (args: {
                readonly _tag: "NewExpression";
                readonly node: TSESTree.NewExpression;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly None: (args: {
                readonly _tag: "None";
            }) => any;
            readonly ObjectExpression: (args: {
                readonly _tag: "ObjectExpression";
                readonly node: TSESTree.ObjectExpression;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly RegExpLiteral: (args: {
                readonly _tag: "RegExpLiteral";
                readonly node: TSESTree.Literal;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
        }>(cases: Cases): (value: {
            readonly _tag: "Array";
            readonly node: TSESTree.ArrayExpression;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "AssignmentExpression";
            readonly node: TSESTree.Node;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "AssignmentPattern";
            readonly node: TSESTree.Node;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "CallExpression";
            readonly node: TSESTree.CallExpression;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "ClassExpression";
            readonly node: TSESTree.ClassExpression;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "FunctionDeclaration";
            readonly node: TSESTree.FunctionDeclaration;
            readonly usage: O.Option<TSESTree.Expression | TSESTree.Identifier>;
        } | {
            readonly _tag: "FunctionExpression";
            readonly node: TSESTree.ArrowFunctionExpression | TSESTree.FunctionExpression;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "JSXElement";
            readonly node: TSESTree.JSXElement;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "JSXFragment";
            readonly node: TSESTree.JSXFragment;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "NewExpression";
            readonly node: TSESTree.NewExpression;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "None";
        } | {
            readonly _tag: "ObjectExpression";
            readonly node: TSESTree.ObjectExpression;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "RegExpLiteral";
            readonly node: TSESTree.Literal;
            readonly usage: O.Option<TSESTree.Node>;
        }) => effect_Unify.Unify<ReturnType<Cases["Array" | "AssignmentExpression" | "AssignmentPattern" | "CallExpression" | "ClassExpression" | "FunctionDeclaration" | "FunctionExpression" | "JSXElement" | "JSXFragment" | "NewExpression" | "None" | "ObjectExpression" | "RegExpLiteral"]>>;
        <Cases extends {
            readonly Array: (args: {
                readonly _tag: "Array";
                readonly node: TSESTree.ArrayExpression;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly AssignmentExpression: (args: {
                readonly _tag: "AssignmentExpression";
                readonly node: TSESTree.Node;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly AssignmentPattern: (args: {
                readonly _tag: "AssignmentPattern";
                readonly node: TSESTree.Node;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly CallExpression: (args: {
                readonly _tag: "CallExpression";
                readonly node: TSESTree.CallExpression;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly ClassExpression: (args: {
                readonly _tag: "ClassExpression";
                readonly node: TSESTree.ClassExpression;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly FunctionDeclaration: (args: {
                readonly _tag: "FunctionDeclaration";
                readonly node: TSESTree.FunctionDeclaration;
                readonly usage: O.Option<TSESTree.Expression | TSESTree.Identifier>;
            }) => any;
            readonly FunctionExpression: (args: {
                readonly _tag: "FunctionExpression";
                readonly node: TSESTree.ArrowFunctionExpression | TSESTree.FunctionExpression;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly JSXElement: (args: {
                readonly _tag: "JSXElement";
                readonly node: TSESTree.JSXElement;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly JSXFragment: (args: {
                readonly _tag: "JSXFragment";
                readonly node: TSESTree.JSXFragment;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly NewExpression: (args: {
                readonly _tag: "NewExpression";
                readonly node: TSESTree.NewExpression;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly None: (args: {
                readonly _tag: "None";
            }) => any;
            readonly ObjectExpression: (args: {
                readonly _tag: "ObjectExpression";
                readonly node: TSESTree.ObjectExpression;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
            readonly RegExpLiteral: (args: {
                readonly _tag: "RegExpLiteral";
                readonly node: TSESTree.Literal;
                readonly usage: O.Option<TSESTree.Node>;
            }) => any;
        }>(value: {
            readonly _tag: "Array";
            readonly node: TSESTree.ArrayExpression;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "AssignmentExpression";
            readonly node: TSESTree.Node;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "AssignmentPattern";
            readonly node: TSESTree.Node;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "CallExpression";
            readonly node: TSESTree.CallExpression;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "ClassExpression";
            readonly node: TSESTree.ClassExpression;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "FunctionDeclaration";
            readonly node: TSESTree.FunctionDeclaration;
            readonly usage: O.Option<TSESTree.Expression | TSESTree.Identifier>;
        } | {
            readonly _tag: "FunctionExpression";
            readonly node: TSESTree.ArrowFunctionExpression | TSESTree.FunctionExpression;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "JSXElement";
            readonly node: TSESTree.JSXElement;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "JSXFragment";
            readonly node: TSESTree.JSXFragment;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "NewExpression";
            readonly node: TSESTree.NewExpression;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "None";
        } | {
            readonly _tag: "ObjectExpression";
            readonly node: TSESTree.ObjectExpression;
            readonly usage: O.Option<TSESTree.Node>;
        } | {
            readonly _tag: "RegExpLiteral";
            readonly node: TSESTree.Literal;
            readonly usage: O.Option<TSESTree.Node>;
        }, cases: Cases): effect_Unify.Unify<ReturnType<Cases["Array" | "AssignmentExpression" | "AssignmentPattern" | "CallExpression" | "ClassExpression" | "FunctionDeclaration" | "FunctionExpression" | "JSXElement" | "JSXFragment" | "NewExpression" | "None" | "ObjectExpression" | "RegExpLiteral"]>>;
    };
};
type ConstructionHint = bigint;
declare const ConstructionHint: {
    None: bigint;
    StrictCallExpression: bigint;
};
/**
 * Get a function that detects the construction of a given node.
 * @param node The AST node to detect the construction of
 * @param initialScope The initial scope to use when detecting the construction
 * @param hint The hint to use when detecting the construction
 * @returns A function that detects the construction of a given node
 */
declare function inspectConstruction(node: TSESTree.Node, initialScope: Scope, hint?: bigint): Construction;

declare const findVariable: {
    (initialScope: Scope): (nameOrNode: string | TSESTree.Identifier) => O.Option<Variable>;
    (nameOrNode: string | TSESTree.Identifier, initialScope: Scope): O.Option<Variable>;
};

declare function getChidScopes(scope: Scope, prev?: readonly Scope[]): readonly Scope[];

declare function getScope(node: TSESTree.Node, scopeManager: ScopeManager): _typescript_eslint_scope_manager.Scope | null;

declare function getStaticValue(node: TSESTree.Node, initialScope: Scope): O.Option<unknown>;

declare function getVariableDeclaratorID(node: TSESTree.Node, prev?: TSESTree.Node): O.Option<TSESTree.BindingName | TSESTree.Expression>;

/**
 * Get the init node of the nth definition of a variable
 * @param at The index number of def in defs
 * @returns A function that takes a variable and returns the init node of the nth definition of that variable
 */
declare function getVariableNode(at: number): (variable: Variable) => O.Option<TSESTree.ClassDeclaration | TSESTree.ClassDeclarationWithName | TSESTree.ClassDeclarationWithOptionalName | TSESTree.Expression | TSESTree.FunctionDeclaration | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName>;

/**
 * Get all variables from the given scope up to the global scope
 * @param initialScope The scope to start from
 * @returns All variables from the given scope up to the global scope
 */
declare function getVariables(initialScope: Scope): Variable[];

/**
 * Check if an identifier is initialized from the given source
 * @param name The top-level identifier's name
 * @param source The import source to check against
 * @param initialScope Initial scope to search for the identifier
 * @returns Whether the identifier is initialized from the given source
 */
declare function isInitializedFromSource(name: string, source: string, initialScope: Scope): boolean;

/**
 * Determines whether node value equals to another node value
 * @param a node to compare
 * @param b node to compare
 * @param initialScopes initial scopes of the two nodes
 * @returns `true` if node value equal
 */
declare function isNodeValueEqual(a: TSESTree.Node, b: TSESTree.Node, initialScopes: [
    aScope: Scope,
    bScope: Scope
]): boolean;

export { Construction, ConstructionHint, findVariable, getChidScopes, getScope, getStaticValue, getVariableDeclaratorID, getVariableNode, getVariables, inspectConstruction, isInitializedFromSource, isNodeValueEqual };
