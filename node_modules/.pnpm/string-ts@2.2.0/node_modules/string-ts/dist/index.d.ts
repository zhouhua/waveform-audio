/**
 * Returns true if input number type is a literal
 */
type IsNumberLiteral<T extends number> = [T] extends [number] ? [number] extends [T] ? false : true : false;
type IsBooleanLiteral<T extends boolean> = [T] extends [boolean] ? [boolean] extends [T] ? false : true : false;
/**
 * Returns true if any elements in boolean array are the literal true (not false or boolean)
 */
type Any<Arr extends boolean[]> = Arr extends [
    infer Head extends boolean,
    ...infer Rest extends boolean[]
] ? IsBooleanLiteral<Head> extends true ? Head extends true ? true : Any<Rest> : Any<Rest> : false;
/**
 * Returns true if every element in boolean array is the literal true (not false or boolean)
 */
type All<Arr extends boolean[]> = IsBooleanLiteral<Arr[number]> extends true ? Arr extends [infer Head extends boolean, ...infer Rest extends boolean[]] ? Head extends true ? Any<Rest> : false : true : false;
/**
 * Returns true if string input type is a literal
 */
type IsStringLiteral<T extends string> = [T] extends [string] ? [string] extends [T] ? false : Uppercase<T> extends Uppercase<Lowercase<T>> ? Lowercase<T> extends Lowercase<Uppercase<T>> ? true : false : false : false;
type IsStringLiteralArray<Arr extends string[] | readonly string[]> = IsStringLiteral<Arr[number]> extends true ? true : false;

/**
 * Splits a string into an array of substrings.
 * T: The string to split.
 * delimiter: The delimiter.
 */
type Split<T extends string, delimiter extends string = ''> = IsStringLiteral<T | delimiter> extends true ? T extends `${infer first}${delimiter}${infer rest}` ? [first, ...Split<rest, delimiter>] : T extends '' ? [] : [T] : string[];
/**
 * A strongly-typed version of `String.prototype.split`.
 * @param str the string to split.
 * @param delimiter the delimiter.
 * @returns the splitted string in both type level and runtime.
 * @example split('hello world', ' ') // ['hello', 'world']
 */
declare function split<T extends string, D extends string = ''>(str: T, delimiter?: D): Split<T, D>;

/**
 * Gets the character at the given index.
 * T: The string to get the character from.
 * index: The index of the character.
 */
type CharAt<T extends string, index extends number> = All<[
    IsStringLiteral<T>,
    IsNumberLiteral<index>
]> extends true ? Split<T>[index] : string;
/**
 * A strongly-typed version of `String.prototype.charAt`.
 * @param str the string to get the character from.
 * @param index the index of the character.
 * @returns the character in both type level and runtime.
 * @example charAt('hello world', 6) // 'w'
 */
declare function charAt<T extends string, I extends number>(str: T, index: I): CharAt<T, I>;

/**
 * Joins a tuple of strings with the given delimiter.
 * T: The tuple of strings to join.
 * delimiter: The delimiter.
 */
type Join<T extends readonly string[], delimiter extends string = ''> = All<[IsStringLiteralArray<T>, IsStringLiteral<delimiter>]> extends true ? T extends readonly [
    infer first extends string,
    ...infer rest extends string[]
] ? rest extends [] ? first : `${first}${delimiter}${Join<rest, delimiter>}` : '' : string;
/**
 * A strongly-typed version of `Array.prototype.join`.
 * @param tuple the tuple of strings to join.
 * @param delimiter the delimiter.
 * @returns the joined string in both type level and runtime.
 * @example join(['hello', 'world'], '-') // 'hello-world'
 */
declare function join<const T extends readonly string[], D extends string = ''>(tuple: T, delimiter?: D): Join<T, D>;

/**
 * Concatenates a tuple of strings.
 * T: The tuple of strings to concatenate.
 */
type Concat<T extends string[]> = Join<T>;
/**
 * A strongly-typed version of `String.prototype.concat`.
 * @param strings the tuple of strings to concatenate.
 * @returns the concatenated string in both type level and runtime.
 * @example concat('a', 'bc', 'def') // 'abcdef'
 */
declare function concat<T extends string[]>(...strings: T): Concat<T>;

/**
 * Gets the length of a string.
 */
type Length<T extends string> = IsStringLiteral<T> extends true ? Split<T>['length'] : number;
/**
 * A strongly-typed version of `String.prototype.length`.
 * @param str the string to get the length from.
 * @returns the length of the string in both type level and runtime.
 * @example length('hello world') // 11
 */
declare function length<T extends string>(str: T): Length<T>;

/**
 * PascalCases all the words in a tuple of strings
 */
type PascalCaseAll<T extends string[]> = T extends [
    infer head extends string,
    ...infer rest extends string[]
] ? [Capitalize<Lowercase<head>>, ...PascalCaseAll<rest>] : T;
/**
 * Removes all the elements matching the given condition from a tuple.
 */
type Reject<tuple, cond, output extends any[] = []> = tuple extends [
    infer first,
    ...infer rest
] ? Reject<rest, cond, first extends cond ? output : [...output, first]> : output;
/**
 * Removes the given suffix from a sentence.
 */
type DropSuffix<sentence extends string, suffix extends string> = string extends sentence | suffix ? string : sentence extends `${infer rest}${suffix}` ? rest : sentence;
/**
 * Returns a tuple of the given length with the given type.
 */
type TupleOf<L extends number, T = unknown, result extends any[] = []> = result['length'] extends L ? result : TupleOf<L, T, [...result, T]>;

declare namespace Math {
    type Subtract<A extends number, B extends number> = number extends A | B ? number : TupleOf<A> extends [...infer U, ...TupleOf<B>] ? U['length'] : 0;
    type IsNegative<T extends number> = number extends T ? boolean : `${T}` extends `-${number}` ? true : false;
    type Abs<T extends number> = `${T}` extends `-${infer U extends number}` ? U : T;
    type GetPositiveIndex<T extends string, I extends number> = IsNegative<I> extends false ? I : Subtract<Length<T>, Abs<I>>;
}

/**
 * Slices a string from a startIndex to an endIndex.
 * T: The string to slice.
 * startIndex: The start index.
 * endIndex: The end index.
 */
type Slice<T extends string, startIndex extends number = 0, endIndex extends number | undefined = undefined> = endIndex extends number ? _Slice<T, startIndex, endIndex> : _SliceStart<T, startIndex>;
/** Slice with startIndex and endIndex */
type _Slice<T extends string, startIndex extends number, endIndex extends number, _result extends string = ''> = IsNumberLiteral<startIndex | endIndex> extends true ? T extends `${infer head}${infer rest}` ? IsStringLiteral<head> extends true ? startIndex extends 0 ? endIndex extends 0 ? _result : _Slice<rest, 0, Math.Subtract<Math.GetPositiveIndex<T, endIndex>, 1>, `${_result}${head}`> : _Slice<rest, Math.Subtract<Math.GetPositiveIndex<T, startIndex>, 1>, Math.Subtract<Math.GetPositiveIndex<T, endIndex>, 1>, _result> : startIndex | endIndex extends 0 ? _result : string : IsStringLiteral<T> extends true ? _result : startIndex | endIndex extends 0 ? _result : string : string;
/** Slice with startIndex only */
type _SliceStart<T extends string, startIndex extends number, _result extends string = ''> = IsNumberLiteral<startIndex> extends true ? T extends `${infer head}${infer rest}` ? IsStringLiteral<head> extends true ? startIndex extends 0 ? T : _SliceStart<rest, Math.Subtract<Math.GetPositiveIndex<T, startIndex>, 1>, _result> : string : IsStringLiteral<T> extends true ? _result : startIndex extends 0 ? _result : string : string;
/**
 * A strongly-typed version of `String.prototype.slice`.
 * @param str the string to slice.
 * @param start the start index.
 * @param end the end index.
 * @returns the sliced string in both type level and runtime.
 * @example slice('hello world', 6) // 'world'
 */
declare function slice<T extends string, S extends number = 0, E extends number | undefined = undefined>(str: T, start?: S, end?: E): Slice<T, S, E>;

/**
 * Checks if a string starts with another string.
 * T: The string to check.
 * S: The string to check against.
 * P: The position to start the search.
 */
type StartsWith<T extends string, S extends string, P extends number = 0> = All<[IsStringLiteral<S>, IsNumberLiteral<P>]> extends true ? Math.IsNegative<P> extends false ? P extends 0 ? S extends `${infer SHead}${infer SRest}` ? T extends `${infer THead}${infer TRest}` ? IsStringLiteral<THead | SHead> extends true ? THead extends SHead ? StartsWith<TRest, SRest> : false : boolean : IsStringLiteral<T> extends true ? false : boolean : true : StartsWith<Slice<T, P>, S, 0> : StartsWith<T, S, 0> : boolean;
/**
 * A strongly-typed version of `String.prototype.startsWith`.
 * @param text the string to search.
 * @param search the string to search with.
 * @param position the index to start search at.
 * @returns boolean, whether or not the text string starts with the search string.
 * @example startsWith('abc', 'a') // true
 */
declare function startsWith<T extends string, S extends string, P extends number = 0>(text: T, search: S, position?: P): StartsWith<T, S, P>;

/**
 * Reverses a string.
 * - `T` The string to reverse.
 */
type Reverse<T extends string, _acc extends string = ''> = T extends `${infer Head}${infer Tail}` ? Reverse<Tail, `${Head}${_acc}`> : _acc extends '' ? T : `${T}${_acc}`;
/**
 * A strongly-typed function to reverse a string.
 * @param str the string to reverse.
 * @returns the reversed string in both type level and runtime.
 * @example reverse('hello world') // 'dlrow olleh'
 */
declare function reverse<T extends string>(str: T): Reverse<T, "">;

/**
 * Checks if a string ends with another string.
 * T: The string to check.
 * S: The string to check against.
 * P: The position the search should end.
 */
type EndsWith<T extends string, S extends string, P extends number | undefined = undefined> = P extends number ? _EndsWith<T, S, P> : _EndsWithNoPosition<T, S>;
type _EndsWith<T extends string, S extends string, P extends number> = All<[
    IsStringLiteral<S>,
    IsNumberLiteral<P>
]> extends true ? Math.IsNegative<P> extends false ? P extends Length<T> ? IsStringLiteral<T> extends true ? S extends Slice<T, Math.Subtract<Length<T>, Length<S>>, Length<T>> ? true : false : _EndsWithNoPosition<Slice<T, 0, P>, S> : _EndsWithNoPosition<Slice<T, 0, P>, S> : false : boolean;
/** Overload of EndsWith without P */
type _EndsWithNoPosition<T extends string, S extends string> = StartsWith<Reverse<T>, Reverse<S>>;
/**
 * A strongly-typed version of `String.prototype.endsWith`.
 * @param text the string to search.
 * @param search the string to search with.
 * @param position the index the search should end at.
 * @returns boolean, whether or not the text string ends with the search string.
 * @example endsWith('abc', 'c') // true
 */
declare function endsWith<T extends string, S extends string, P extends number = Length<T>>(text: T, search: S, position?: P): EndsWith<T, S, P>;

/**
 * Checks if a string includes another string.
 * T: The string to check.
 * S: The string to check against.
 * P: The position to start the search.
 */
type Includes<T extends string, S extends string, P extends number = 0> = string extends T | S ? boolean : Math.IsNegative<P> extends false ? P extends 0 ? T extends `${string}${S}${string}` ? true : false : Includes<Slice<T, P>, S, 0> : Includes<T, S, 0>;
/**
 * A strongly-typed version of `String.prototype.includes`.
 * @param text the string to search
 * @param search the string to search with
 * @param position the index to start search at
 * @returns boolean, whether or not the text contains the search string.
 * @example includes('abcde', 'bcd') // true
 */
declare function includes<T extends string, S extends string, P extends number = 0>(text: T, search: S, position?: P): Includes<T, S, P>;

/**
 * Repeats a string N times.
 * T: The string to repeat.
 * N: The number of times to repeat.
 */
type Repeat<T extends string, times extends number = 0> = All<[
    IsStringLiteral<T>,
    IsNumberLiteral<times>
]> extends true ? times extends 0 ? '' : Math.IsNegative<times> extends false ? Join<TupleOf<times, T>> : never : string;
/**
 * A strongly-typed version of `String.prototype.repeat`.
 * @param str the string to repeat.
 * @param times the number of times to repeat.
 * @returns the repeated string in both type level and runtime.
 * @example repeat('hello', 3) // 'hellohellohello'
 */
declare function repeat<T extends string, N extends number = 0>(str: T, times?: N): Repeat<T, N>;

/**
 * Pads a string at the end with another string.
 * T: The string to pad.
 * times: The number of times to pad.
 * pad: The string to pad with.
 */
type PadEnd<T extends string, times extends number = 0, pad extends string = ' '> = All<[IsStringLiteral<T | pad>, IsNumberLiteral<times>]> extends true ? Math.IsNegative<times> extends false ? Math.Subtract<times, Length<T>> extends infer missing extends number ? `${T}${Slice<Repeat<pad, missing>, 0, missing>}` : never : T : string;
/**
 * A strongly-typed version of `String.prototype.padEnd`.
 * @param str the string to pad.
 * @param length the length to pad.
 * @param pad the string to pad with.
 * @returns the padded string in both type level and runtime.
 * @example padEnd('hello', 10, '=') // 'hello====='
 */
declare function padEnd<T extends string, N extends number = 0, U extends string = ' '>(str: T, length?: N, pad?: U): PadEnd<T, N, U>;

/**
 * Pads a string at the start with another string.
 * T: The string to pad.
 * times: The number of times to pad.
 * pad: The string to pad with.
 */
type PadStart<T extends string, times extends number = 0, pad extends string = ' '> = All<[IsStringLiteral<T | pad>, IsNumberLiteral<times>]> extends true ? Math.IsNegative<times> extends false ? Math.Subtract<times, Length<T>> extends infer missing extends number ? `${Slice<Repeat<pad, missing>, 0, missing>}${T}` : never : T : string;
/**
 * A strongly-typed version of `String.prototype.padStart`.
 * @param str the string to pad.
 * @param length the length to pad.
 * @param pad the string to pad with.
 * @returns the padded string in both type level and runtime.
 * @example padStart('hello', 10, '=') // '=====hello'
 */
declare function padStart<T extends string, N extends number = 0, U extends string = ' '>(str: T, length?: N, pad?: U): PadStart<T, N, U>;

/**
 * Replaces the first occurrence of a string with another string.
 * sentence: The sentence to replace.
 * lookup: The lookup string to be replaced.
 * replacement: The replacement string.
 */
type Replace<sentence extends string, lookup extends string | RegExp, replacement extends string = ''> = lookup extends string ? IsStringLiteral<lookup | sentence | replacement> extends true ? sentence extends `${infer rest}${lookup}${infer rest2}` ? `${rest}${replacement}${rest2}` : sentence : string : string;
/**
 * A strongly-typed version of `String.prototype.replace`.
 * @param sentence the sentence to replace.
 * @param lookup the lookup string to be replaced.
 * @param replacement the replacement string.
 * @returns the replaced string in both type level and runtime.
 * @example replace('hello world', 'l', '1') // 'he1lo world'
 */
declare function replace<T extends string, S extends string | RegExp, R extends string = ''>(sentence: T, lookup: S, replacement?: R): Replace<T, S, R>;

/**
 * Replaces all the occurrences of a string with another string.
 * sentence: The sentence to replace.
 * lookup: The lookup string to be replaced.
 * replacement: The replacement string.
 */
type ReplaceAll<sentence extends string, lookup extends string | RegExp, replacement extends string = ''> = lookup extends string ? IsStringLiteral<lookup | sentence | replacement> extends true ? sentence extends `${infer rest}${lookup}${infer rest2}` ? `${rest}${replacement}${ReplaceAll<rest2, lookup, replacement>}` : sentence : string : string;
/**
 * A strongly-typed version of `String.prototype.replaceAll`.
 * @param sentence the sentence to replace.
 * @param lookup the lookup string to be replaced.
 * @param replacement the replacement string.
 * @returns the replaced string in both type level and runtime.
 * @example replaceAll('hello world', 'l', '1') // 'he11o wor1d'
 */
declare function replaceAll<T extends string, S extends string | RegExp, R extends string = ''>(sentence: T, lookup: S, replacement?: R): ReplaceAll<T, S, R>;

/**
 * Trims all whitespaces at the start of a string.
 * T: The string to trim.
 */
type TrimStart<T extends string> = IsStringLiteral<T> extends true ? T extends ` ${infer rest}` ? TrimStart<rest> : T : string;
/**
 * A strongly-typed version of `String.prototype.trimStart`.
 * @param str the string to trim.
 * @returns the trimmed string in both type level and runtime.
 * @example trimStart(' hello world ') // 'hello world '
 */
declare function trimStart<T extends string>(str: T): TrimStart<T>;

/**
 * Trims all whitespaces at the end of a string.
 * T: The string to trim.
 */
type TrimEnd<T extends string> = IsStringLiteral<T> extends true ? T extends `${infer rest} ` ? TrimEnd<rest> : T : string;
/**
 * A strongly-typed version of `String.prototype.trimEnd`.
 * @param str the string to trim.
 * @returns the trimmed string in both type level and runtime.
 * @example trimEnd(' hello world ') // ' hello world'
 */
declare function trimEnd<T extends string>(str: T): TrimEnd<T>;

/**
 * Trims all whitespaces at the start and end of a string.
 * T: The string to trim.
 */
type Trim<T extends string> = TrimEnd<TrimStart<T>>;
/**
 * A strongly-typed version of `String.prototype.trim`.
 * @param str the string to trim.
 * @returns the trimmed string in both type level and runtime.
 * @example trim(' hello world ') // 'hello world'
 */
declare function trim<T extends string>(str: T): TrimEnd<TrimStart<T>>;

/**
 * This function is a strongly-typed counterpart of String.prototype.toLowerCase.
 * @param str the string to make lowercase.
 * @returns the lowercased string.
 * @example toLowerCase('HELLO WORLD') // 'hello world'
 */
declare function toLowerCase<T extends string>(str: T): Lowercase<T>;

/**
 * This function is a strongly-typed counterpart of String.prototype.toUpperCase.
 * @param str the string to make uppercase.
 * @returns the uppercased string.
 * @example toUpperCase('hello world') // 'HELLO WORLD'
 */
declare function toUpperCase<T extends string>(str: T): Uppercase<T>;

/**
 * Truncate a string if it's longer than the given maximum length.
 * The last characters of the truncated string are replaced with the omission string which defaults to "...".
 */
type Truncate<T extends string, Size extends number, Omission extends string = '...'> = All<[IsStringLiteral<T | Omission>, IsNumberLiteral<Size>]> extends true ? Math.IsNegative<Size> extends true ? Omission : Math.Subtract<Length<T>, Size> extends 0 ? T : Join<[Slice<T, 0, Math.Subtract<Size, Length<Omission>>>, Omission]> : string;
/**
 * A strongly typed function to truncate a string if it's longer than the given maximum string length.
 * The last characters of the truncated string are replaced with the omission string which defaults to "...".
 * @param sentence the sentence to extract the words from.
 * @param length the maximum length of the string.
 * @param omission the string to append to the end of the truncated string.
 * @returns the truncated string
 * @example truncate('Hello, World', 8) // 'Hello...'
 */
declare function truncate<T extends string, S extends number, P extends string = '...'>(sentence: T, length: S, omission?: P): Truncate<T, S, P>;

declare const SEPARATORS: readonly ["[", "]", "{", "}", "(", ")", "|", "/", "-", "\\", " ", "_", "."];
type Separator = (typeof SEPARATORS)[number];
/**
 * Checks if the given character is a separator.
 * E.g. space, underscore, dash, dot, slash.
 */
type IsSeparator<T extends string> = IsStringLiteral<T> extends true ? T extends Separator ? true : false : boolean;

type UpperChars = 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z';
type LowerChars = Lowercase<UpperChars>;
/**
 * Checks if the given character is an upper case letter.
 */
type IsUpper<T extends string> = IsStringLiteral<T> extends true ? T extends UpperChars ? true : false : boolean;
/**
 * Checks if the given character is a lower case letter.
 */
type IsLower<T extends string> = IsStringLiteral<T> extends true ? T extends LowerChars ? true : false : boolean;
/**
 * Checks if the given character is a letter.
 */
type IsLetter<T extends string> = IsStringLiteral<T> extends true ? T extends LowerChars | UpperChars ? true : false : boolean;

type Digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
/**
 * Checks if the given character is a number.
 */
type IsDigit<T extends string> = IsStringLiteral<T> extends true ? T extends Digit ? true : false : boolean;

type Apostrophe = "'";
/**
 * Checks if the given character is an apostrophe
 */
type IsApostrophe<T extends string> = IsStringLiteral<T> extends true ? T extends Apostrophe ? true : false : boolean;
type RemoveApostrophe<T extends string> = ReplaceAll<T, "'", ''>;

/**
 * Checks if the given character is a special character.
 * E.g. not a letter, number, or separator.
 */
type IsSpecial<T extends string> = IsStringLiteral<T> extends true ? IsLetter<T> extends true ? false : IsDigit<T> extends true ? false : IsSeparator<T> extends true ? false : IsApostrophe<T> extends true ? false : true : boolean;

/**
 * Splits a string into words.
 * sentence: The current string to split.
 * word: The current word.
 * prev: The previous character.
 */
type Words<sentence extends string, word extends string = '', prev extends string = ''> = IsStringLiteral<sentence | word | prev> extends true ? sentence extends `${infer curr}${infer rest}` ? IsSeparator<curr> extends true ? Reject<[word, ...Words<rest>], ''> : prev extends '' ? Reject<Words<rest, curr, curr>, ''> : [false, true] extends [IsDigit<prev>, IsDigit<curr>] ? [
    word,
    ...Words<rest, curr, curr>
] : [true, false] extends [IsDigit<prev>, IsDigit<curr>] ? [
    word,
    ...Words<rest, curr, curr>
] : [false, true] extends [IsSpecial<prev>, IsSpecial<curr>] ? [
    word,
    ...Words<rest, curr, curr>
] : [true, false] extends [IsSpecial<prev>, IsSpecial<curr>] ? [
    word,
    ...Words<rest, curr, curr>
] : [true, true] extends [IsDigit<prev>, IsDigit<curr>] ? Reject<Words<rest, `${word}${curr}`, curr>, ''> : [true, true] extends [IsLower<prev>, IsUpper<curr>] ? [
    word,
    ...Words<rest, curr, curr>
] : [true, true] extends [IsUpper<prev>, IsLower<curr>] ? [
    DropSuffix<word, prev>,
    ...Words<rest, `${prev}${curr}`, curr>
] : Reject<Words<rest, `${word}${curr}`, curr>, ''> : Reject<[word], ''> : string[];
/**
 * A strongly-typed function to extract the words from a sentence.
 * @param sentence the sentence to extract the words from.
 * @returns an array of words in both type level and runtime.
 * @example words('helloWorld') // ['hello', 'World']
 */
declare function words<T extends string>(sentence: T): Words<T>;

/**
 * Transforms a string to PascalCase.
 */
type PascalCase<T extends string> = Join<PascalCaseAll<Words<RemoveApostrophe<T>>>>;
/**
 * A strongly typed version of `pascalCase` that works in both runtime and type level.
 * @param str the string to convert to pascal case.
 * @returns the pascal cased string.
 * @example pascalCase('hello world') // 'HelloWorld'
 */
declare function pascalCase<T extends string>(str: T): PascalCase<T>;
/**
 * @deprecated
 * Use `pascalCase` instead.
 * Read more about the deprecation [here](https://github.com/gustavoguichard/string-ts/issues/44).
 */
declare const toPascalCase: typeof pascalCase;

/**
 * Transforms a string to camelCase.
 */
type CamelCase<T extends string> = Uncapitalize<PascalCase<RemoveApostrophe<T>>>;
/**
 * A strongly typed version of `camelCase` that works in both runtime and type level.
 * @param str the string to convert to camel case.
 * @returns the camel cased string.
 * @example camelCase('hello world') // 'helloWorld'
 */
declare function camelCase<T extends string>(str: T): CamelCase<T>;
/**
 * @deprecated
 * Use `camelCase` instead.
 * Read more about the deprecation [here](https://github.com/gustavoguichard/string-ts/issues/44).
 */
declare const toCamelCase: typeof camelCase;

/**
 * Transforms a string with the specified separator (delimiter).
 */
type DelimiterCase<T extends string, D extends string> = Join<Words<RemoveApostrophe<T>>, D>;
/**
 * A function that transforms a string by splitting it into words and joining them with the specified delimiter.
 * @param str the string to transform.
 * @param delimiter the delimiter to use.
 * @returns the transformed string.
 * @example delimiterCase('hello world', '.') // 'hello.world'
 */
declare function delimiterCase<T extends string, D extends string>(str: T, delimiter: D): DelimiterCase<T, D>;
/**
 * @deprecated
 * Use `delimiterCase` instead.
 * Read more about the deprecation [here](https://github.com/gustavoguichard/string-ts/issues/44).
 */
declare const toDelimiterCase: typeof delimiterCase;

/**
 * Transforms a string to CONSTANT_CASE.
 */
type ConstantCase<T extends string> = Uppercase<DelimiterCase<RemoveApostrophe<T>, '_'>>;
/**
 * A strongly typed version of `constantCase` that works in both runtime and type level.
 * @param str the string to convert to constant case.
 * @returns the constant cased string.
 * @example constantCase('hello world') // 'HELLO_WORLD'
 */
declare function constantCase<T extends string>(str: T): ConstantCase<T>;
/**
 * @deprecated
 * Use `constantCase` instead.
 * Read more about the deprecation [here](https://github.com/gustavoguichard/string-ts/issues/44).
 */
declare const toConstantCase: typeof constantCase;

/**
 * Transforms a string to kebab-case.
 */
type KebabCase<T extends string> = Lowercase<DelimiterCase<RemoveApostrophe<T>, '-'>>;
/**
 * A strongly typed version of `kebabCase` that works in both runtime and type level.
 * @param str the string to convert to kebab case.
 * @returns the kebab cased string.
 * @example kebabCase('hello world') // 'hello-world'
 */
declare function kebabCase<T extends string>(str: T): KebabCase<T>;
/**
 * @deprecated
 * Use `kebabCase` instead.
 * Read more about the deprecation [here](https://github.com/gustavoguichard/string-ts/issues/44).
 */
declare const toKebabCase: typeof kebabCase;

/**
 * Transforms a string to snake_case.
 */
type SnakeCase<T extends string> = Lowercase<DelimiterCase<RemoveApostrophe<T>, '_'>>;
/**
 * A strongly typed version of `snakeCase` that works in both runtime and type level.
 * @param str the string to convert to snake case.
 * @returns the snake cased string.
 * @example snakeCase('hello world') // 'hello_world'
 */
declare function snakeCase<T extends string>(str: T): SnakeCase<T>;
/**
 * @deprecated
 * Use `snakeCase` instead.
 * Read more about the deprecation [here](https://github.com/gustavoguichard/string-ts/issues/44).
 */
declare const toSnakeCase: typeof snakeCase;

/**
 * Transforms a string to "Title Case".
 */
type TitleCase<T extends string> = DelimiterCase<PascalCase<T>, ' '>;
/**
 * A strongly typed version of `titleCase` that works in both runtime and type level.
 * @param str the string to convert to title case.
 * @returns the title cased string.
 * @example titleCase('hello world') // 'Hello World'
 */
declare function titleCase<T extends string>(str: T): TitleCase<T>;
/**
 * @deprecated
 * Use `titleCase` instead.
 * Read more about the deprecation [here](https://github.com/gustavoguichard/string-ts/issues/44).
 */
declare const toTitleCase: typeof titleCase;

/**
 * Capitalizes the first letter of a string. This is a runtime counterpart of `Capitalize<T>` from `src/types.d.ts`.
 * @param str the string to capitalize.
 * @returns the capitalized string.
 * @example capitalize('hello world') // 'Hello world'
 */
declare function capitalize<T extends string>(str: T): Capitalize<T>;

/**
 * A strongly-typed version of `lowerCase` that works in both runtime and type level.
 * @param str the string to convert to lower case.
 * @returns the lowercased string.
 * @example lowerCase('HELLO-WORLD') // 'hello world'
 */
declare function lowerCase<T extends string>(str: T): Lowercase<DelimiterCase<T, ' '>>;

/**
 * Uncapitalizes the first letter of a string. This is a runtime counterpart of `Uncapitalize<T>` from `src/types.d.ts`.
 * @param str the string to uncapitalize.
 * @returns the uncapitalized string.
 * @example uncapitalize('Hello world') // 'hello world'
 */
declare function uncapitalize<T extends string>(str: T): Uncapitalize<T>;

/**
 * A strongly-typed version of `upperCase` that works in both runtime and type level.
 * @param str the string to convert to upper case.
 * @returns the uppercased string.
 * @example upperCase('hello-world') // 'HELLO WORLD'
 */
declare function upperCase<T extends string>(str: T): Uppercase<DelimiterCase<T, ' '>>;

/**
 * Shallowly transforms the keys of a Record to camelCase.
 * T: the type of the Record to transform.
 */
type CamelKeys<T> = T extends [] ? T : {
    [K in keyof T as CamelCase<Extract<K, string>>]: T[K];
};
/**
 * A strongly typed function that shallowly transforms the keys of an object to camelCase. The transformation is done both at runtime and type level.
 * @param obj the object to transform.
 * @returns the transformed object.
 * @example camelKeys({ 'foo-bar': { 'fizz-buzz': true } }) // { fooBar: { 'fizz-buz': true } }
 */
declare function camelKeys<T>(obj: T): CamelKeys<T>;

/**
 * Shallowly transforms the keys of a Record to CONSTANT_CASE.
 * T: the type of the Record to transform.
 */
type ConstantKeys<T> = T extends [] ? T : {
    [K in keyof T as ConstantCase<Extract<K, string>>]: T[K];
};
/**
 * A strongly typed function that shallowly transforms the keys of an object to CONSTANT_CASE. The transformation is done both at runtime and type level.
 * @param obj the object to transform.
 * @returns the transformed object.
 * @example constantKeys({ 'foo-bar': { 'fizz-buzz': true } }) // { FOO_BAR: { 'fizz-buzz': true } }
 */
declare function constantKeys<T>(obj: T): ConstantKeys<T>;

/**
 * Shallowly transforms the keys of a Record to a custom delimiter case.
 * T: the type of the Record to transform.
 * D: the delimiter to use.
 */
type DelimiterKeys<T, D extends string> = T extends [] ? T : {
    [K in keyof T as DelimiterCase<Extract<K, string>, D>]: T[K];
};
/**
 * A strongly typed function that shallowly transforms the keys of an object to a custom delimiter case. The transformation is done both at runtime and type level.
 * @param obj the object to transform.
 * @param delimiter the delimiter to use.
 * @returns the transformed object.
 * @example delimiterKeys({ 'foo-bar': { 'fizz-buzz': true } }, '.') // { 'foo.bar': { 'fizz.buzz': true } }
 */
declare function delimiterKeys<T, D extends string>(obj: T, delimiter: D): DelimiterKeys<T, D>;

/**
 * Shallowly transforms the keys of a Record to kebab-case.
 * T: the type of the Record to transform.
 */
type KebabKeys<T> = T extends [] ? T : {
    [K in keyof T as KebabCase<Extract<K, string>>]: T[K];
};
/**
 * A strongly typed function that shallowly transforms the keys of an object to kebab-case. The transformation is done both at runtime and type level.
 * @param obj the object to transform.
 * @returns the transformed object.
 * @example kebabKeys({ fooBar: { fizzBuzz: true } }) // { 'foo-bar': { fizzBuzz: true } }
 */
declare function kebabKeys<T>(obj: T): KebabKeys<T>;

/**
 * Shallowly transforms the keys of a Record to PascalCase.
 * T: the type of the Record to transform.
 */
type PascalKeys<T> = T extends [] ? T : {
    [K in keyof T as PascalCase<Extract<K, string>>]: T[K];
};
/**
 * A strongly typed function that shallowly transforms the keys of an object to pascal case. The transformation is done both at runtime and type level.
 * @param obj the object to transform.
 * @returns the transformed object.
 * @example pascalKeys({ 'foo-bar': { 'fizz-buzz': true } }) // { FooBar: { 'fizz-buzz': true } }
 */
declare function pascalKeys<T>(obj: T): PascalKeys<T>;

/**
 * Shallowly transforms the keys of a Record to snake_case.
 * T: the type of the Record to transform.
 */
type SnakeKeys<T> = T extends [] ? T : {
    [K in keyof T as SnakeCase<Extract<K, string>>]: T[K];
};
/**
 * A strongly typed function that shallowly the keys of an object to snake_case. The transformation is done both at runtime and type level.
 * @param obj the object to transform.
 * @returns the transformed object.
 * @example snakeKeys({ 'foo-bar': { 'fizz-buzz': true } }) // { 'foo_bar': { 'fizz-buzz': true } }
 */
declare function snakeKeys<T>(obj: T): SnakeKeys<T>;

/**
 * Shallowly transforms the keys of a Record with `replace`.
 * T: the type of the Record to transform.
 */
type ReplaceKeys<T, lookup extends string | RegExp, replacement extends string = ''> = T extends [] ? T : {
    [K in keyof T as Replace<Extract<K, string>, lookup, replacement>]: T[K];
};
/**
 * A strongly typed function that shallowly transforms the keys of an object by running the `replace` method in every key. The transformation is done both at runtime and type level.
 * @param obj the object to transform.
 * @param lookup the lookup string to be replaced.
 * @param replacement the replacement string.
 * @returns the transformed object.
 * @example replaceKeys({ 'foo-bar': { 'fizz-buzz': true } }, 'f', 'b') // { booBar: { 'fizz-buz': true } }
 */
declare function replaceKeys<T, S extends string | RegExp, R extends string = ''>(obj: T, lookup: S, replacement?: R): ReplaceKeys<T, S, R>;

/**
 * Recursively transforms the keys of a Record to camelCase.
 * T: the type of the Record to transform.
 */
type DeepCamelKeys<T> = T extends [any, ...any] ? {
    [I in keyof T]: DeepCamelKeys<T[I]>;
} : T extends (infer V)[] ? DeepCamelKeys<V>[] : {
    [K in keyof T as CamelCase<Extract<K, string>>]: DeepCamelKeys<T[K]>;
};
/**
 * A strongly typed function that recursively transforms the keys of an object to camelCase. The transformation is done both at runtime and type level.
 * @param obj the object to transform.
 * @returns the transformed object.
 * @example deepCamelKeys({ 'foo-bar': { 'fizz-buzz': true } }) // { fooBar: { fizzBuzz: true } }
 */
declare function deepCamelKeys<T>(obj: T): DeepCamelKeys<T>;

/**
 * Recursively transforms the keys of a Record to CONSTANT_CASE.
 * T: the type of the Record to transform.
 */
type DeepConstantKeys<T> = T extends [any, ...any] ? {
    [I in keyof T]: DeepConstantKeys<T[I]>;
} : T extends (infer V)[] ? DeepConstantKeys<V>[] : {
    [K in keyof T as ConstantCase<Extract<K, string>>]: DeepConstantKeys<T[K]>;
};
/**
 * A strongly typed function that recursively transforms the keys of an object to CONSTANT_CASE. The transformation is done both at runtime and type level.
 * @param obj the object to transform.
 * @returns the transformed object.
 * @example deepConstantKeys({ 'foo-bar': { 'fizz-buzz': true } }) // { FOO_BAR: { FIZZ_BUZZ: true } }
 */
declare function deepConstantKeys<T>(obj: T): DeepConstantKeys<T>;

/**
 * Recursively transforms the keys of a Record to a custom delimiter case.
 * T: the type of the Record to transform.
 * D: the delimiter to use.
 */
type DeepDelimiterKeys<T, D extends string> = T extends [any, ...any] ? {
    [I in keyof T]: DeepDelimiterKeys<T[I], D>;
} : T extends (infer V)[] ? DeepDelimiterKeys<V, D>[] : {
    [K in keyof T as DelimiterCase<Extract<K, string>, D>]: DeepDelimiterKeys<T[K], D>;
};
/**
 * A strongly typed function that recursively transforms the keys of an object to a custom delimiter case. The transformation is done both at runtime and type level.
 * @param obj the object to transform.
 * @param delimiter the delimiter to use.
 * @returns the transformed object.
 * @example deepDelimiterKeys({ 'foo-bar': { 'fizz-buzz': true } }, '.') // { 'foo.bar': { 'fizz.buzz': true } }
 */
declare function deepDelimiterKeys<T, D extends string>(obj: T, delimiter: D): DeepDelimiterKeys<T, D>;

/**
 * Recursively transforms the keys of a Record to kebab-case.
 * T: the type of the Record to transform.
 */
type DeepKebabKeys<T> = T extends [any, ...any] ? {
    [I in keyof T]: DeepKebabKeys<T[I]>;
} : T extends (infer V)[] ? DeepKebabKeys<V>[] : {
    [K in keyof T as KebabCase<Extract<K, string>>]: DeepKebabKeys<T[K]>;
};
/**
 * A strongly typed function that recursively transforms the keys of an object to kebab-case. The transformation is done both at runtime and type level.
 * @param obj the object to transform.
 * @returns the transformed object.
 * @example deepKebabKeys({ 'foo-bar': { 'fizz-buzz': true } }) // { 'foo-bar': { 'fizz-buzz': true } }
 */
declare function deepKebabKeys<T>(obj: T): DeepKebabKeys<T>;

/**
 * Recursively transforms the keys of a Record to PascalCase.
 * T: the type of the Record to transform.
 */
type DeepPascalKeys<T> = T extends [any, ...any] ? {
    [I in keyof T]: DeepPascalKeys<T[I]>;
} : T extends (infer V)[] ? DeepPascalKeys<V>[] : {
    [K in keyof T as PascalCase<Extract<K, string>>]: DeepPascalKeys<T[K]>;
};
/**
 * A strongly typed function that recursively transforms the keys of an object to pascal case. The transformation is done both at runtime and type level.
 * @param obj the object to transform.
 * @returns the transformed object.
 * @example deepPascalKeys({ 'foo-bar': { 'fizz-buzz': true } }) // { FooBar: { FizzBuzz: true } }
 */
declare function deepPascalKeys<T>(obj: T): DeepPascalKeys<T>;

/**
 * Recursively transforms the keys of a Record to snake_case.
 * T: the type of the Record to transform.
 */
type DeepSnakeKeys<T> = T extends [any, ...any] ? {
    [I in keyof T]: DeepSnakeKeys<T[I]>;
} : T extends (infer V)[] ? DeepSnakeKeys<V>[] : {
    [K in keyof T as SnakeCase<Extract<K, string>>]: DeepSnakeKeys<T[K]>;
};
/**
 * A strongly typed function that recursively transforms the keys of an object to snake_case. The transformation is done both at runtime and type level.
 * @param obj the object to transform.
 * @returns the transformed object.
 * @example deepSnakeKeys({ 'foo-bar': { 'fizz-buzz': true } }) // { 'foo_bar': { 'fizz_buzz': true } }
 */
declare function deepSnakeKeys<T>(obj: T): DeepSnakeKeys<T>;

/**
 * This function is used to transform the keys of an object deeply.
 * It will only be transformed at runtime, so it's not type safe.
 * @param obj the object to transform.
 * @param transform the function to transform the keys from string to string.
 * @returns the transformed object.
 * @example deepTransformKeys({ 'foo-bar': { 'fizz-buzz': true } }, camelCase)
 * // { fooBar: { fizzBuzz: true } }
 */
declare function deepTransformKeys<T>(obj: T, transform: (s: string) => string): T;

export { type CamelCase, type CamelKeys, type CharAt, type Concat, type ConstantCase, type ConstantKeys, type DeepCamelKeys, type DeepConstantKeys, type DeepDelimiterKeys, type DeepKebabKeys, type DeepPascalKeys, type DeepSnakeKeys, type DelimiterCase, type DelimiterKeys, type EndsWith, type Includes, type IsDigit, type IsLetter, type IsLower, type IsSeparator, type IsSpecial, type IsUpper, type Join, type KebabCase, type KebabKeys, type Length, type PadEnd, type PadStart, type PascalCase, type PascalKeys, type Repeat, type Replace, type ReplaceAll, type ReplaceKeys, type Reverse, type Slice, type SnakeCase, type SnakeKeys, type Split, type StartsWith, type TitleCase, type Trim, type TrimEnd, type TrimStart, type Truncate, type Words, camelCase, camelKeys, capitalize, charAt, concat, constantCase, constantKeys, deepCamelKeys, deepConstantKeys, deepDelimiterKeys, deepKebabKeys, deepPascalKeys, deepSnakeKeys, deepTransformKeys, delimiterCase, delimiterKeys, endsWith, includes, join, kebabCase, kebabKeys, length, lowerCase, padEnd, padStart, pascalCase, pascalKeys, repeat, replace, replaceAll, replaceKeys, reverse, slice, snakeCase, snakeKeys, split, startsWith, titleCase, toCamelCase, toConstantCase, toDelimiterCase, toKebabCase, toLowerCase, toPascalCase, toSnakeCase, toTitleCase, toUpperCase, trim, trimEnd, trimStart, truncate, uncapitalize, upperCase, words };
