"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("refa"),t=require("regexp-ast-analysis"),r=require("@eslint-community/regexpp");function n(e,t){const r=new Error(t);throw r.data=e,r}function a(t,r){if(void 0!==r&&!e.JS.isFlags(r))throw new Error("Invalid flags");return e.JS.toLiteral({type:"CharacterClass",characters:t},{flags:r})}function s(e){switch(e.type){case"Character":case"CharacterClass":case"CharacterSet":case"ExpressionCharacterClass":return!0;default:return!1}}function i(e){return"Quantifier"===e.type&&s(e.element)}function c(e,r){if(Array.isArray(e)){if(0===e.length)return{consume:t.Chars.empty(r),assert:t.Chars.all(r)};if(1===e.length)return e[0]}let n=t.Chars.empty(r),a=t.Chars.all(r);for(const t of e)if(n=n.intersect(t.consume.union(t.assert)).union(t.consume.intersect(a)),a=a.intersect(t.assert),a.isEmpty&&n.isEmpty)break;return{consume:n,assert:a}}function o(e,r){return u(e,t.Chars.empty(r))}function u(e,t){if(Array.isArray(e)&&1===e.length)return e[0];let r=t,n=t;for(const t of e)r=r.union(t.consume),n=n.union(t.assert);return{consume:r,assert:n}}function l(t){return{consume:e.CharSet.empty(t.consume.maximum),assert:t.consume.union(t.assert)}}function m(r,a){if(Array.isArray(r))return o(r.map((e=>m(e,a))),a);switch(r.type){case"Alternative":return c(function*(){for(const e of r.elements)yield m(e,a)}(),a);case"Assertion":switch(r.kind){case"end":case"start":return a.multiline?{consume:t.Chars.empty(a),assert:t.Chars.lineTerminator(a)}:{consume:t.Chars.empty(a),assert:t.Chars.empty(a)};case"word":{const e=t.Chars.word(a),n=e.negate();for(const s of["ltr","rtl"]){const i=t.getFirstCharAfter(r,s,a);if(!i.edge){if(i.char.isSubsetOf(e))return{consume:t.Chars.empty(a),assert:r.negate?e:n};if(i.char.isSubsetOf(n))return{consume:t.Chars.empty(a),assert:r.negate?n:e}}}return r.negate?{consume:t.Chars.empty(a),assert:t.Chars.all(a)}:{consume:t.Chars.empty(a),assert:t.Chars.empty(a)}}case"lookahead":case"lookbehind":{const e=l(m(r.alternatives,a));return r.negate?{consume:t.Chars.empty(a),assert:e.assert.negate()}:e}}return n(r);case"CapturingGroup":case"Group":case"Pattern":return m(r.alternatives,a);case"Character":case"CharacterClass":case"CharacterSet":case"ExpressionCharacterClass":case"ClassIntersection":case"ClassSubtraction":case"ClassStringDisjunction":case"StringAlternative":return function(t){const r=e.CharSet.empty(t.chars.maximum),n=e.CharSet.all(t.chars.maximum),a={consume:t.chars,assert:r};return t.isEmpty||t.accept.isEmpty?a:u([a,...t.accept.wordSets.map((e=>{if(0===e.length)return{consume:r,assert:n};let t=e[0];for(let r=1;r<e.length;r++)t=t.intersect(e[r]);return{consume:t,assert:r}}))],e.CharSet.empty(t.chars.maximum))}(t.toUnicodeSet(r,a));case"Quantifier":return 0===r.max?{consume:t.Chars.empty(a),assert:t.Chars.all(a)}:0===r.min?{consume:m(r.element,a).consume,assert:t.Chars.all(a)}:m(r.element,a);case"RegExpLiteral":return m(r.pattern,a);case"Backreference":if(t.isEmptyBackreference(r,a))return{consume:t.Chars.empty(a),assert:t.Chars.all(a)};{const e=m(r.resolved,a);return t.isStrictBackreference(r)?e:{consume:e.consume,assert:t.Chars.all(a)}}case"CharacterClassRange":case"Flags":throw new Error("This doesn't make any sense");default:n(r)}}function f(e,r,a,s,i){return 1===t.followPaths(e,"enter",0,{fork:e=>e,join:e=>e.every((e=>2===e))?2:e.some((e=>1===e))?1:0,assert:(e,t,r)=>1===r?r:e,continueAfter:(t,r)=>t!==e&&0===r,continueInto:(e,t)=>0===t,enter:(e,t)=>e===r?1:t,leave(e,t){if(0!==t)return t;switch(e.type){case"Assertion":case"Backreference":case"Character":case"CharacterClass":case"CharacterSet":case"ExpressionCharacterClass":{const t=m(e,i),r=t.consume.union(t.assert);return a.isSubsetOf(r)?0:2}case"CapturingGroup":case"Group":case"Quantifier":return t;default:n(e)}}},s)}function p(e){let r=t.getEffectiveMaximumRepetition(e);return"Quantifier"===e.type&&(r*=e.max),r>20}function h(e){let t;if(0===e.min&&1===e.max)t="?";else if(0===e.min&&e.max===1/0)t="*";else if(1===e.min&&e.max===1/0)t="+";else{if(e.min===e.max)return 1===e.min?"":`{${e.min}}`;t=e.max===1/0?`{${e.min},}`:`{${e.min},${e.max}}`}return e.greedy||(t+="?"),t}function g(e,r,n){return e.element.raw===r.element.raw||!(!i(e)||!i(r))&&t.toUnicodeSet(e.element,n).equals(t.toUnicodeSet(r.element,n))}function y(e,t){return"ltr"===e?t.join(""):[...t].reverse().join("")}function d(e,t){return 0===t?"":1===t?e.raw:e.raw+`{${t}}`}function C(e){return t.hasSomeDescendant(e,(e=>"CapturingGroup"===e.type))}class w{constructor(e){this.source=e.pattern.raw,this.flags=e.flags.raw,this.patternOffset=e.pattern.start}replace(e,t){let r,n;if(Array.isArray(e)){r=1/0,n=-1/0;for(const t of e)r=Math.min(r,t.start),n=Math.max(n,t.end)}else r=e.start,n=e.end;const a=this.patternOffset;return{source:this.source.slice(0,r-a)+t+this.source.slice(n-a),flags:this.flags}}}function x(r,n){const{startQuant:a,endQuant:c}=n;if(C(a)||C(c))return;const o=new w(r);if(a.parent===c.parent){const n=t.getMatchingDirection(a);if(n===(a.start<c.start?"ltr":"rtl")){const u=a.parent.elements,l=u.indexOf(a),m=u.indexOf(c),f=u.slice(Math.min(l,m)+1,Math.max(l,m));if(0===f.length)return function(e,t,r,n,a){if(g(n,a,e.flags))return t.replace([n,a],n.element.raw+h({min:n.min+a.min,max:1/0,greedy:n.greedy||a.greedy}));if(i(n)&&i(a)){const s=v(e.flags,r,n,a);if(s)return t.replace(s.which,s.replacement)}}(r,o,n,a,c);if(1===f.length){const u=f[0];if("Quantifier"===u.type)return function(e,r,n,a,s,c){if(0===c.max||0!==c.min||t.isPotentiallyZeroLength(a.element,e.flags)||t.isPotentiallyZeroLength(s.element,e.flags)||t.isPotentiallyZeroLength(c.element,e.flags))return;const o=t.getFirstConsumedChar(a.element,n,e.flags),u=t.getFirstConsumedChar(s.element,n,e.flags),l=t.getFirstConsumedChar(c.element,n,e.flags);function m(e){return 3===a.parent.elements.length?e.join("|"):"(?:"+e.join("|")+")"}function f(){return c.element.raw+h(Object.assign(Object.assign({},c),{min:1}))}const p=c.greedy?"":"?";if(o.char.isDisjointWith(l.char)&&u.char.isDisjointWith(l.char)){if(g(a,s,e.flags)){if(0===s.min)return r.replace([c,s],"(?:"+y(n,[f(),s.raw])+")?"+p);if(0===a.min){if(C(c))return r.replace([a,c],"(?:"+y(n,[a.raw,f()])+")?"+p);{const e=y(n,[f(),s.raw]),t=[y(n,[a.element.raw+h(Object.assign(Object.assign({},a),{min:1})),"(?:"+e+")?"+p]),e];return c.greedy||t.reverse(),r.replace([a,c,s],m(t))}}}if(i(a)&&i(s)){const t=v(e.flags,n,a,s);if(t){const{which:e,replacement:i}=t;if(""===i)return e===a?r.replace([a,c],"(?:"+y(n,[a.raw,f()])+")?"+p):r.replace([c,s],"(?:"+y(n,[f(),s.raw])+")?"+p);{const t=[y(n,[a.raw,f(),s.raw]),y(n,[a===e?i:a.raw,s===e?i:s.raw])];return c.greedy||t.reverse(),r.replace([a,c,s],m(t))}}}}}(r,o,n,a,c,u);if(s(u))return function(r,n,a,s,c,o){if(s.element.raw===c.element.raw&&s.element.raw===o.raw)return n.replace([s,o,c],s.element.raw+h({min:s.min+c.min+1,max:1/0,greedy:s.greedy||c.greedy}));if(i(s)&&i(c)&&s.greedy&&c.greedy){const i=t.toUnicodeSet(s.element,r.flags),u=t.toUnicodeSet(c.element,r.flags),l=t.toUnicodeSet(o,r.flags);if(!i.accept.isEmpty||!u.accept.isEmpty||!l.accept.isEmpty)return;const m=i.chars,f=u.chars,p=l.chars,h={type:"Concatenation",elements:[{type:"Quantifier",min:s.min,max:1/0,lazy:!1,alternatives:[{type:"Concatenation",elements:[{type:"CharacterClass",characters:m}]}]},{type:"CharacterClass",characters:p},{type:"Quantifier",min:c.min,max:1/0,lazy:!1,alternatives:[{type:"Concatenation",elements:[{type:"CharacterClass",characters:f}]}]}]};if("rtl"===a&&h.elements.reverse(),!e.JS.isFlags(r.flags))throw new Error("Invalid flags");const g=e.DFA.fromFA(e.NFA.fromRegex(h,{maxCharacter:m.maximum}));g.minimize();const y=g.toRegex(),d=e.JS.toLiteral(y,{flags:r.flags}).source,C=y.alternatives.length>1?"(?:"+d+")":d;return n.replace([s,o,c],C)}}(r,o,n,a,c,u)}}}}function v(e,r,n,s){const i=t.toUnicodeSet(n.element,e),c=t.toUnicodeSet(s.element,e);if(!i.accept.isEmpty||!c.accept.isEmpty)return;const o=i.chars,u=c.chars;let l;if(l=o.isSubsetOf(u)?n:u.isSubsetOf(o)?s:void 0,l)return{which:l,replacement:d(l.element,l.min)};const m=a(u.without(o),e).source,f=s.element.raw+h({min:Math.max(0,s.min-1),max:1/0,greedy:s.greedy});let p;if(0===s.min){const e=s.greedy?"":"?";p=`(?:${y(r,[m,f])})?${e}`}else{const t=a(u.intersect(o),e).source,n=d(s.element,s.min-1);p=`(?:${y(r,[m,f])}|${y(r,[t,n])})`}return{which:s,replacement:p}}const S=()=>{};function E(t){return{set:t,pick:String.fromCodePoint(e.Words.pickMostReadableCharacter(t)),literal:a(t)}}function A(e,r){return t.hasSomeAncestor(r,(t=>t===e))}const b=new r.RegExpParser;exports.analyse=function(e,a){const{pattern:s,flags:i}=function(e){if("source"in e){const t=b.parseFlags(e.flags);return{pattern:b.parsePattern(e.source,void 0,void 0,t),flags:t}}return e}(e),{maxReports:u,reportTypes:g,assumeRejectingSuffix:y}=function(e){var t,r,n;return{maxReports:null!==(t=null==e?void 0:e.maxReports)&&void 0!==t?t:1/0,reportTypes:null!==(r=null==e?void 0:e.reportTypes)&&void 0!==r?r:{},assumeRejectingSuffix:null!==(n=null==e?void 0:e.assumeRejectingSuffix)&&void 0!==n&&n}}(a),d={parsed:{pattern:s,flags:i},literal:{source:s.raw,flags:i.raw},reports:[]};if(u<=0)return d;function C(e){d.reports.length<u&&!1!==g[e.type]&&(!function(e,t){switch(t.type){case"Move":break;case"Self":t.fix=()=>{const r=function(e,t){const{quant:r,parentQuant:n}=t;if(r.greedy!==n.greedy)return;const a=new w(e);if(1===r.parent.elements.length&&"Group"===r.parent.parent.type&&r.parent.parent.parent===n){if(1===r.parent.parent.alternatives.length){const e=r.min,t=r.max,s=n.min,i=n.max;if(t===1/0&&0===s?e<=1:s===i||t*s+1>=e*(s+1)){const c={min:e*s,max:t*i,greedy:r.greedy};return a.replace(n,r.element.raw+h(c))}}if(n.max===1/0){if(1===r.min||0===r.min&&0===n.min)return a.replace(r,r.element.raw);if(0===r.min)return a.replace(r,r.element.raw+h({min:0,max:1,greedy:r.greedy}))}}}(e,t);return r||void 0};break;case"Trade":t.fix=()=>{const r=x(e,t);return r||void 0};break;default:n(t)}}(d.parsed,e),d.reports.push(e))}const v=function(e){const t=new Map;return function(r){let n=t.get(r);return void 0===n&&(n=e(r),t.set(r,n)),n}}((e=>m(e,i))),j={fork:e=>e,join:e=>o(e,i),continueAfter:(e,t)=>!(t.assert.isEmpty&&t.consume.isEmpty)&&d.reports.length<u,continueInto:(e,t)=>!(t.assert.isEmpty&&t.consume.isEmpty)&&d.reports.length<u,leave(e,t){switch(e.type){case"Assertion":case"Backreference":case"Character":case"CharacterClass":case"CharacterSet":case"ExpressionCharacterClass":return c([t,v(e)],i);case"CapturingGroup":case"Group":case"Quantifier":return t;default:n(e)}}},Q=new Map,O=new Map;function k(e,t,r){let n=e.get(t);return void 0===n&&(n=new Set,e.set(t,n)),!!n.has(r)||(n.add(r),!1)}function M(e,r){const n=v(r).consume.intersect(e.consume.union(e.assert));if(n.isEmpty)return n;if(y)return n;{const e=l((a=r,t.followPaths(a,"next",{consume:t.Chars.empty(i),assert:t.Chars.all(i)},j))).assert;return n.without(e)}var a}function R(e,r,n){if(r.max!==1/0)return;const a=M(n,r);if(a.isEmpty)return;let s,c,o;e===r?(s=e,c=function(e){let t=e.parent;for(;t;){if("Quantifier"===t.type)return t;t=t.parent}throw new Error("Cannot get parent quant of `"+e.raw+"`")}(e)):A(r,e)?(s=e,c=r):A(e,r)&&(s=r,c=e),s&&c&&(o=function(e,t){let r,n=t.parent;for(;n;){if(n===e)return r;"Assertion"===n.type&&(r=n),n=n.parent}throw new Error("The given nodes are not parent and child.")}(c,s))?k(O,e,o)||C({type:"Trade",startQuant:e,endQuant:r,character:E(a),fix:S,exponential:!1}):s&&c&&f(c,s,a,"ltr",i)&&f(c,s,a,"rtl",i)?k(Q,s,c)||C({type:"Self",quant:s,parentQuant:c,character:E(a),fix:S,exponential:p(c)}):k(O,e,r)||C({type:"Trade",startQuant:e,endQuant:r,character:E(a),fix:S,exponential:p(t.getClosestAncestor(e,r))})}if(r.visitRegExpAST(s,{onQuantifierLeave(e){if(e.max!==1/0)return;if(d.reports.length>=u)return;const r=v(e.element);r.consume.isEmpty||(t.followPaths(e,"next",r,Object.assign(Object.assign({},j),{enter:(t,r)=>("Quantifier"===t.type&&R(e,t,r),r)})),t.followPaths(e,"enter",r,Object.assign(Object.assign({},j),{enter:(t,r)=>(t!==e&&"Quantifier"===t.type&&R(e,t,r),r),continueAfter:(t,r,n)=>j.continueAfter(t,r,n)&&t!==e})))}}),!i.sticky&&d.reports.length<u&&!1!==g.Move){function P(e,t){if(e.max!==1/0)return;const r=M(t,e);r.isEmpty||C({type:"Move",quant:e,character:E(r),fix:S,exponential:!1})}const F={consume:t.Chars.all(i),assert:t.Chars.empty(i)};for(const T of s.alternatives)0!==T.elements.length&&t.followPaths(T.elements[0],"enter",F,Object.assign(Object.assign({},j),{enter:(e,t)=>("Quantifier"===e.type&&P(e,t),t)}))}return d};
