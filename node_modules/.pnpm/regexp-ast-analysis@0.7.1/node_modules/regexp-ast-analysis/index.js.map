{"version":3,"file":"index.js","sources":[".out/chars.js",".out/util.js",".out/cache.js",".out/to-char-set.js",".out/basic.js",".out/equal.js",".out/follow.js",".out/next-char.js",".out/longest-prefix.js",".out/determinism.js",".out/consumed-chars.js",".out/reorder.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-namespace */\nimport { CharSet, JS } from \"refa\";\nfunction isUnicode(flags) {\n    return flags.unicode || !!flags.unicodeSets;\n}\n/**\n * A set of functions to get predefined character sets.\n */\nexport var Chars;\n(function (Chars) {\n    /**\n     * Returns the maximum character for the given flags.\n     */\n    function maxChar(flags) {\n        if (isUnicode(flags)) {\n            return 1114111 /* MaxChar.UNICODE */;\n        }\n        else {\n            return 65535 /* MaxChar.UTF16 */;\n        }\n    }\n    Chars.maxChar = maxChar;\n    const EMPTY_UTF16_CHARSET = CharSet.empty(65535 /* MaxChar.UTF16 */);\n    const EMPTY_UNICODE_CHARSET = CharSet.empty(1114111 /* MaxChar.UNICODE */);\n    /**\n     * Returns the empty character set for the given flags.\n     */\n    function empty(flags) {\n        if (isUnicode(flags)) {\n            return EMPTY_UNICODE_CHARSET;\n        }\n        else {\n            return EMPTY_UTF16_CHARSET;\n        }\n    }\n    Chars.empty = empty;\n    const ALL_UTF16_CHARSET = CharSet.all(65535 /* MaxChar.UTF16 */);\n    const ALL_UNICODE_CHARSET = CharSet.all(1114111 /* MaxChar.UNICODE */);\n    /**\n     * Returns the full character set for the given flags.\n     */\n    function all(flags) {\n        if (isUnicode(flags)) {\n            return ALL_UNICODE_CHARSET;\n        }\n        else {\n            return ALL_UTF16_CHARSET;\n        }\n    }\n    Chars.all = all;\n    const LINE_TERMINATOR_UTF16_CHARSET = JS.createCharSet([{ kind: \"any\" }], { unicode: false }).negate();\n    const LINE_TERMINATOR_UNICODE_CHARSET = JS.createCharSet([{ kind: \"any\" }], { unicode: true }).negate();\n    /**\n     * Returns the character set that contains only line terminators.\n     *\n     * This character set accepts all characters that the JS RegExp `.` rejects. The returned character set accepts\n     * all character that the regex `/^.$/` rejects.\n     */\n    function lineTerminator(flags) {\n        if (isUnicode(flags)) {\n            return LINE_TERMINATOR_UNICODE_CHARSET;\n        }\n        else {\n            return LINE_TERMINATOR_UTF16_CHARSET;\n        }\n    }\n    Chars.lineTerminator = lineTerminator;\n    const WORD_UTF16_CHARSET = JS.createCharSet([{ kind: \"word\", negate: false }], { unicode: false });\n    const WORD_UNICODE_CHARSET = JS.createCharSet([{ kind: \"word\", negate: false }], {\n        unicode: true,\n        ignoreCase: false,\n    });\n    const WORD_UNICODE_IGNORE_CASE_CHARSET = JS.createCharSet([{ kind: \"word\", negate: false }], {\n        unicode: true,\n        ignoreCase: true,\n    });\n    /**\n     * Returns a character set that is equivalent to `\\w` with the given flags.\n     *\n     * Note: `\\w` is somewhat special because it has 3 values. All predefined character sets only have two values - one\n     * for Unicode mode and one for non-Unicode mode. This is because Unicode-mode changes the semantics of ignore case\n     * as well. This causes some of the ASCII letters to be ignore-case-equal to higher Unicode characters\n     * (e.g. K (Latin Capital Letter K, U+004b) == k (Latin Small Letter K, U+006b) == â„ª (Kelvin Sign, U+212A)). As a\n     * result `\\w` has 3 values: one for non-Unicode mode, one for case-sensitive Unicode-mode, and one for\n     * case-insensitive Unicode-mode.\n     */\n    function word(flags) {\n        if (isUnicode(flags)) {\n            if (flags.ignoreCase) {\n                return WORD_UNICODE_IGNORE_CASE_CHARSET;\n            }\n            else {\n                return WORD_UNICODE_CHARSET;\n            }\n        }\n        else {\n            return WORD_UTF16_CHARSET;\n        }\n    }\n    Chars.word = word;\n    const DIGIT_UTF16_CHARSET = JS.createCharSet([{ kind: \"digit\", negate: false }], { unicode: false });\n    const DIGIT_UNICODE_CHARSET = JS.createCharSet([{ kind: \"digit\", negate: false }], { unicode: true });\n    /**\n     * Returns a character set that is equivalent to `\\d` with the given flags.\n     */\n    function digit(flags) {\n        if (isUnicode(flags)) {\n            return DIGIT_UNICODE_CHARSET;\n        }\n        else {\n            return DIGIT_UTF16_CHARSET;\n        }\n    }\n    Chars.digit = digit;\n    const SPACE_UTF16_CHARSET = JS.createCharSet([{ kind: \"space\", negate: false }], { unicode: false });\n    const SPACE_UNICODE_CHARSET = JS.createCharSet([{ kind: \"space\", negate: false }], { unicode: true });\n    /**\n     * Returns a character set that is equivalent to `\\s` with the given flags.\n     */\n    function space(flags) {\n        if (isUnicode(flags)) {\n            return SPACE_UNICODE_CHARSET;\n        }\n        else {\n            return SPACE_UTF16_CHARSET;\n        }\n    }\n    Chars.space = space;\n})(Chars || (Chars = {}));\n","import { CharSet } from \"refa\";\nimport { Chars } from \"./chars\";\nexport function assertNever(value, message) {\n    throw new Error(message || value);\n}\nexport function assertSameParent(alternatives) {\n    let parent = null;\n    for (const a of alternatives) {\n        if (parent === null) {\n            parent = a.parent;\n        }\n        else {\n            if (a.parent !== parent) {\n                throw new Error(\"Expected all alternatives to have the same parent\");\n            }\n        }\n    }\n}\nexport const isReadonlyArray = Array.isArray;\nexport function asReadonlySet(iter) {\n    if (iter instanceof Set) {\n        return iter;\n    }\n    return new Set(iter);\n}\nexport class CharUnion {\n    get char() {\n        return this._exactChars.union(this._inexactChars);\n    }\n    get exact() {\n        // basic idea here is that the union or an exact superset with an inexact subset will be exact\n        return this._exactChars.isSupersetOf(this._inexactChars);\n    }\n    constructor(empty) {\n        this._exactChars = empty;\n        this._inexactChars = empty;\n    }\n    add(char) {\n        if (char.exact) {\n            this._exactChars = this._exactChars.union(char.char);\n        }\n        else {\n            this._inexactChars = this._inexactChars.union(char.char);\n        }\n    }\n    static fromFlags(flags) {\n        return new CharUnion(Chars.empty(flags));\n    }\n    static fromMaximum(maximum) {\n        return new CharUnion(CharSet.empty(maximum));\n    }\n}\nexport function unionInexact(left, right) {\n    const char = left.char.union(right.char);\n    let exact;\n    if (left.exact) {\n        if (right.exact) {\n            exact = true;\n        }\n        else {\n            exact = left.char.isSupersetOf(right.char);\n        }\n    }\n    else {\n        if (right.exact) {\n            exact = right.char.isSupersetOf(left.char);\n        }\n        else {\n            exact = false;\n        }\n    }\n    return { char, exact };\n}\nexport function intersectInexact(left, right) {\n    const char = left.char.intersect(right.char);\n    const exact = (left.exact && right.exact) || char.isEmpty;\n    return { char, exact };\n}\nexport class SetEquivalence {\n    constructor(count) {\n        this.count = count;\n        this._indexes = [];\n        for (let i = 0; i < count; i++) {\n            this._indexes.push(i);\n        }\n    }\n    makeEqual(a, b) {\n        // This works using the following idea:\n        //  1. If the eq set of a and b is the same, then we can stop.\n        //  2. If indexes[a] < indexes[b], then we want to make\n        //     indexes[b] := indexes[a]. However, this means that we lose the\n        //     information about the indexes[b]! So we will store\n        //     oldB := indexes[b], then indexes[b] := indexes[a], and then\n        //     make oldB == a.\n        //  3. If indexes[a] > indexes[b], similar to 2.\n        let aValue = this._indexes[a];\n        let bValue = this._indexes[b];\n        while (aValue !== bValue) {\n            if (aValue < bValue) {\n                this._indexes[b] = aValue;\n                // eslint-disable-next-line no-param-reassign -- x\n                b = bValue;\n                bValue = this._indexes[b];\n            }\n            else {\n                this._indexes[a] = bValue;\n                // eslint-disable-next-line no-param-reassign -- x\n                a = aValue;\n                aValue = this._indexes[a];\n            }\n        }\n    }\n    /**\n     * This returns:\n     *\n     * 1. `eqSet.count`: How many different equivalence classes there are.\n     * 2. `eqSet.indexes`: A map (array) from each element (index) to the index\n     *    of its equivalence class.\n     *\n     * All equivalence class indexes `eqSet.indexes[i]` are guaranteed to\n     * be <= `eqSet.count`.\n     */\n    getEquivalenceSets() {\n        let counter = 0;\n        for (let i = 0; i < this.count; i++) {\n            if (i === this._indexes[i]) {\n                this._indexes[i] = counter++;\n            }\n            else {\n                this._indexes[i] = this._indexes[this._indexes[i]];\n            }\n        }\n        return {\n            count: counter,\n            indexes: this._indexes,\n        };\n    }\n}\n","/**\n * This will create a new cache instance for the given flags.\n *\n * This operation will always create a new cache. If you want to transparently reuse cache instances, use\n * {@link toCache} instead.\n *\n * See {@link Cache} from more information about using caches.\n *\n * @see {@link Cache}\n * @see {@link toCache}\n */\nexport function createCache(flags) {\n    return new CacheInstance(flags);\n}\n/**\n * Returns a cache instance for the given flags.\n *\n * If the given flags are a cache instance, the cache instance will be returned. Otherwise a new cache instance will\n * be created using {@link createCache}.\n *\n * See {@link Cache} from more information about using caches.\n *\n * @see {@link Cache}\n * @see {@link createCache}\n */\nexport function toCache(flags) {\n    return CacheInstance.from(flags);\n}\n/** @internal */\nexport class CacheInstance {\n    constructor(flags) {\n        this.toCharSet = new WeakMap();\n        this.toUnicodeSet = new WeakMap();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.getFirstConsumedCharLTR = new WeakMap();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.getFirstConsumedCharRTL = new WeakMap();\n        this.getLongestPrefix = new Map();\n        this.dotAll = !!flags.dotAll;\n        this.global = !!flags.global;\n        this.hasIndices = !!flags.hasIndices;\n        this.ignoreCase = !!flags.ignoreCase;\n        this.multiline = !!flags.multiline;\n        this.sticky = !!flags.sticky;\n        this.unicode = !!flags.unicode;\n        this.unicodeSets = !!flags.unicodeSets;\n    }\n    static from(flags) {\n        if (flags instanceof CacheInstance) {\n            return flags;\n        }\n        else {\n            return new CacheInstance(flags);\n        }\n    }\n}\n","import { JS } from \"refa\";\nimport { CacheInstance } from \"./cache\";\nimport { Chars } from \"./chars\";\nimport { assertNever, isReadonlyArray } from \"./util\";\n/**\n * Converts the given element or array of elements into a refa `CharSet`.\n *\n * If an array is given, all the character sets of all elements will be unioned. This means that for any two element `a`\n * and `b`, the results of `toCharSet([a, b])` and `toCharSet(a).union(toCharSet(b))` will be the same.\n *\n * This is guaranteed to be equivalent to `toUnicodeSet(char).chars`.\n */\nexport function toCharSet(elements, flags) {\n    if (!JS.isFlags(flags)) {\n        throw new Error(\"Invalid flags.\");\n    }\n    if (!isReadonlyArray(elements)) {\n        return toCharSetSimpleCached(elements, flags);\n    }\n    if (elements.length === 0) {\n        return Chars.empty(flags);\n    }\n    else if (elements.length === 1) {\n        return toCharSetSimpleCached(elements[0], flags);\n    }\n    else {\n        return Chars.empty(flags).union(...elements.map(e => toCharSetSimpleCached(e, flags)));\n    }\n}\nfunction toCharSetSimpleCached(element, flags) {\n    if (flags instanceof CacheInstance) {\n        let cached = flags.toCharSet.get(element);\n        if (cached === undefined) {\n            cached = JS.parseCharSet(element, flags);\n            flags.toCharSet.set(element, cached);\n        }\n        return cached;\n    }\n    else {\n        return JS.parseCharSet(element, flags);\n    }\n}\n/**\n * Converts the given element or array of elements into a refa `UnicodeSet`.\n *\n * If an array is given, all the character sets of all elements will be unioned. This means that for any two element `a`\n * and `b`, the results of `toUnicodeSet([a, b])` and `toUnicodeSet(a).union(toUnicodeSet(b))` will be the same.\n */\nexport function toUnicodeSet(elements, flags) {\n    if (!JS.isFlags(flags)) {\n        throw new Error(\"Invalid flags.\");\n    }\n    if (!isReadonlyArray(elements)) {\n        return toUnicodeSetSimpleCached(elements, flags);\n    }\n    if (elements.length === 0) {\n        return JS.UnicodeSet.empty(Chars.maxChar(flags));\n    }\n    else if (elements.length === 1) {\n        return toUnicodeSetSimpleCached(elements[0], flags);\n    }\n    else {\n        return JS.UnicodeSet.empty(Chars.maxChar(flags)).union(...elements.map(e => toUnicodeSetSimpleCached(e, flags)));\n    }\n}\nfunction toUnicodeSetSimpleCached(element, flags) {\n    if (flags instanceof CacheInstance) {\n        let cached = flags.toUnicodeSet.get(element);\n        if (cached === undefined) {\n            cached = JS.parseUnicodeSet(element, flags);\n            flags.toUnicodeSet.set(element, cached);\n        }\n        return cached;\n    }\n    else {\n        return JS.parseUnicodeSet(element, flags);\n    }\n}\n/**\n * Returns whether the given character class/set matches all characters.\n *\n * This is guaranteed to be equivalent to `toUnicodeSet(char).chars.isAll` but is implemented more efficiently.\n */\nexport function matchesAllCharacters(char, flags) {\n    switch (char.type) {\n        case \"Character\":\n        case \"ClassStringDisjunction\":\n        case \"StringAlternative\":\n            return false;\n        case \"CharacterClassRange\":\n            return char.min.value === 0 && char.max.value === Chars.maxChar(flags);\n        case \"CharacterSet\":\n            if (char.kind === \"property\") {\n                if (char.strings) {\n                    // are currently no properties of strings that match all characters\n                    return false;\n                }\n                return toCharSet(char, flags).isAll;\n            }\n            else if (char.kind === \"any\") {\n                return !!flags.dotAll;\n            }\n            else {\n                return false;\n            }\n        case \"CharacterClass\":\n            if (char.negate) {\n                return char.elements.every(e => matchesNoCharacters(e, flags));\n            }\n            else {\n                if (char.elements.length === 0) {\n                    return false;\n                }\n                else if (char.elements.length === 1) {\n                    return matchesAllCharacters(char.elements[0], flags);\n                }\n                else {\n                    return toUnicodeSet(char, flags).chars.isAll;\n                }\n            }\n        case \"ExpressionCharacterClass\":\n            return matchesAllCharacters(char.expression, flags);\n        case \"ClassIntersection\":\n            return matchesAllCharacters(char.left, flags) && matchesAllCharacters(char.right, flags);\n        case \"ClassSubtraction\":\n            return toUnicodeSet(char, flags).chars.isAll;\n        default:\n            return assertNever(char);\n    }\n}\n/**\n * Returns whether the given character class/set matches no characters.\n *\n * This is guaranteed to be equivalent to `toUnicodeSet(char).isEmpty` but is implemented more efficiently.\n */\nexport function matchesNoCharacters(char, flags) {\n    switch (char.type) {\n        case \"Character\":\n        case \"CharacterClassRange\":\n        case \"ClassStringDisjunction\":\n        case \"StringAlternative\":\n            // all are guaranteed to match at least one character\n            return false;\n        case \"CharacterSet\":\n            if (char.kind === \"property\") {\n                if (char.strings) {\n                    // are currently no properties of strings that match no characters\n                    return false;\n                }\n                return toCharSet(char, flags).isEmpty;\n            }\n            else {\n                return false;\n            }\n        case \"CharacterClass\":\n            if (char.negate) {\n                if (char.elements.length === 0) {\n                    return false;\n                }\n                else if (char.elements.length === 1) {\n                    return matchesAllCharacters(char.elements[0], flags);\n                }\n                else {\n                    return toUnicodeSet(char, flags).isEmpty;\n                }\n            }\n            else {\n                return char.elements.every(e => matchesNoCharacters(e, flags));\n            }\n        case \"ExpressionCharacterClass\":\n            return matchesNoCharacters(char.expression, flags);\n        case \"ClassIntersection\":\n        case \"ClassSubtraction\":\n            return toUnicodeSet(char, flags).isEmpty;\n        default:\n            return assertNever(char);\n    }\n}\n/**\n * Returns whether the given character elements contains strings.\n *\n * This is guaranteed to be equivalent to `!toUnicodeSet(char).accept.isEmpty` but is implemented more efficiently.\n */\nexport function hasStrings(char, flags) {\n    switch (char.type) {\n        case \"Character\":\n        case \"CharacterClassRange\":\n            return false;\n        case \"CharacterSet\":\n            return char.kind === \"property\" && char.strings;\n        case \"CharacterClass\":\n            if (char.negate || !char.unicodeSets) {\n                return false;\n            }\n            else {\n                return char.elements.some(e => hasStrings(e, flags));\n            }\n        case \"ExpressionCharacterClass\":\n            return hasStrings(char.expression, flags);\n        case \"ClassIntersection\":\n        case \"ClassSubtraction\":\n            return !toUnicodeSet(char, flags).accept.isEmpty;\n        case \"ClassStringDisjunction\":\n            return char.alternatives.some(a => hasStrings(a, flags));\n        case \"StringAlternative\":\n            return char.elements.length !== 1;\n        default:\n            return assertNever(char);\n    }\n}\n","import { visitRegExpAST } from \"@eslint-community/regexpp\";\nimport { assertNever, isReadonlyArray } from \"./util\";\nimport { toUnicodeSet } from \"./to-char-set\";\nfunction characterIsEmpty(element, flags) {\n    switch (element.type) {\n        case \"Character\":\n        case \"CharacterSet\":\n        case \"CharacterClassRange\":\n            return false;\n        case \"CharacterClass\":\n            return (element.unicodeSets &&\n                !element.negate &&\n                element.elements.length > 0 &&\n                element.elements.every(e => characterIsEmpty(e, flags)));\n        case \"ExpressionCharacterClass\":\n            return !element.negate && characterIsEmpty(element.expression, flags);\n        case \"ClassIntersection\":\n        case \"ClassSubtraction\": {\n            // we actually need to evaluate the operation to implement this correctly\n            const lengthRange = toUnicodeSet(element, flags).getLengthRange();\n            return lengthRange !== undefined && lengthRange.min === 0 && lengthRange.max === 0;\n        }\n        case \"ClassStringDisjunction\":\n            return element.alternatives.every(e => characterIsEmpty(e, flags));\n        case \"StringAlternative\":\n            return element.elements.length === 0;\n        default:\n            throw assertNever(element);\n    }\n}\nfunction characterIsPotentiallyEmpty(element) {\n    switch (element.type) {\n        case \"Character\":\n        case \"CharacterSet\":\n        case \"CharacterClassRange\":\n            return false;\n        case \"CharacterClass\":\n            return element.unicodeSets && !element.negate && element.elements.some(characterIsPotentiallyEmpty);\n        case \"ExpressionCharacterClass\":\n            return !element.negate && characterIsPotentiallyEmpty(element.expression);\n        case \"ClassIntersection\":\n            return characterIsPotentiallyEmpty(element.left) && characterIsPotentiallyEmpty(element.right);\n        case \"ClassSubtraction\":\n            return characterIsPotentiallyEmpty(element.left) && !characterIsPotentiallyEmpty(element.right);\n        case \"ClassStringDisjunction\":\n            return element.alternatives.some(characterIsPotentiallyEmpty);\n        case \"StringAlternative\":\n            return element.elements.length === 0;\n        default:\n            throw assertNever(element);\n    }\n}\nfunction isInvokeEvery(element, fn) {\n    if (isReadonlyArray(element)) {\n        return element.every(fn);\n    }\n    else {\n        return fn(element);\n    }\n}\nfunction isInvokeSome(element, fn) {\n    if (isReadonlyArray(element)) {\n        return element.some(fn);\n    }\n    else {\n        return fn(element);\n    }\n}\n/**\n * Returns whether all (but at least one of the) paths of the given element do not consume characters.\n *\n * If this function returns `true`, then {@link isPotentiallyZeroLength} is guaranteed to return `true`.\n *\n * ## Backreferences\n *\n * This function uses the same condition for backreferences as {@link isEmpty}.\n *\n * ## Relations\n *\n * - `isZeroLength(e) -> isPotentiallyZeroLength(e)`\n * - `isZeroLength(e) -> getLengthRange(e).max == 0`\n *\n * @see {@link isPotentiallyZeroLength}\n * @see {@link isEmpty}\n * @see {@link isPotentiallyEmpty}\n * @see {@link getLengthRange}\n */\nexport function isZeroLength(element, flags) {\n    return isInvokeEvery(element, e => isZeroLengthImpl(e, flags));\n}\nfunction isZeroLengthImpl(element, flags) {\n    switch (element.type) {\n        case \"Alternative\":\n            return element.elements.every(e => isZeroLengthImpl(e, flags));\n        case \"Assertion\":\n            return true;\n        case \"Character\":\n        case \"CharacterSet\":\n        case \"CharacterClassRange\":\n        case \"CharacterClass\":\n        case \"ExpressionCharacterClass\":\n        case \"ClassIntersection\":\n        case \"ClassSubtraction\":\n        case \"ClassStringDisjunction\":\n        case \"StringAlternative\":\n            return characterIsEmpty(element, flags);\n        case \"Quantifier\":\n            return element.max === 0 || isZeroLengthImpl(element.element, flags);\n        case \"Backreference\":\n            return isEmptyBackreference(element, flags);\n        case \"CapturingGroup\":\n        case \"Group\":\n            return element.alternatives.length > 0 && element.alternatives.every(e => isZeroLengthImpl(e, flags));\n        default:\n            throw assertNever(element);\n    }\n}\n/**\n * Returns whether at least one path of the given element does not consume characters.\n *\n * ## Backreferences\n *\n * This function uses the same condition for backreferences as {@link isPotentiallyEmpty}.\n *\n * ## Relations\n *\n * - `isPotentiallyZeroLength(e) -> getLengthRange(e).min == 0`\n *\n * @see {@link isZeroLength}\n * @see {@link isEmpty}\n * @see {@link isPotentiallyEmpty}\n * @see {@link getLengthRange}\n */\nexport function isPotentiallyZeroLength(element, flags) {\n    if (!isReadonlyArray(element)) {\n        switch (element.type) {\n            case \"Character\":\n            case \"CharacterSet\":\n            case \"CharacterClassRange\":\n            case \"CharacterClass\":\n            case \"ExpressionCharacterClass\":\n            case \"ClassIntersection\":\n            case \"ClassSubtraction\":\n            case \"ClassStringDisjunction\":\n            case \"StringAlternative\":\n                return characterIsPotentiallyEmpty(element);\n        }\n    }\n    return isInvokeSome(element, e => isPotentiallyZeroLengthImpl(e, e, flags));\n}\nfunction isPotentiallyZeroLengthImpl(e, root, flags) {\n    return impl(e);\n    function impl(element) {\n        switch (element.type) {\n            case \"Alternative\":\n                return element.elements.every(impl);\n            case \"Assertion\":\n                return true;\n            case \"Backreference\":\n                return backreferenceIsPotentiallyEmpty(element, root, flags);\n            case \"Character\":\n            case \"CharacterSet\":\n            case \"CharacterClass\":\n            case \"ExpressionCharacterClass\":\n                return characterIsPotentiallyEmpty(element);\n            case \"CapturingGroup\":\n            case \"Group\":\n                return element.alternatives.some(impl);\n            case \"Quantifier\":\n                return element.min === 0 || impl(element.element);\n            default:\n                throw assertNever(element);\n        }\n    }\n}\n/**\n * Returns whether all (but at least one of the) paths of the given element do neither consume characters nor assert\n * characters.\n *\n * If this function returns `true`, then {@link isZeroLength} and {@link isPotentiallyEmpty} are guaranteed to return\n * `true`.\n *\n * ## Backreferences\n *\n * A backreferences will only be considered potentially empty, iff it is empty by the definition of\n * {@link isEmptyBackreference}.\n *\n * ## Relations\n *\n * - `isEmpty(e) -> isZeroLength(e)`\n * - `isEmpty(e) -> isPotentiallyEmpty(e)`\n *\n * @see {@link isZeroLength}\n * @see {@link isPotentiallyZeroLength}\n * @see {@link isPotentiallyEmpty}\n * @see {@link getLengthRange}\n */\nexport function isEmpty(element, flags) {\n    return isInvokeEvery(element, e => isEmptyImpl(e, flags));\n}\nfunction isEmptyImpl(element, flags) {\n    switch (element.type) {\n        case \"Alternative\":\n            return element.elements.every(e => isEmptyImpl(e, flags));\n        case \"Assertion\":\n            return false;\n        case \"Backreference\":\n            return isEmptyBackreference(element, flags);\n        case \"Character\":\n        case \"CharacterSet\":\n        case \"CharacterClassRange\":\n        case \"CharacterClass\":\n        case \"ExpressionCharacterClass\":\n        case \"ClassIntersection\":\n        case \"ClassSubtraction\":\n        case \"ClassStringDisjunction\":\n        case \"StringAlternative\":\n            return characterIsEmpty(element, flags);\n        case \"CapturingGroup\":\n        case \"Group\":\n            return element.alternatives.length > 0 && element.alternatives.every(e => isEmptyImpl(e, flags));\n        case \"Quantifier\":\n            return element.max === 0 || isEmptyImpl(element.element, flags);\n        default:\n            throw assertNever(element);\n    }\n}\n/**\n * Returns whether at least one path of the given element does neither consume characters nor assert characters.\n *\n * ## Backreferences\n *\n * A backreferences will only be considered potentially empty, iff at least one of the following conditions is true:\n *\n * - The backreference is trivially always empty. (see {@link isEmptyBackreference})\n * - The referenced capturing group is a descendant of the given element and at least one of the following conditions is\n *   true:\n *   * The referenced capturing group is potentially zero-length.\n *   * The backreferences is not always after its referenced capturing group.\n *     (see {@link isStrictBackreference})\n *\n * ## Relations\n *\n * - `isPotentiallyEmpty(e) -> isPotentiallyZeroLength(e)`\n *\n * @see {@link isZeroLength}\n * @see {@link isPotentiallyZeroLength}\n * @see {@link isEmpty}\n * @see {@link getLengthRange}\n */\nexport function isPotentiallyEmpty(element, flags) {\n    if (!isReadonlyArray(element)) {\n        switch (element.type) {\n            case \"Character\":\n            case \"CharacterSet\":\n            case \"CharacterClassRange\":\n            case \"CharacterClass\":\n            case \"ExpressionCharacterClass\":\n            case \"ClassIntersection\":\n            case \"ClassSubtraction\":\n            case \"ClassStringDisjunction\":\n            case \"StringAlternative\":\n                return characterIsPotentiallyEmpty(element);\n        }\n    }\n    return isInvokeSome(element, e => isPotentiallyEmptyImpl(e, flags));\n}\nfunction isPotentiallyEmptyImpl(root, flags) {\n    return impl(root);\n    function impl(element) {\n        switch (element.type) {\n            case \"Alternative\":\n                return element.elements.every(impl);\n            case \"Assertion\":\n                return false;\n            case \"Backreference\":\n                return backreferenceIsPotentiallyEmpty(element, root, flags);\n            case \"Character\":\n            case \"CharacterSet\":\n            case \"CharacterClass\":\n            case \"ExpressionCharacterClass\":\n                return characterIsPotentiallyEmpty(element);\n            case \"CapturingGroup\":\n            case \"Group\":\n                return element.alternatives.some(impl);\n            case \"Quantifier\":\n                return element.min === 0 || impl(element.element);\n            default:\n                throw assertNever(element);\n        }\n    }\n}\nfunction backreferenceIsPotentiallyEmpty(back, root, flags) {\n    if (isEmptyBackreference(back, flags)) {\n        return true;\n    }\n    else if (hasSomeAncestor(back.resolved, a => a === root)) {\n        return !isStrictBackreference(back) || isPotentiallyZeroLengthImpl(back.resolved, root, flags);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Returns whether any of the ancestors of the given node fulfills the given condition.\n *\n * If the given condition is an AST node instead of a function, `hasSomeAncestor` will behave as if the condition\n * function was `d => d === conditionNode`.\n *\n * The ancestors will be iterated in the order from closest to farthest.\n * The condition function will not be called on the given node.\n */\nexport function hasSomeAncestor(node, condition) {\n    if (typeof condition === \"function\") {\n        return hasSomeAncestorFnImpl(node, condition);\n    }\n    else {\n        return hasSomeAncestorNodeImpl(node, condition);\n    }\n}\nfunction hasSomeAncestorNodeImpl(node, condition) {\n    let parent = node.parent;\n    while (parent) {\n        if (parent === condition) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\nfunction hasSomeAncestorFnImpl(node, condition) {\n    let parent = node.parent;\n    while (parent) {\n        if (condition(parent)) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns whether any of the descendants of the given node fulfill the given condition.\n *\n * The descendants will be iterated in a DFS top-to-bottom manner from left to right with the first node being the\n * given node.\n *\n * If the given condition is an AST node instead of a function, `hasSomeDescendant` will behave as if the condition\n * function was `d => d === conditionNode`.\n *\n * This function is short-circuited, so as soon as any `condition` returns `true`, `true` will be returned.\n *\n * @param node\n * @param condition\n * @param descentConditionFn An optional function to decide whether the descendant of the given node will be checked as\n * well.\n *\n * This function will be called with some node only after `condition` has returned `false` for this node.\n */\nexport function hasSomeDescendant(node, condition, descentConditionFn) {\n    if (typeof condition === \"function\") {\n        return hasSomeDescendantImpl(node, condition, descentConditionFn);\n    }\n    else {\n        if (descentConditionFn) {\n            return hasSomeDescendantImpl(node, d => d === condition, descentConditionFn);\n        }\n        else {\n            // instead of checking the O(n) descendant nodes of `node`, we can instead check the O(log n) ancestor\n            // nodes of `condition`\n            return node === condition || hasSomeAncestor(condition, node);\n        }\n    }\n}\nfunction hasSomeDescendantImpl(node, conditionFn, descentConditionFn) {\n    if (conditionFn(node)) {\n        return true;\n    }\n    if (descentConditionFn && !descentConditionFn(node)) {\n        return false;\n    }\n    switch (node.type) {\n        case \"Alternative\":\n        case \"CharacterClass\":\n        case \"StringAlternative\":\n            return node.elements.some(e => hasSomeDescendantImpl(e, conditionFn, descentConditionFn));\n        case \"Assertion\":\n            if (node.kind === \"lookahead\" || node.kind === \"lookbehind\") {\n                return node.alternatives.some(a => hasSomeDescendantImpl(a, conditionFn, descentConditionFn));\n            }\n            return false;\n        case \"CapturingGroup\":\n        case \"ClassStringDisjunction\":\n        case \"Group\":\n        case \"Pattern\":\n            return node.alternatives.some(a => hasSomeDescendantImpl(a, conditionFn, descentConditionFn));\n        case \"ClassIntersection\":\n        case \"ClassSubtraction\":\n            return (hasSomeDescendantImpl(node.left, conditionFn, descentConditionFn) ||\n                hasSomeDescendantImpl(node.right, conditionFn, descentConditionFn));\n        case \"ExpressionCharacterClass\":\n            return hasSomeDescendantImpl(node.expression, conditionFn, descentConditionFn);\n        case \"CharacterClassRange\":\n            return (hasSomeDescendantImpl(node.min, conditionFn, descentConditionFn) ||\n                hasSomeDescendantImpl(node.max, conditionFn, descentConditionFn));\n        case \"Quantifier\":\n            return hasSomeDescendantImpl(node.element, conditionFn, descentConditionFn);\n        case \"RegExpLiteral\":\n            return (hasSomeDescendantImpl(node.pattern, conditionFn, descentConditionFn) ||\n                hasSomeDescendantImpl(node.flags, conditionFn, descentConditionFn));\n        case \"Backreference\":\n        case \"Character\":\n        case \"CharacterSet\":\n        case \"Flags\":\n            return false;\n        default:\n            return assertNever(node);\n    }\n}\n/**\n * Returns the one-based number of the given capturing group.\n *\n * This is the number needed to refer to the capturing group via backreferences.\n */\nexport function getCapturingGroupNumber(group) {\n    let found = 0;\n    try {\n        visitRegExpAST(getPattern(group), {\n            onCapturingGroupEnter(node) {\n                found++;\n                if (node === group) {\n                    // throw an error to end early\n                    throw new Error();\n                }\n            },\n        });\n        throw new Error(\"Unable to find the given capturing group in its parent pattern.\");\n    }\n    catch (error) {\n        return found;\n    }\n}\n/**\n * Returns the pattern node of the JS RegExp of a given node.\n *\n * This operation is guaranteed to always success for all node types except for flags nodes. Flags nodes have an\n * optional `parent` which, if not set, means that this function can't access the pattern node. If the function can't\n * access the pattern node from a flags node, an error will be thrown.\n */\nexport function getPattern(node) {\n    switch (node.type) {\n        case \"RegExpLiteral\":\n            return node.pattern;\n        case \"Pattern\":\n            return node;\n        case \"Flags\":\n            if (node.parent) {\n                return node.parent.pattern;\n            }\n            else {\n                throw new Error(\"Unable to find the pattern of flags without a RegExp literal.\");\n            }\n        default: {\n            let p = node.parent;\n            while (p.type !== \"Pattern\") {\n                p = p.parent;\n            }\n            return p;\n        }\n    }\n}\n/**\n * Returns the direction which which the given node will be matched relative to the closest parent alternative.\n *\n * If the given node is a lookaround, then the result of `getMatchingDirection(lookaround)` will be the same as\n * `getMatchingDirection(lookaround.parent)`.\n */\nexport function getMatchingDirection(node) {\n    let closestLookaround;\n    hasSomeAncestor(node, a => {\n        if (a.type === \"Assertion\") {\n            closestLookaround = a;\n            return true;\n        }\n        return false;\n    });\n    if (closestLookaround === undefined) {\n        // left-to-right matching is assumed\n        return \"ltr\";\n    }\n    else if (closestLookaround.kind === \"lookahead\") {\n        return \"ltr\";\n    }\n    else {\n        return \"rtl\";\n    }\n}\n/**\n * Returns the opposite matching direction of the given matching direction.\n *\n * If `ltr` is given, `rtl` will be returned and vise versa.\n */\nexport function invertMatchingDirection(direction) {\n    return direction === \"ltr\" ? \"rtl\" : \"ltr\";\n}\n/**\n * Converts a given assertion kind into a matching direction.\n *\n * For lookaheads and lookbehinds, the returned matching direction will be the matching direction of their children.\n * I.e. the result of `lookahead` is `ltr` and the result of `lookbehind` is `rtl`.\n *\n * For edge assertions (`^` and `$`), the returned value is the direction of the character the edge assertion asserts.\n * I.e. the result of `^` is `rtl` (because it asserts the previous character) and the result of `$` is `ltr` (because\n * it asserts the next character).\n */\nexport function getMatchingDirectionFromAssertionKind(kind) {\n    return kind === \"end\" || kind === \"lookahead\" ? \"ltr\" : \"rtl\";\n}\n/**\n * Returns whether the given backreference will always be replaced with the empty string.\n *\n * There are two reasons why a backreference might always be replaced with the empty string:\n *\n * 1. The referenced capturing group does not consume characters.\n *\n *    This is the trivial case. If the referenced capturing group never consumes any characters, then a backreference to\n *    that group must be replaced with the empty string.\n *\n *    E.g. `/(\\b)a\\1/`\n *\n * 2. The backreference is not after the referenced capturing group.\n *\n *    A backreference can only be replaced with a non-empty string if the referenced capturing group has captured text\n *    before the backreference is matched. There are multiple reasons why the capturing group might be unable to capture\n *    text before a backreference to it is reached.\n *\n *    - The capturing group might be in a different alternative. E.g. `/(a)b|\\1/`.\n *    - The backreference might be *inside* the capturing group. E.g. `/(a\\1)/`.\n *    - The backreference might be before the capturing group. E.g. `/\\1(a)/`, `/(?:\\1(a))+/`, `/(?<=(a)\\1)b/`\n */\nexport function isEmptyBackreference(backreference, flags) {\n    const group = backreference.resolved;\n    const closestAncestor = getClosestAncestor(backreference, group);\n    if (closestAncestor === group) {\n        // if the backreference is element of the referenced group\n        return true;\n    }\n    if (closestAncestor.type !== \"Alternative\") {\n        // if the closest common ancestor isn't an alternative => they're disjunctive.\n        return true;\n    }\n    const backRefAncestors = new Set();\n    for (let a = backreference; a; a = a.parent) {\n        backRefAncestors.add(a);\n    }\n    // Now for the hard part:\n    // If there exists a path through the regular expression which connect the group and the backreference, then\n    // the backreference can capture the group iff we only move up, down, or right relative to the group.\n    function findBackreference(node) {\n        const parent = node.parent;\n        switch (parent.type) {\n            case \"Alternative\": {\n                // if any elements right to the given node contain or are the backreference, we found it.\n                const index = parent.elements.indexOf(node);\n                // we have to take the current matching direction into account\n                let next;\n                if (getMatchingDirection(node) === \"ltr\") {\n                    // the next elements to match will be right to the given node\n                    next = parent.elements.slice(index + 1);\n                }\n                else {\n                    // the next elements to match will be left to the given node\n                    next = parent.elements.slice(0, index);\n                }\n                if (next.some(e => backRefAncestors.has(e))) {\n                    return true;\n                }\n                // no luck. let's go up!\n                const parentParent = parent.parent;\n                if (parentParent.type === \"Pattern\") {\n                    // can't go up.\n                    return false;\n                }\n                else if (parentParent.type === \"Assertion\" && parentParent.negate) {\n                    // The captured text of a capturing group will be reset after leaving a negated lookaround\n                    return false;\n                }\n                else {\n                    return findBackreference(parentParent);\n                }\n            }\n            case \"Quantifier\":\n                return findBackreference(parent);\n        }\n    }\n    return !findBackreference(group) || isZeroLength(group, flags);\n}\n/**\n * Returns whether the given backreference is a strict backreference.\n *\n * Strict backreferences are backreferences that are always matched __after__ the referenced group was matched. If there\n * exists any path that goes through a backreference but not through the referenced capturing group, that backreference\n * is not strict.\n *\n * ## Examples\n *\n * In the follow examples, `\\1` is a strict backreference:\n *\n * - `/(a)\\1/`\n * - `/(a)(?:b|\\1)/`\n * - `/(a)\\1?/`\n * - `/(?<=\\1(a))b/`\n *\n * In the follow examples, `\\1` is not a strict backreference:\n *\n * - `/(a)|\\1/`\n * - `/(?:(a)|b)\\1/`\n * - `/(a)?\\1/`\n * - `/(?<=(a)\\1)b/`\n * - `/(?!(a)).\\1/`\n */\nexport function isStrictBackreference(backreference) {\n    const group = backreference.resolved;\n    const closestAncestor = getClosestAncestor(backreference, group);\n    if (closestAncestor === group) {\n        // if the backreference is element of the referenced group\n        return false;\n    }\n    if (closestAncestor.type !== \"Alternative\") {\n        // if the closest common ancestor isn't an alternative => they're disjunctive.\n        return false;\n    }\n    const backRefAncestors = new Set();\n    for (let a = backreference; a; a = a.parent) {\n        backRefAncestors.add(a);\n    }\n    function findBackreference(node) {\n        const parent = node.parent;\n        switch (parent.type) {\n            case \"Alternative\": {\n                // if any elements right to the given node contain or are the backreference, we found it.\n                const index = parent.elements.indexOf(node);\n                // we have to take the current matching direction into account\n                let next;\n                if (getMatchingDirection(node) === \"ltr\") {\n                    // the next elements to match will be right to the given node\n                    next = parent.elements.slice(index + 1);\n                }\n                else {\n                    // the next elements to match will be left to the given node\n                    next = parent.elements.slice(0, index);\n                }\n                if (next.some(e => backRefAncestors.has(e))) {\n                    return true;\n                }\n                // no luck. let's go up!\n                const parentParent = parent.parent;\n                if (parentParent.type === \"Pattern\") {\n                    // can't go up.\n                    return false;\n                }\n                else if (parentParent.type === \"Assertion\" && parentParent.negate) {\n                    // The captured text of a capturing group will be reset after leaving a negated lookaround\n                    return false;\n                }\n                else {\n                    if (parentParent.alternatives.length > 1) {\n                        // e.g.: (?:a|(a))+b\\1\n                        return false;\n                    }\n                    return findBackreference(parentParent);\n                }\n            }\n            case \"Quantifier\":\n                if (parent.min === 0) {\n                    // e.g.: (a+)?b\\1\n                    return false;\n                }\n                return findBackreference(parent);\n        }\n    }\n    return findBackreference(group);\n}\n/**\n * Returns whether the given node contains or is a capturing group.\n *\n * This function is guaranteed to behave in the same way as:\n *\n * ```js\n * hasSomeDescendant(node, d => d.type === \"CapturingGroup\")\n * ```\n */\nexport function containsCapturingGroup(node) {\n    return hasSomeDescendant(node, isCapturingGroup);\n}\nfunction isCapturingGroup(node) {\n    return node.type === \"CapturingGroup\";\n}\nconst ZERO_LENGTH_RANGE = { min: 0, max: 0 };\nconst ONE_LENGTH_RANGE = { min: 1, max: 1 };\n/**\n * Returns how many characters the given element can consume at most and has to consume at least.\n *\n * Note that character classes are not parsed by this function and are assumed to be non-empty.\n *\n * ## Backreferences\n *\n * While {@link isPotentiallyZeroLength} generally assumes the worst-case for backreferences that references capturing group\n * outside the given element, this function does not/cannot. The length range of a backreference only depends on the\n * referenced capturing group and the relative positions of the backreference and the capturing group within the\n * pattern. It does not depend on the given element.\n *\n * This is an important distinction because it means that `isPotentiallyZeroLength(e) -> getLengthRange(e).min == 0` is\n * guaranteed but `getLengthRange(e).min == 0 -> isPotentiallyZeroLength(e)` is only guaranteed if `e` does not contain\n * backreferences.\n *\n * @throws {RangeError} if an empty array of alternatives is given.\n *\n * @see {@link isZeroLength}\n * @see {@link isPotentiallyZeroLength}\n * @see {@link isEmpty}\n * @see {@link isPotentiallyEmpty}\n */\nexport function getLengthRange(element, flags) {\n    if (isReadonlyArray(element)) {\n        return getLengthRangeAlternativesImpl(element, flags);\n    }\n    else {\n        return getLengthRangeElementImpl(element, flags);\n    }\n}\nfunction getLengthRangeAlternativesImpl(alternatives, flags) {\n    let min = Infinity;\n    let max = 0;\n    for (const a of alternatives) {\n        const eRange = getLengthRangeElementImpl(a, flags);\n        min = Math.min(min, eRange.min);\n        max = Math.max(max, eRange.max);\n    }\n    if (min > max) {\n        throw new RangeError(\"Expected the alternatives array to have at least one alternative.\");\n    }\n    else {\n        return { min, max };\n    }\n}\nfunction unicodeSetToLengthRange(set) {\n    const range = set.getLengthRange();\n    if (!range) {\n        // we define that the empty unicode set has a length of 1\n        return ONE_LENGTH_RANGE;\n    }\n    return range;\n}\nfunction getLengthRangeElementImpl(element, flags) {\n    switch (element.type) {\n        case \"Assertion\":\n            return ZERO_LENGTH_RANGE;\n        case \"Character\":\n        case \"CharacterClassRange\":\n            return ONE_LENGTH_RANGE;\n        case \"CharacterSet\":\n            if (element.kind === \"property\" && element.strings) {\n                // we have to evaluate it\n                return unicodeSetToLengthRange(toUnicodeSet(element, flags));\n            }\n            else {\n                return ONE_LENGTH_RANGE;\n            }\n        case \"CharacterClass\": {\n            if (!element.unicodeSets || element.negate || element.elements.length === 0) {\n                return ONE_LENGTH_RANGE;\n            }\n            return getLengthRangeAlternativesImpl(element.elements, flags);\n        }\n        case \"ExpressionCharacterClass\": {\n            if (element.negate) {\n                return ONE_LENGTH_RANGE;\n            }\n            return getLengthRangeElementImpl(element.expression, flags);\n        }\n        case \"ClassIntersection\":\n        case \"ClassSubtraction\": {\n            // we have to evaluate it\n            return unicodeSetToLengthRange(toUnicodeSet(element, flags));\n        }\n        case \"StringAlternative\":\n            return { min: element.elements.length, max: element.elements.length };\n        case \"Quantifier\": {\n            if (element.max === 0) {\n                return ZERO_LENGTH_RANGE;\n            }\n            const elementRange = getLengthRangeElementImpl(element.element, flags);\n            if (elementRange.max === 0) {\n                return ZERO_LENGTH_RANGE;\n            }\n            else {\n                return { min: elementRange.min * element.min, max: elementRange.max * element.max };\n            }\n        }\n        case \"Alternative\": {\n            let min = 0;\n            let max = 0;\n            for (const e of element.elements) {\n                const eRange = getLengthRangeElementImpl(e, flags);\n                min += eRange.min;\n                max += eRange.max;\n            }\n            return { min, max };\n        }\n        case \"CapturingGroup\":\n        case \"Group\":\n        case \"ClassStringDisjunction\":\n            return getLengthRangeAlternativesImpl(element.alternatives, flags);\n        case \"Backreference\": {\n            if (isEmptyBackreference(element, flags)) {\n                return ZERO_LENGTH_RANGE;\n            }\n            else {\n                const resolvedRange = getLengthRangeElementImpl(element.resolved, flags);\n                if (resolvedRange.min > 0 && !isStrictBackreference(element)) {\n                    return { min: 0, max: resolvedRange.max };\n                }\n                else {\n                    return resolvedRange;\n                }\n            }\n        }\n        default:\n            throw assertNever(element);\n    }\n}\n/**\n * Returns whether `getLengthRange(e).min == 0`.\n *\n * This function is slightly different from {@link isPotentiallyZeroLength} in how it handles backreferences. See the\n * notes on backreferences in the documentation of {@link isPotentiallyZeroLength} and {@link getLengthRange} for more\n * information.\n *\n * ## Relations\n *\n * - `isLengthRangeMinZero(e) <-> getLengthRange(e).min == 0`\n *\n * @throws {RangeError} if an empty array of alternatives is given.\n *\n * @see {@link getLengthRange}\n */\nexport function isLengthRangeMinZero(element, flags) {\n    if (isReadonlyArray(element)) {\n        return isLengthRangeMinZeroAlternativesImpl(element, flags);\n    }\n    else {\n        return isLengthRangeMinZeroElementImpl(element, flags);\n    }\n}\nfunction isLengthRangeMinZeroAlternativesImpl(alternatives, flags) {\n    if (alternatives.length === 0) {\n        throw new RangeError(\"Expected the alternatives array to have at least one alternative.\");\n    }\n    return alternatives.some(e => isLengthRangeMinZeroElementImpl(e, flags));\n}\nfunction isLengthRangeMinZeroElementImpl(element, flags) {\n    switch (element.type) {\n        case \"Assertion\":\n            return true;\n        case \"Character\":\n        case \"CharacterClassRange\":\n            return false;\n        case \"CharacterSet\":\n            if (element.kind === \"property\" && element.strings) {\n                // there are current no unicode properties that include the empty string\n                return false;\n            }\n            else {\n                return false;\n            }\n        case \"CharacterClass\":\n            if (!element.unicodeSets || element.negate || element.elements.length === 0) {\n                return false;\n            }\n            return isLengthRangeMinZeroAlternativesImpl(element.elements, flags);\n        case \"ExpressionCharacterClass\":\n            if (element.negate) {\n                return false;\n            }\n            return isLengthRangeMinZeroElementImpl(element.expression, flags);\n        case \"ClassIntersection\":\n        case \"ClassSubtraction\": {\n            // we have to evaluate it\n            return toUnicodeSet(element, flags).hasEmptyWord;\n        }\n        case \"Quantifier\":\n            return element.min === 0 || isLengthRangeMinZeroElementImpl(element.element, flags);\n        case \"Alternative\":\n            return element.elements.every(e => isLengthRangeMinZeroElementImpl(e, flags));\n        case \"StringAlternative\":\n            return element.elements.length === 0;\n        case \"CapturingGroup\":\n        case \"Group\":\n        case \"ClassStringDisjunction\":\n            return isLengthRangeMinZeroAlternativesImpl(element.alternatives, flags);\n        case \"Backreference\": {\n            return (isEmptyBackreference(element, flags) ||\n                !isStrictBackreference(element) ||\n                isLengthRangeMinZeroElementImpl(element.resolved, flags));\n        }\n        default:\n            throw assertNever(element);\n    }\n}\nexport function getClosestAncestor(...args) {\n    if (args.length === 0)\n        return undefined;\n    return args.reduce(getClosestAncestorImpl);\n}\nfunction getClosestAncestorImpl(a, b) {\n    if (a === b) {\n        // trivial\n        return a;\n    }\n    else if (a.parent && a.parent === b.parent) {\n        // this case is quite common and doesn't require any memory allocation\n        return a.parent;\n    }\n    else {\n        const aPath = getPathToRoot(a);\n        const bPath = getPathToRoot(b);\n        while (true) {\n            if (aPath.length === 0) {\n                return a;\n            }\n            else if (bPath.length === 0) {\n                return b;\n            }\n            else if (aPath[aPath.length - 1] === bPath[bPath.length - 1]) {\n                aPath.pop();\n                bPath.pop();\n            }\n            else {\n                break;\n            }\n        }\n        const p = aPath[aPath.length - 1].parent;\n        if (p) {\n            return p;\n        }\n        throw new Error(\"The two nodes are not part of the same tree.\");\n    }\n}\nfunction getPathToRoot(a) {\n    const path = [];\n    for (let an = a; an; an = an.parent) {\n        path.push(an);\n    }\n    return path;\n}\n/**\n * Returns how many times the regex engine can match the given element at most.\n *\n * This method will treat elements inside lookarounds differently. Elements inside lookarounds will ignore everything\n * outside the lookaround.\n *\n * ## Examples\n *\n * - `/a?/`: This will return 1 for `a`.\n * - `/a+/`: This will return infinity for `a` and 1 for the quantifier `a+`.\n * - `/((a{0,8}){0,8}){0,8}/`: This will return 512 for `a`.\n * - `/(ba{0})+/`: This will return 0 for `a` and infinity for the quantifier `a{0}`.\n * - `/(\\w(?!a{3}b))+/`: This will return 3 for `a` because `a` is inside a lookaround and therefore unaffected by the\n *   `(\\w(?!a{3}b)))+` quantifier.\n */\nexport function getEffectiveMaximumRepetition(element) {\n    let max = 1;\n    for (let n = element.parent; n; n = n.parent) {\n        if (n.type === \"Quantifier\") {\n            max *= n.max;\n            if (max === 0) {\n                return 0;\n            }\n        }\n        else if (n.type === \"Assertion\") {\n            break;\n        }\n    }\n    return max;\n}\n","import { isStrictBackreference } from \"./basic\";\nimport { assertNever } from \"./util\";\n/**\n * Returns whether two nodes are structurally equivalent.\n *\n * If two elements are structurally equivalent, they must also semantically equivalent. However, two semantically\n * equivalent elements might not be structurally equivalent (e.g. `/[ab]/` !=<sub>struct</sub> `/[ba]/`).\n */\nexport function structurallyEqual(x, y) {\n    if (x == y) {\n        return true;\n    }\n    if (!x || !y || x.type != y.type) {\n        return false;\n    }\n    switch (x.type) {\n        case \"Alternative\":\n        case \"StringAlternative\": {\n            const other = y;\n            return manyAreStructurallyEqual(x.elements, other.elements);\n        }\n        case \"Assertion\": {\n            const other = y;\n            if (x.kind === other.kind) {\n                if (x.kind === \"lookahead\" || x.kind === \"lookbehind\") {\n                    const otherLookaround = y;\n                    return (x.negate === otherLookaround.negate &&\n                        manyAreStructurallyEqual(x.alternatives, otherLookaround.alternatives));\n                }\n                else {\n                    return x.raw === other.raw;\n                }\n            }\n            return false;\n        }\n        case \"Backreference\": {\n            const other = y;\n            return (structurallyEqual(x.resolved, other.resolved) &&\n                isStrictBackreference(x) == isStrictBackreference(other));\n        }\n        case \"Character\": {\n            const other = y;\n            return x.value === other.value;\n        }\n        case \"CharacterClass\": {\n            const other = y;\n            return (x.negate === other.negate &&\n                x.unicodeSets === other.unicodeSets &&\n                manyAreStructurallyEqual(x.elements, other.elements));\n        }\n        case \"CharacterClassRange\": {\n            const other = y;\n            return structurallyEqual(x.min, other.min) && structurallyEqual(x.max, other.max);\n        }\n        case \"CharacterSet\": {\n            const other = y;\n            if (x.kind === \"property\" && other.kind === \"property\") {\n                return x.negate === other.negate && x.key === other.key && x.value === other.value;\n            }\n            else {\n                return x.raw === other.raw;\n            }\n        }\n        case \"ExpressionCharacterClass\": {\n            const other = y;\n            return x.negate === other.negate && structurallyEqual(x.expression, other.expression);\n        }\n        case \"ClassIntersection\":\n        case \"ClassSubtraction\": {\n            const other = y;\n            return structurallyEqual(x.left, other.left) && structurallyEqual(x.right, other.right);\n        }\n        case \"Flags\": {\n            const other = y;\n            return (x.dotAll === other.dotAll &&\n                x.global === other.global &&\n                x.ignoreCase === other.ignoreCase &&\n                x.multiline === other.multiline &&\n                x.sticky === other.sticky &&\n                x.unicode === other.unicode &&\n                x.unicodeSets === other.unicodeSets);\n        }\n        case \"ClassStringDisjunction\":\n        case \"CapturingGroup\":\n        case \"Group\":\n        case \"Pattern\": {\n            const other = y;\n            return manyAreStructurallyEqual(x.alternatives, other.alternatives);\n        }\n        case \"Quantifier\": {\n            const other = y;\n            return (x.min === other.min &&\n                x.max === other.max &&\n                x.greedy === other.greedy &&\n                structurallyEqual(x.element, other.element));\n        }\n        case \"RegExpLiteral\": {\n            const other = y;\n            return structurallyEqual(x.flags, other.flags) && structurallyEqual(x.pattern, other.pattern);\n        }\n        default:\n            throw assertNever(x);\n    }\n}\nfunction manyAreStructurallyEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (!structurallyEqual(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n","import { getMatchingDirectionFromAssertionKind, getMatchingDirection } from \"./basic\";\nimport { assertNever } from \"./util\";\n/**\n * This function goes to all elements reachable from the given `start` element.\n *\n * ## Paths\n *\n * The function uses _paths_. A path is an [execution path](https://en.wikipedia.org/wiki/Symbolic_execution) that\n * describes a sequence of regex elements.\n *\n * I.e. there are two paths to go from `a` to `b` in the pattern `/a(\\w|dd)b/`. The first path is `a \\w b` and the\n * second path is `a d d b`.\n *\n * However, the problem with paths is that there can be exponentially many because of combinatorial explosion (e.g. the\n * pattern `/(a|b)(a|b)(a|b)(a|b)(a|b)/` has 32 paths). To solve this problem, paths can be _joined_ together again.\n *\n * I.e. in the pattern `/a(\\w|dd)b/`, first element of all paths will be `a`. After `a`, the path splits into two. We\n * call each of the split paths a _fork_. The two forks will be `a ( \\w` and `a ( d d`. The `(` is used to indicate that\n * a fork was made. Since both paths come together after the group ends, they will be _joined_. The joined path of\n * `a ( \\w` and `a ( d d` will be written as `a ( \\w | d d )`. The `)` is used to indicate that forks have been joined.\n * The final path will be `a ( \\w | d d ) b`.\n *\n * This method of forking and joining works for alternations but it won't work for quantifiers. This is why quantifiers\n * will be treated as single elements that can be entered. By default, a quantifier `q` will be interpreted as `( q | )`\n * if its minimum is zero and as `( q )` otherwise.\n *\n * I.e. in the pattern `/ab*c/`, the paths are `a ( b* | ) c`, and in `/ab+c/`, the path is `a b+ c`.\n *\n * ### State\n *\n * Paths are thought of as a sequence of elements and they are represented by state (type parameter `S`). All operations\n * that fork, join, or assert paths will operate on state and not a sequence of elements.\n *\n * State allows operations to be implemented more efficiently and ensures that only necessary data is passed around.\n * An analysis of paths usually tracks properties and analyses how these properties change, the current value of these\n * properties is state.\n *\n * ## Operations\n *\n * Operations act upon state and are specific to the type of state. They define how state changes when\n * entering/leaving/asserting elements and how paths fork, join, and continue.\n *\n * ### Operation sequence\n *\n * To follow all paths, two methods are necessary: one method that enters elements and one that determines the next\n * element. These methods will be called `Enter` and `Next` respectively. These methods will call the given operations\n * roughly like this:\n *\n * ```text\n * function Enter(element, state):\n *     operations.enter\n *     if operations.continueInto:\n *         if element.type == GROUP:\n *             operations.join(\n *                 element.alternatives.map(e => Enter(e, operations.fork(state)))\n *             )\n *         if element.type == QUANTIFIER:\n *             if element.max == 0:\n *                 // do nothing\n *             else if element.min == 0:\n *                 operations.join([\n *                     state,\n *                     Enter(quantifier, operations.fork(state))\n *                 ])\n *             else:\n *                 Enter(quantifier, operations.fork(state))\n *         if element.type == LOOKAROUND:\n *             operations.assert(\n *                 state,\n *                 operations.join(\n *                     element.alternatives.map(e => Enter(e, operations.fork(state)))\n *                 )\n *             )\n *     operations.leave\n *     Next(element, state)\n *\n * function Next(element, state):\n *     if operations.continueAfter:\n *         if noNextElement:\n *             operations.endPath\n *         else:\n *             Enter(nextElement, state)\n * ```\n *\n * (This is just simplified pseudo code but the general order of operations will be the same.)\n *\n * ## Runtime\n *\n * If `n` elements can be reached from the given starting element, then the average runtime will be `O(n)` and the\n * worst-case runtime will be `O(n^2)`.\n *\n * @param start\n * @param startMode If \"enter\", then the first element to be entered will be the starting element. If \"leave\", then the\n * first element to continue after will be the starting element.\n * @param initialState\n * @param operations\n * @param direction The direction in which paths will be followed. If undefined, then the natural matching direction\n * ({@link getMatchingDirection}) of the start element will be used.\n *\n * @typeParam S The type of the state.\n */\nexport function followPaths(start, startMode, initialState, operations, direction) {\n    function opEnter(element, state, direction) {\n        var _a, _b;\n        if (operations.enter) {\n            state = operations.enter(element, state, direction);\n        }\n        const continueInto = (_b = (_a = operations.continueInto) === null || _a === void 0 ? void 0 : _a.call(operations, element, state, direction)) !== null && _b !== void 0 ? _b : true;\n        if (continueInto) {\n            switch (element.type) {\n                case \"Assertion\": {\n                    if (element.kind === \"lookahead\" || element.kind === \"lookbehind\") {\n                        const assertionDirection = getMatchingDirectionFromAssertionKind(element.kind);\n                        const assertion = operations.join(element.alternatives.map(a => enterAlternative(a, doFork(operations, state, direction), assertionDirection)), assertionDirection);\n                        state = endPath(state, assertionDirection, \"assertion\");\n                        if (operations.assert) {\n                            state = operations.assert(state, direction, assertion, assertionDirection);\n                        }\n                    }\n                    break;\n                }\n                case \"Group\":\n                case \"CapturingGroup\": {\n                    state = operations.join(element.alternatives.map(a => enterAlternative(a, doFork(operations, state, direction), direction)), direction);\n                    break;\n                }\n                case \"Quantifier\": {\n                    if (element.max === 0) {\n                        // do nothing\n                    }\n                    else if (element.min === 0) {\n                        state = operations.join([state, opEnter(element.element, doFork(operations, state, direction), direction)], direction);\n                    }\n                    else {\n                        state = opEnter(element.element, state, direction);\n                    }\n                    break;\n                }\n            }\n        }\n        if (operations.leave) {\n            state = operations.leave(element, state, direction);\n        }\n        return state;\n    }\n    function enterAlternative(alternative, state, direction) {\n        var _a, _b;\n        let i = direction === \"ltr\" ? 0 : alternative.elements.length - 1;\n        const increment = direction === \"ltr\" ? +1 : -1;\n        let element;\n        for (; (element = alternative.elements[i]); i += increment) {\n            state = opEnter(element, state, direction);\n            const continueAfter = (_b = (_a = operations.continueAfter) === null || _a === void 0 ? void 0 : _a.call(operations, element, state, direction)) !== null && _b !== void 0 ? _b : true;\n            if (!continueAfter) {\n                break;\n            }\n        }\n        return state;\n    }\n    function opNext(element, state, direction) {\n        for (;;) {\n            let after = getNextElement(element, state, direction);\n            while (Array.isArray(after)) {\n                const [quant, other] = after;\n                state = operations.join([state, opEnter(quant, doFork(operations, state, direction), direction)], direction);\n                after = other;\n            }\n            if (after === false) {\n                return state;\n            }\n            else if (after === \"assertion\" || after === \"pattern\") {\n                return endPath(state, direction, after);\n            }\n            else {\n                state = opEnter(after, state, direction);\n                element = after;\n            }\n        }\n    }\n    function getNextElement(element, state, direction) {\n        var _a, _b;\n        const parent = element.parent;\n        if (parent.type === \"CharacterClass\" ||\n            parent.type === \"CharacterClassRange\" ||\n            parent.type === \"ClassIntersection\" ||\n            parent.type === \"ClassSubtraction\" ||\n            parent.type === \"ExpressionCharacterClass\" ||\n            parent.type === \"StringAlternative\") {\n            throw new Error(\"The given element cannot be part of a character class.\");\n        }\n        const continuePath = (_b = (_a = operations.continueAfter) === null || _a === void 0 ? void 0 : _a.call(operations, element, state, direction)) !== null && _b !== void 0 ? _b : true;\n        if (!continuePath) {\n            return false;\n        }\n        if (parent.type === \"Quantifier\") {\n            // This is difficult.\n            // The main problem is that paths coming out of the quantifier might loop back into itself. This means that\n            // we have to consider the path that leaves the quantifier and the path that goes back into the quantifier.\n            if (parent.max <= 1) {\n                // Can't loop, so we only have to consider the path going out of the quantifier.\n                return getNextElement(parent, state, direction);\n            }\n            else {\n                return [parent, getNextElement(parent, state, direction)];\n            }\n        }\n        else {\n            const nextIndex = parent.elements.indexOf(element) + (direction === \"ltr\" ? +1 : -1);\n            const nextElement = parent.elements[nextIndex];\n            if (nextElement) {\n                return nextElement;\n            }\n            else {\n                const parentParent = parent.parent;\n                if (parentParent.type === \"Pattern\") {\n                    return \"pattern\";\n                }\n                else if (parentParent.type === \"Assertion\") {\n                    if (continueOutside(parentParent, state, direction)) {\n                        return getNextElement(parentParent, state, direction);\n                    }\n                    return \"assertion\";\n                }\n                else if (parentParent.type === \"CapturingGroup\" || parentParent.type === \"Group\") {\n                    return getNextElement(parentParent, state, direction);\n                }\n                throw assertNever(parentParent);\n            }\n        }\n    }\n    function continueOutside(assertion, state, direction) {\n        if (operations.continueOutside) {\n            return operations.continueOutside(assertion, state, direction);\n        }\n        return false;\n    }\n    function endPath(state, direction, reason) {\n        if (operations.endPath) {\n            return operations.endPath(state, direction, reason);\n        }\n        return state;\n    }\n    if (!direction) {\n        direction = getMatchingDirection(start);\n    }\n    if (start.type === \"Alternative\") {\n        // Alternatives are a little tricky.\n        // The basic ideas are the following:\n        //  1) If we want to *enter* an alternative, we can just enter its first element instead.\n        //  2) If we want to *leave* an alternative, we can leave its parent element instead.\n        //     This gets more complex because the parent might be an assertion or the pattern.\n        if (start.elements.length === 0) {\n            // For empty alternatives, entering is the same as leaving\n            startMode = \"next\";\n        }\n        if (startMode === \"enter\") {\n            start = getFirstElement(start, direction);\n        }\n        else {\n            const parent = start.parent;\n            if (parent.type === \"Pattern\") {\n                return endPath(initialState, direction, \"pattern\");\n            }\n            else if (parent.type === \"Assertion\" && !continueOutside(parent, initialState, direction)) {\n                return endPath(initialState, direction, \"assertion\");\n            }\n            start = parent;\n        }\n    }\n    if (startMode === \"enter\") {\n        initialState = opEnter(start, initialState, direction);\n    }\n    return opNext(start, initialState, direction);\n}\nfunction doFork(operations, state, direction) {\n    if (operations.fork) {\n        return operations.fork(state, direction);\n    }\n    else {\n        return state;\n    }\n}\nfunction getFirstElement(a, dir) {\n    if (dir === \"ltr\") {\n        return a.elements[0];\n    }\n    else {\n        return a.elements[a.elements.length - 1];\n    }\n}\n","import { CharSet } from \"refa\";\nimport { getMatchingDirectionFromAssertionKind, isStrictBackreference, getLengthRange, hasSomeDescendant, isEmptyBackreference, invertMatchingDirection, } from \"./basic\";\nimport { toUnicodeSet } from \"./to-char-set\";\nimport { followPaths } from \"./follow\";\nimport { assertNever, CharUnion, intersectInexact, isReadonlyArray, unionInexact } from \"./util\";\nimport { Chars } from \"./chars\";\nimport { CacheInstance } from \"./cache\";\n/**\n * This namespace contains methods for working with {@link FirstLookChar}s.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport var FirstLookChars;\n(function (FirstLookChars) {\n    /**\n     * Returns a {@link FirstLookChar} that is equivalent to a trivially accepting lookaround.\n     *\n     * The returned look is semantically equivalent to `(?=)` == `(?=[^]|$)` or `(?<=)` == `(?<=[^]|^)`.\n     */\n    function all(flags) {\n        return {\n            char: Chars.all(flags),\n            exact: true,\n            edge: true,\n        };\n    }\n    FirstLookChars.all = all;\n    /**\n     * Returns a {@link FirstLookChar} that is equivalent to an assertion that only accepts the start/end of the input\n     * string.\n     *\n     * The returned look is semantically equivalent to `$` == `(?=[]|$)` or `^` == `(?<=[]|^)`.\n     */\n    function edge(flags) {\n        return {\n            char: Chars.empty(flags),\n            exact: true,\n            edge: true,\n        };\n    }\n    FirstLookChars.edge = edge;\n    /**\n     * Converts the given {@link FirstLookChar} to a {@link FirstConsumedChar}.\n     *\n     * This is semantically equivalent to `(?=b|$)` -> `[]|(?=b|$)`.\n     *\n     * Note: This operation will typically return a {@link FirstPartiallyConsumedChar}. It will only return a\n     * {@link FirstFullyConsumedChar} if the given `char` is empty and `edge: false`. This is because\n     * `(?=[])` -> `[]|(?=[])` == `[]`.\n     */\n    function toConsumed(look) {\n        if (!look.edge && look.char.isEmpty) {\n            // the given look trivially rejects everything\n            return {\n                char: CharSet.empty(look.char.maximum),\n                exact: true,\n                empty: false,\n            };\n        }\n        else {\n            return {\n                char: CharSet.empty(look.char.maximum),\n                exact: true,\n                empty: true,\n                look,\n            };\n        }\n    }\n    FirstLookChars.toConsumed = toConsumed;\n})(FirstLookChars || (FirstLookChars = {}));\n/**\n * This namespace contains methods for working with {@link FirstConsumedChar}s.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport var FirstConsumedChars;\n(function (FirstConsumedChars) {\n    /**\n     * Returns a {@link FirstConsumedChar} that is equivalent to the empty concatenation.\n     */\n    function emptyConcat(flags) {\n        return {\n            char: Chars.empty(flags),\n            exact: true,\n            empty: true,\n            look: FirstLookChars.all(flags),\n        };\n    }\n    FirstConsumedChars.emptyConcat = emptyConcat;\n    /**\n     * Returns a {@link FirstConsumedChar} that is equivalent to the empty union (or empty set).\n     */\n    function emptyUnion(flags) {\n        return {\n            char: Chars.empty(flags),\n            exact: true,\n            empty: false,\n        };\n    }\n    FirstConsumedChars.emptyUnion = emptyUnion;\n    /**\n     * Converts the given {@link FirstConsumedChar} to a {@link FirstLookChar}.\n     *\n     * This is conceptually equivalent to wrapping the given consumed character into a lookaround.\n     *\n     * This is semantically equivalent to `a|(?=b|$)` -> `(?=a|(?=b|$))` == `(?=[ab]|$)`.\n     */\n    function toLook(consumed) {\n        if (consumed.empty) {\n            // We have 2 cases:\n            //   (1) (?=a|(?=b))\n            //       (?=a|b)\n            //       (?=[ab])\n            //   (2) (?=a|(?=b|$))\n            //       (?=a|b|$)\n            //       (?=[ab]|$)\n            const union = unionInexact(consumed, consumed.look);\n            return {\n                char: union.char,\n                exact: union.exact,\n                edge: consumed.look.edge,\n            };\n        }\n        else {\n            // It's already in the correct form:\n            //   (?=a)\n            return {\n                char: consumed.char,\n                exact: consumed.exact,\n                edge: false,\n            };\n        }\n    }\n    FirstConsumedChars.toLook = toLook;\n    /**\n     * Creates the union of all the given {@link FirstConsumedChar}s.\n     *\n     * The result is independent of the order in which the characters are given.\n     */\n    function union(chars, flags) {\n        const union = CharUnion.fromFlags(flags);\n        const looks = [];\n        for (const itemChar of chars) {\n            union.add(itemChar);\n            if (itemChar.empty) {\n                looks.push(itemChar.look);\n            }\n        }\n        if (looks.length > 0) {\n            if (looks.length === 1) {\n                return {\n                    char: union.char,\n                    exact: union.exact,\n                    empty: true,\n                    look: looks[0],\n                };\n            }\n            // This means that the unioned elements look something like this:\n            //   (a|(?=g)|b?|x)\n            //\n            // Adding the trivially accepting look after all all alternatives that can be empty, we'll get:\n            //   (a|(?=g)|b?|x)\n            //   (a|(?=g)|b?(?=[^]|$)|x)\n            //   (a|(?=g)|b(?=[^]|$)|(?=[^]|$)|x)\n            //\n            // Since we are only interested in the first character, the look in `b(?=[^]|$)` can be removed.\n            //   (a|(?=g)|b|(?=[^]|$)|x)\n            //   (a|b|x|(?=g)|(?=[^]|$))\n            //   ([abx]|(?=g)|(?=[^]|$))\n            //\n            // To union the looks, we can simply use the fact that `(?=a)|(?=b)` == `(?=a|b)`\n            //   ([abx]|(?=g)|(?=[^]|$))\n            //   ([abx]|(?=g|[^]|$))\n            //   ([abx]|(?=[^]|$))\n            //\n            // And with that we are done. This is exactly the form of a first partial char. Getting the exactness of the\n            // union of normal chars and look chars follows the same rules.\n            const lookUnion = CharUnion.fromFlags(flags);\n            let edge = false;\n            for (const look of looks) {\n                lookUnion.add(look);\n                edge = edge || look.edge;\n            }\n            return {\n                char: union.char,\n                exact: union.exact,\n                empty: true,\n                look: { char: lookUnion.char, exact: lookUnion.exact, edge },\n            };\n        }\n        else {\n            return { char: union.char, exact: union.exact, empty: false };\n        }\n    }\n    FirstConsumedChars.union = union;\n    /**\n     * Creates the concatenation of all the given {@link FirstConsumedChar}s.\n     *\n     * The given char iterable is evaluated **lazily**. The implementation will try to iterate as few chars as possible.\n     */\n    function concat(chars, flags) {\n        const union = CharUnion.fromFlags(flags);\n        let look = FirstLookChars.all(flags);\n        for (const item of chars) {\n            union.add(intersectInexact(item, look));\n            if (item.empty) {\n                // This is the hard case. We need to convert the expression\n                //   (a|(?=b))(c|(?=d))\n                // into an expression\n                //   e|(?=f)\n                // (we will completely ignore edge assertions for now)\n                //\n                // To do that, we'll use the following idea:\n                //   (a|(?=b))(c|(?=d))\n                //   a(c|(?=d))|(?=b)(c|(?=d))\n                //   ac|a(?=d)|(?=b)c|(?=b)(?=d)\n                //\n                // Since we are only interested in the first char, we can remove the `c` in `ac` and the `(?=d)` in\n                // `a(?=d)`. Furthermore, `(?=b)c` is a single char, so let's call it `C` for now.\n                //   ac|a(?=d)|(?=b)c|(?=b)(?=d)\n                //   a|a|C|(?=b)(?=d)\n                //   [aC]|(?=b)(?=d)\n                //   [aC]|(?=(?=b)d)\n                //\n                // This is *almost* the desired form. We now have to convert `(?=(?=b)d)` to an expression of the form\n                // `(?=f)`. This is the point where we can't ignore edge assertions any longer. Let's look at all possible\n                // cases and see how it plays out. Also, let `D` be the char intersection of `b` and `d`.\n                //   (1) (?=(?=b)d)\n                //       (?=D)\n                //\n                //   (2) (?=(?=b)(d|$))\n                //       (?=(?=b)d|(?=b)$)\n                //       (?=D)\n                //\n                //   (3) (?=(?=b|$)d)\n                //       (?=((?=b)|$)d)\n                //       (?=(?=b)d|$d)\n                //       (?=D)\n                //\n                //   (4) (?=(?=b|$)(d|$))\n                //       (?=((?=b)|$)(d|$))\n                //       (?=(?=b)(d|$)|$(d|$))\n                //       (?=(?=b)d|(?=b)$|$d|$$)\n                //       (?=D|$)\n                //\n                // As we can see, the look char is always `D` and the edge is only accepted if it's accepted by both.\n                const lookIntersection = intersectInexact(look, item.look);\n                look = {\n                    char: lookIntersection.char,\n                    exact: lookIntersection.exact,\n                    edge: look.edge && item.look.edge,\n                };\n                if (!look.edge && look.char.isEmpty) {\n                    // The look trivially rejects everything\n                    return { char: union.char, exact: union.exact, empty: false };\n                }\n            }\n            else {\n                return { char: union.char, exact: union.exact, empty: false };\n            }\n        }\n        return { char: union.char, exact: union.exact, empty: true, look };\n    }\n    FirstConsumedChars.concat = concat;\n    /**\n     * Makes the given consumed character optional.\n     *\n     * This is semantically equivalent to `a|(?=b|$)` -> `a?`.\n     */\n    function makeOptional(consumed) {\n        return {\n            char: consumed.char,\n            exact: consumed.exact,\n            empty: true,\n            look: { char: CharSet.all(consumed.char.maximum), exact: true, edge: true },\n        };\n    }\n    FirstConsumedChars.makeOptional = makeOptional;\n})(FirstConsumedChars || (FirstConsumedChars = {}));\nclass ImplOptions {\n    constructor(flags) {\n        this._currentWordBoundaries = [];\n        // We need a cache to avoid an exponential worst case regarding boundary assertions.\n        // If the current flags are a cache instance, we'll use the cache from there and if not, then we'll create a\n        // new cache.\n        if (flags instanceof CacheInstance) {\n            this._ltrCache = flags.getFirstConsumedCharLTR;\n            this._rtlCache = flags.getFirstConsumedCharRTL;\n        }\n        else {\n            this._ltrCache = new WeakMap();\n            this._rtlCache = new WeakMap();\n        }\n    }\n    isCurrentWordBoundary(element) {\n        return this._currentWordBoundaries.some(e => e === element);\n    }\n    pushWordBoundary(element) {\n        this._currentWordBoundaries.push(element);\n    }\n    popWordBoundary() {\n        this._currentWordBoundaries.pop();\n    }\n    getCached(element, dir) {\n        if (dir === \"ltr\") {\n            return this._ltrCache.get(element);\n        }\n        else {\n            return this._rtlCache.get(element);\n        }\n    }\n    setCached(element, dir, result) {\n        if (dir === \"ltr\") {\n            this._ltrCache.set(element, result);\n        }\n        else {\n            this._rtlCache.set(element, result);\n        }\n    }\n}\n/**\n * If a character is returned, it guaranteed to be a super set of the actual character. If the given element is\n * always of zero length, then the empty character set will be returned.\n *\n * If `exact` is `true` then it is guaranteed that the returned character is guaranteed to be the actual\n * character at all times if this element is not influenced by lookarounds outside itself.\n *\n * ## Partially consumed\n *\n * Only the given element and its children are processed. This is important when considering partially consumed first\n * characters. The lookaround is derived only from the assertions inside the given element.\n *\n * E.g. In `/b?a/`, the result for `b?` is `{ char: 'b', empty: true, look: { char: all, edge: true } }`. The\n * lookaround accepts all characters because it doesn't take the `a` after `b?` into consideration.\n */\nexport function getFirstConsumedChar(element, direction, flags) {\n    const options = new ImplOptions(flags);\n    if (isReadonlyArray(element)) {\n        return getFirstConsumedCharAlternativesImpl(element, direction, flags, options);\n    }\n    else {\n        return getFirstConsumedCharImpl(element, direction, flags, options);\n    }\n}\nfunction getFirstConsumedCharAlternativesImpl(alternatives, direction, flags, options) {\n    return FirstConsumedChars.union(alternatives.map(e => getFirstConsumedCharImpl(e, direction, flags, options)), flags);\n}\nfunction getFirstConsumedCharImpl(element, direction, flags, options) {\n    let result = options.getCached(element, direction);\n    if (result === undefined) {\n        result = getFirstConsumedCharUncachedImpl(element, direction, flags, options);\n        options.setCached(element, direction, result);\n    }\n    return result;\n}\nfunction getFirstConsumedCharAssertionImpl(element, direction, flags, options) {\n    switch (element.kind) {\n        case \"word\":\n            if (options.isCurrentWordBoundary(element)) {\n                // this means that the value of a word boundary assertion depends on itself indirectly.\n                // we have to stop the recursion here because infinite recursion is possible otherwise.\n                return misdirectedAssertion();\n            }\n            else {\n                options.pushWordBoundary(element);\n                const before = getFirstCharAfterImpl(element, invertMatchingDirection(direction), flags, options);\n                options.popWordBoundary();\n                // Remember:\n                //   \\B == (?<=\\w)(?=\\w)|(?<!\\w)(?!\\w)\n                //   \\b == (?<!\\w)(?=\\w)|(?<=\\w)(?!\\w)\n                const word = Chars.word(flags);\n                if (before.edge) {\n                    // this forces our hand a little. Since the previous \"character\" might be the start/end of\n                    // the string, we have to enter the alternative that starts with `(?<!\\w)`\n                    if (before.char.isDisjointWith(word)) {\n                        return wordAssertion(element.negate);\n                    }\n                    else {\n                        // it might be either of the alternatives\n                        return misdirectedAssertion();\n                    }\n                }\n                else {\n                    if (before.char.isDisjointWith(word)) {\n                        return wordAssertion(element.negate);\n                    }\n                    else if (before.char.isSubsetOf(word)) {\n                        return wordAssertion(!element.negate);\n                    }\n                    else {\n                        // it might be either of the alternatives\n                        return misdirectedAssertion();\n                    }\n                }\n            }\n        case \"end\":\n        case \"start\":\n            if (getMatchingDirectionFromAssertionKind(element.kind) === direction) {\n                if (flags.multiline) {\n                    return lineAssertion();\n                }\n                else {\n                    return edgeAssertion();\n                }\n            }\n            else {\n                return misdirectedAssertion();\n            }\n        case \"lookahead\":\n        case \"lookbehind\":\n            if (getMatchingDirectionFromAssertionKind(element.kind) === direction) {\n                if (element.negate) {\n                    // A little note about negative:\n                    //\n                    // Negation is hard because it throws the idea of exactness on its heads. The interface defines\n                    // exactness in a way that means: \"we only guarantee that the returned characters are a superset of\n                    // the actual (=correct) characters.\" Negation is incompatible with that definition of exactness\n                    // because negating a _superset_ means that we can only guarantee a _subset_. So we can only do\n                    // _exact_ negation. This is a big limitation.\n                    //\n                    // So what negations can be done _exactly_?\n                    // Single-character negations, e.g. `(?!a)` or `(?!a|b|\\d)`. That's it. All other negated assertions\n                    // are not doable _in general_.\n                    if (hasSomeDescendant(element, d => d !== element && d.type === \"Assertion\")) {\n                        return misdirectedAssertion();\n                    }\n                    const firstChar = getFirstConsumedCharAlternativesImpl(element.alternatives, direction, flags, options);\n                    const range = getLengthRange(element.alternatives, flags);\n                    if (firstChar.empty || !range) {\n                        // trivially rejecting\n                        return { char: Chars.empty(flags), empty: false, exact: true };\n                    }\n                    if (!firstChar.exact || range.max !== 1) {\n                        // the goal to to convert `(?![a])` to `(?=[^a]|$)` but this negation is only correct\n                        // if the characters are exact and if the assertion asserts at most one character\n                        // E.g. `(?![a][b])` == `(?=$|[^a]|[a][^b])`\n                        return misdirectedAssertion();\n                    }\n                    else {\n                        return FirstLookChars.toConsumed({ char: firstChar.char.negate(), edge: true, exact: true });\n                    }\n                }\n                else {\n                    const firstChar = getFirstConsumedCharAlternativesImpl(element.alternatives, direction, flags, options);\n                    return FirstLookChars.toConsumed(FirstConsumedChars.toLook(firstChar));\n                }\n            }\n            else {\n                return misdirectedAssertion();\n            }\n        default:\n            throw assertNever(element);\n    }\n    /**\n     * The result for an assertion that (partly) assert for the wrong matching direction.\n     */\n    function misdirectedAssertion() {\n        return FirstLookChars.toConsumed({\n            char: Chars.all(flags),\n            edge: true,\n            // This is the important part.\n            // Since the allowed chars depend on the previous chars, we don't know which will be allowed.\n            exact: false,\n        });\n    }\n    function edgeAssertion() {\n        return FirstLookChars.toConsumed(FirstLookChars.edge(flags));\n    }\n    function lineAssertion() {\n        return FirstLookChars.toConsumed({\n            char: Chars.lineTerminator(flags),\n            edge: true,\n            exact: true,\n        });\n    }\n    function wordAssertion(negate) {\n        const word = Chars.word(flags);\n        return FirstLookChars.toConsumed({\n            char: negate ? word.negate() : word,\n            edge: negate,\n            exact: true,\n        });\n    }\n}\nfunction getFirstConsumedCharUncachedImpl(element, direction, flags, options) {\n    switch (element.type) {\n        case \"Assertion\":\n            return getFirstConsumedCharAssertionImpl(element, direction, flags, options);\n        case \"Character\":\n        case \"CharacterSet\":\n        case \"CharacterClass\":\n        case \"ExpressionCharacterClass\": {\n            const set = toUnicodeSet(element, flags);\n            if (set.accept.isEmpty) {\n                return { char: set.chars, empty: false, exact: true };\n            }\n            else {\n                const firstChars = new Set();\n                if (direction === \"ltr\") {\n                    for (const wordSet of set.accept.wordSets) {\n                        if (wordSet.length > 0) {\n                            firstChars.add(wordSet[0]);\n                        }\n                    }\n                }\n                else {\n                    for (const wordSet of set.accept.wordSets) {\n                        if (wordSet.length > 0) {\n                            firstChars.add(wordSet[wordSet.length - 1]);\n                        }\n                    }\n                }\n                const consumed = {\n                    char: set.chars.union(...firstChars),\n                    empty: false,\n                    exact: true,\n                };\n                return set.hasEmptyWord ? FirstConsumedChars.makeOptional(consumed) : consumed;\n            }\n        }\n        case \"Quantifier\": {\n            if (element.max === 0) {\n                return FirstConsumedChars.emptyConcat(flags);\n            }\n            const firstChar = getFirstConsumedCharImpl(element.element, direction, flags, options);\n            if (element.min === 0) {\n                return FirstConsumedChars.makeOptional(firstChar);\n            }\n            else {\n                return firstChar;\n            }\n        }\n        case \"Alternative\": {\n            let elements = element.elements;\n            if (direction === \"rtl\") {\n                elements = [...elements];\n                elements.reverse();\n            }\n            return FirstConsumedChars.concat((function* () {\n                for (const e of elements) {\n                    yield getFirstConsumedCharImpl(e, direction, flags, options);\n                }\n            })(), flags);\n        }\n        case \"CapturingGroup\":\n        case \"Group\":\n            return getFirstConsumedCharAlternativesImpl(element.alternatives, direction, flags, options);\n        case \"Backreference\": {\n            if (isEmptyBackreference(element, flags)) {\n                return FirstConsumedChars.emptyConcat(flags);\n            }\n            let resolvedChar = getFirstConsumedCharImpl(element.resolved, direction, flags, options);\n            // the resolved character is only exact if it is only a single character.\n            // i.e. /(\\w)\\1/ here the (\\w) will capture exactly any word character, but the \\1 can only match\n            // one word character and that is the only (\\w) matched.\n            if (resolvedChar.exact && resolvedChar.char.size > 1) {\n                resolvedChar = Object.assign(Object.assign({}, resolvedChar), { exact: false });\n            }\n            if (isStrictBackreference(element)) {\n                return resolvedChar;\n            }\n            else {\n                // there is at least one path through which the backreference will (possibly) be replaced with the\n                // empty string\n                return FirstConsumedChars.makeOptional(resolvedChar);\n            }\n        }\n        default:\n            throw assertNever(element);\n    }\n}\nexport function getFirstConsumedCharAfter(afterThis, direction, flags) {\n    return getFirstConsumedCharAfterImpl(afterThis, direction, flags, new ImplOptions(flags));\n}\nfunction getFirstConsumedCharAfterImpl(afterThis, direction, flags, options) {\n    const result = followPaths(afterThis, \"next\", FirstConsumedChars.emptyConcat(flags), {\n        join(states) {\n            return FirstConsumedChars.union(states, flags);\n        },\n        enter(element, state, direction) {\n            const first = getFirstConsumedCharImpl(element, direction, flags, options);\n            return FirstConsumedChars.concat([state, first], flags);\n        },\n        continueInto() {\n            return false;\n        },\n        continueAfter(_, state) {\n            return state.empty;\n        },\n        continueOutside(element, _, direction) {\n            return getMatchingDirectionFromAssertionKind(element.kind) !== direction;\n        },\n    }, direction);\n    return result;\n}\n/**\n * Returns the first character after the given element.\n *\n * What \"after\" means depends the on the given direction which will be interpreted as the current matching\n * direction. You can use this to get the previous character of an element as well.\n */\nexport function getFirstCharAfter(afterThis, direction, flags) {\n    return getFirstCharAfterImpl(afterThis, direction, flags, new ImplOptions(flags));\n}\nfunction getFirstCharAfterImpl(afterThis, direction, flags, options) {\n    return FirstConsumedChars.toLook(getFirstConsumedCharAfterImpl(afterThis, direction, flags, options));\n}\n/**\n * This function behaves exactly like {@link getFirstConsumedCharAfter} but it also tracks what elements contribute to\n * the result.\n */\nexport function getFirstConsumedCharAfterWithContributors(afterThis, direction, flags) {\n    return getFirstConsumedCharAfterWithContributorsImpl(afterThis, direction, flags, new ImplOptions(flags));\n}\nfunction getFirstConsumedCharAfterWithContributorsImpl(afterThis, direction, flags, option) {\n    const result = followPaths(afterThis, \"next\", { char: FirstConsumedChars.emptyConcat(flags), contributors: [] }, {\n        join(states) {\n            const contributors = new Set();\n            states.forEach(s => s.contributors.forEach(e => contributors.add(e)));\n            return {\n                char: FirstConsumedChars.union(states.map(s => s.char), flags),\n                contributors: [...contributors],\n            };\n        },\n        enter(element, state, direction) {\n            const first = getFirstConsumedCharImpl(element, direction, flags, option);\n            return {\n                char: FirstConsumedChars.concat([state.char, first], flags),\n                contributors: [...state.contributors, element],\n            };\n        },\n        continueInto() {\n            return false;\n        },\n        continueAfter(_, state) {\n            return state.char.empty;\n        },\n        continueOutside(element, _, direction) {\n            return getMatchingDirectionFromAssertionKind(element.kind) !== direction;\n        },\n    }, direction);\n    return result;\n}\n/**\n * This function behaves exactly like {@link getFirstCharAfter} but it also tracks what elements contribute to the\n * result.\n */\nexport function getFirstCharAfterWithContributors(afterThis, direction, flags) {\n    return getFirstCharAfterWithContributorsImpl(afterThis, direction, flags, new ImplOptions(flags));\n}\nfunction getFirstCharAfterWithContributorsImpl(afterThis, direction, flags, option) {\n    const { char, contributors } = getFirstConsumedCharAfterWithContributorsImpl(afterThis, direction, flags, option);\n    return { char: FirstConsumedChars.toLook(char), contributors };\n}\n","import { isEmptyBackreference, isLengthRangeMinZero, isStrictBackreference, isZeroLength, } from \"./basic\";\nimport { CacheInstance } from \"./cache\";\nimport { FirstConsumedChars, getFirstCharAfter, getFirstConsumedChar, getFirstConsumedCharAfter, } from \"./next-char\";\nimport { toUnicodeSet } from \"./to-char-set\";\nimport { assertNever } from \"./util\";\n/**\n * Returns the longest knowable prefix guaranteed to always be accepted by the\n * given alternative (ignoring assertions).\n *\n * All character sets except the last one are guaranteed to be non-empty. The\n * last character set is only guaranteed to be non-empty if `includeAfter: false`.\n */\nexport function getLongestPrefix(alternative, direction, flags, options = {}) {\n    const cacheInstance = CacheInstance.from(flags);\n    flags = cacheInstance;\n    const { includeAfter = false, onlyInside = false, looseGroups = false } = options;\n    const cache = cacheInstance.getLongestPrefix;\n    const cacheKey = `${direction},${includeAfter},${onlyInside},${looseGroups}`;\n    let weakCache = cache.get(cacheKey);\n    if (weakCache === undefined) {\n        weakCache = new WeakMap();\n        cache.set(cacheKey, weakCache);\n    }\n    let cached = weakCache.get(alternative);\n    if (cached === undefined) {\n        cached = getLongestPrefixImpl(alternative, direction, { includeAfter, onlyInside, looseGroups, root: alternative }, flags);\n        weakCache.set(alternative, cached);\n    }\n    return cached;\n}\nfunction getLongestPrefixImpl(alternative, direction, options, flags) {\n    const { chars, complete } = getAlternativePrefix(alternative, direction, options, flags);\n    // try to find empty character sets\n    for (let i = 0; i < chars.length; i++) {\n        if (chars[i].isEmpty) {\n            return chars.slice(0, i);\n        }\n    }\n    // append the next character after the alternative\n    if (complete && options.includeAfter && !options.onlyInside) {\n        return [...chars, getFirstCharAfterAlternative(alternative, direction, flags).char];\n    }\n    return chars;\n}\nconst EMPTY_COMPLETE = { chars: [], complete: true };\nconst EMPTY_INCOMPLETE = { chars: [], complete: false };\nfunction getAlternativePrefix(alternative, direction, options, flags) {\n    const { elements } = alternative;\n    const chars = [];\n    const first = direction === \"ltr\" ? 0 : elements.length - 1;\n    const inc = direction === \"ltr\" ? +1 : -1;\n    for (let i = first; i >= 0 && i < elements.length; i += inc) {\n        const inner = getElementPrefix(elements[i], direction, options, flags);\n        chars.push(...inner.chars);\n        if (!inner.complete) {\n            return { chars, complete: false };\n        }\n    }\n    return { chars, complete: true };\n}\nfunction getElementPrefix(element, direction, options, flags) {\n    switch (element.type) {\n        case \"Assertion\":\n            return EMPTY_COMPLETE;\n        case \"Character\":\n        case \"CharacterClass\":\n        case \"CharacterSet\":\n        case \"ExpressionCharacterClass\": {\n            const set = toUnicodeSet(element, flags);\n            if (set.accept.isEmpty) {\n                return { chars: [set.chars], complete: true };\n            }\n            else {\n                const prefixes = [];\n                if (!set.chars.isEmpty) {\n                    prefixes.push({ chars: [set.chars], complete: true });\n                }\n                for (const wordSet of set.accept.wordSets) {\n                    prefixes.push({ chars: wordSet, complete: true });\n                }\n                return getAlternationPrefix(element, prefixes, direction, options, flags);\n            }\n        }\n        case \"CapturingGroup\":\n        case \"Group\":\n            return getGroupPrefix(element, direction, options, flags);\n        case \"Quantifier\":\n            return getQuantifierPrefix(element, direction, options, flags);\n        case \"Backreference\": {\n            if (isEmptyBackreference(element, flags)) {\n                return EMPTY_COMPLETE;\n            }\n            if (isStrictBackreference(element)) {\n                const inner = getElementPrefix(element.resolved, direction, Object.assign(Object.assign({}, options), { includeAfter: false }), flags);\n                return inner;\n            }\n            if (!mayLookAhead(element, options, direction, flags)) {\n                return EMPTY_INCOMPLETE;\n            }\n            const look = FirstConsumedChars.toLook(getFirstConsumedCharPlusAfter(element, direction, flags));\n            return { chars: [look.char], complete: false };\n        }\n        default:\n            assertNever(element);\n    }\n}\nfunction getGroupPrefix(element, direction, options, flags) {\n    const alternatives = element.alternatives.map(a => getAlternativePrefix(a, direction, options, flags));\n    return getAlternationPrefix(element, alternatives, direction, options, flags);\n}\nfunction getAlternationPrefix(element, alternatives, direction, options, flags) {\n    if (alternatives.length === 1) {\n        return alternatives[0];\n    }\n    const chars = [];\n    let complete = true;\n    /** Counts the number of different characters in strict mode */\n    let differentCount = 0;\n    for (let i = 0; complete; i++) {\n        const cs = [];\n        let end = false;\n        for (const a of alternatives) {\n            if (i >= a.chars.length) {\n                end = true;\n            }\n            else {\n                cs.push(a.chars[i]);\n                if (i === a.chars.length - 1 && !a.complete && options.includeAfter) {\n                    complete = false;\n                }\n            }\n        }\n        if (cs.length === 0) {\n            // This means that all alternatives are complete and have the same\n            // length, so we can stop here.\n            break;\n        }\n        if (end) {\n            // This means that one (but not all) complete alternatives have\n            // reached the end, so we have consider the chars after the group.\n            complete = false;\n            if (!mayLookAheadAfter(element, options, direction, flags)) {\n                break;\n            }\n            cs.push(getFirstCharAfter(element, direction, flags).char);\n        }\n        else if (!options.looseGroups) {\n            if (complete && cs.some(c => !c.equals(cs[0]))) {\n                differentCount++;\n            }\n            if (differentCount >= 2) {\n                complete = false;\n                if (!options.includeAfter) {\n                    break;\n                }\n            }\n        }\n        const total = cs[0].union(...cs.slice(1));\n        chars.push(total);\n    }\n    return { chars, complete };\n}\nfunction getQuantifierPrefix(element, direction, options, flags) {\n    if (isZeroLength(element, flags)) {\n        return EMPTY_COMPLETE;\n    }\n    if (isLengthRangeMinZero(element, flags)) {\n        if (!mayLookAhead(element, options, direction, flags)) {\n            return EMPTY_INCOMPLETE;\n        }\n        const look = FirstConsumedChars.toLook(getFirstConsumedCharPlusAfter(element, direction, flags));\n        return { chars: [look.char], complete: false };\n    }\n    const inner = getElementPrefix(element.element, direction, options, flags);\n    if (!inner.complete) {\n        return inner;\n    }\n    if (inner.chars.length === 0) {\n        // The quantifier is not of length zero and the inner element is complete.\n        // If the algorithm is implemented correctly, `inner` will be at least on character long.\n        throw new Error(`Expected the quantifier '${element.raw}' to consume at least one character.`);\n    }\n    const chars = [];\n    for (let i = 0; i < element.min; i++) {\n        chars.push(...inner.chars);\n        if (chars.length > 1000) {\n            // this is a safe-guard to protect against regexes like a{1000000}\n            return { chars, complete: false };\n        }\n    }\n    if (element.min === element.max) {\n        return { chars, complete: true };\n    }\n    if (mayLookAheadAfter(element, options, direction, flags)) {\n        const look = getFirstCharAfter(element, direction, flags);\n        chars.push(look.char.union(inner.chars[0]));\n    }\n    return { chars, complete: false };\n}\n/**\n * This operations is equal to:\n *\n * ```\n * concat(\n *     getFirstConsumedChar(element, direction, flags),\n *     getFirstConsumedCharAfter(element, direction, flags),\n * )\n * ```\n */\nfunction getFirstConsumedCharPlusAfter(element, direction, flags) {\n    const consumed = getFirstConsumedChar(element, direction, flags);\n    if (!consumed.empty) {\n        return consumed;\n    }\n    return FirstConsumedChars.concat([consumed, getFirstConsumedCharAfter(element, direction, flags)], flags);\n}\nfunction getFirstCharAfterAlternative(alternative, direction, flags) {\n    const { elements } = alternative;\n    const last = direction === \"rtl\" ? 0 : elements.length - 1;\n    const inc = direction === \"ltr\" ? +1 : -1;\n    // The idea here is to go back as far as possible into the alternative without consuming a characters.\n    // This allows assertions inside the alternative to affect the character after it.\n    let afterThis = last;\n    while (afterThis >= 0 && afterThis < elements.length && isZeroLength(elements[afterThis], flags)) {\n        afterThis -= inc;\n    }\n    if (afterThis >= 0 && afterThis < elements.length) {\n        return getFirstCharAfter(elements[afterThis], direction, flags);\n    }\n    else {\n        return FirstConsumedChars.toLook(getFirstConsumedCharPlusAfter(alternative, direction, flags));\n    }\n}\nfunction mayLookAhead(element, options, direction, flags) {\n    if (!options.includeAfter) {\n        return false;\n    }\n    if (options.onlyInside) {\n        return isNextCharacterInside(element, direction, options.root, flags);\n    }\n    return true;\n}\nfunction mayLookAheadAfter(element, options, direction, flags) {\n    if (!options.includeAfter) {\n        return false;\n    }\n    if (options.onlyInside) {\n        return isNextCharacterInsideAfter(element, direction, options.root, flags);\n    }\n    return true;\n}\nfunction isNextCharacterInside(element, direction, root, flags) {\n    return !isLengthRangeMinZero(element, flags) || isNextCharacterInsideAfter(element, direction, root, flags);\n}\n/**\n * Returns whether the next character consumed after `afterThis` is entirely determined by the elements of the given\n * `root` alternative.\n *\n * This assumes that `afterThis` is a descendant of `root`.\n */\nfunction isNextCharacterInsideAfter(afterThis, direction, root, flags) {\n    const parent = afterThis.parent;\n    if (parent.type === \"CharacterClass\" ||\n        parent.type === \"CharacterClassRange\" ||\n        parent.type === \"ClassIntersection\" ||\n        parent.type === \"ClassSubtraction\" ||\n        parent.type === \"ExpressionCharacterClass\" ||\n        parent.type === \"StringAlternative\") {\n        throw new Error(\"Expected an element outside a character class.\");\n    }\n    if (parent.type === \"Quantifier\") {\n        return isNextCharacterInsideAfter(parent, direction, root, flags);\n    }\n    const inc = direction === \"ltr\" ? +1 : -1;\n    const start = parent.elements.indexOf(afterThis);\n    for (let i = start + inc; i >= 0 && i < parent.elements.length; i += inc) {\n        const e = parent.elements[i];\n        if (!isLengthRangeMinZero(e, flags)) {\n            return true;\n        }\n    }\n    if (parent === root) {\n        // since we reached the root, we couldn't find something is consumed a character\n        return false;\n    }\n    const grandparent = parent.parent;\n    if (grandparent.type === \"Pattern\") {\n        throw new Error(\"Expected the given element to be a descendant of the root alternative.\");\n    }\n    if (grandparent.type === \"Assertion\") {\n        // honestly, this doesn't make sense, so let's just throw an error\n        throw new Error();\n    }\n    return isNextCharacterInsideAfter(grandparent, direction, root, flags);\n}\n","import { CharBase } from \"refa\";\nimport { getLongestPrefix } from \"./longest-prefix\";\nimport { assertSameParent, SetEquivalence } from \"./util\";\n/**\n * This splits the set of alternative into disjoint non-empty equivalence\n * classes based on the characters consumed by the alternatives. The\n * equivalence classes can be reordered freely but elements within an\n * equivalence class have to be proven to be reorderable.\n *\n * The idea of determinism is that we can reorder alternatives freely if the\n * regex engine doesn't have a choice as to which alternative to take.\n *\n * E.g. we can freely reorder the alternatives `food|butter|bread` because the\n * alternatives are not a prefix of each other and do not overlap. On the other\n * hand, the alternatives `a|aa` cannot be reordered without affecting the\n * regex.\n *\n * @param alternatives A set of alternatives with the same parent.where all\n * alternatives have the same parent.\n *\n * The collection must be possible to iterate multiple times. Ideally, the\n * backing data structure of this parameter is `Set` but other collection types\n * are also possible.\n * @param dir The direction from which characters are read to determine the\n * equivalence classes.\n *\n * Alternatives can have different equivalence classes depending on the\n * direction from which characters are read. E.g. when reading `a|ba` left to\n * right, the alternatives can be reordered, but not when reading from right to\n * left.\n *\n * The `\"unknown\"` option ensures that the returned equivalence classes hold\n * true regardless of direction. This option can also be thought of as \"both\"\n * directions.\n *\n * Example: Here are the results of this function for `ab|ac|bc` with all\n * direction options:\n *\n * - `\"left\"`: ``[[`ab`, `ac`], [`bc`]]``\n * - `\"right\"`: ``[[`ab`], [`ac`, `bc`]]``\n * - `\"unknown\"`: ``[[`ab`, `ac`, `bc`]]``\n * @param flags The flags of the regex of the given alternatives.\n */\nexport function getDeterminismEqClasses(alternatives, dir, flags) {\n    assertSameParent(alternatives);\n    if (dir === \"unknown\") {\n        return getDirectionIndependentDeterminismEqClasses(alternatives, flags);\n    }\n    return getDirectionalDeterminismEqClasses(alternatives, dir, flags);\n}\n/**\n * This will return equivalence classes independent of the matching direction\n * of the given alternatives.\n */\nfunction getDirectionIndependentDeterminismEqClasses(alternatives, flags) {\n    const ltr = getDirectionalDeterminismEqClasses(alternatives, \"ltr\", flags);\n    const rtl = getDirectionalDeterminismEqClasses(alternatives, \"rtl\", flags);\n    const disjoint = mergeOverlappingSets([...ltr, ...rtl], s => s);\n    const result = [];\n    for (const sets of disjoint) {\n        const eq = new Set();\n        for (const s of sets) {\n            s.forEach(a => eq.add(a));\n        }\n        result.push([...eq]);\n    }\n    return result;\n}\nconst LONGEST_PREFIX_OPTIONS = {\n    includeAfter: true,\n    looseGroups: true,\n};\n/**\n * This splits the set of alternative into disjoint non-empty equivalence\n * classes based on the characters consumed. The equivalence classes can be\n * reordered freely but elements within an equivalence class have to be proven\n * to be reorderable.\n *\n * The idea of determinism is that we can reorder alternatives freely if the\n * regex engine doesn't have a choice as to which alternative to take.\n *\n * E.g. we can freely reorder the alternatives `food|butter|bread` because the\n * alternative are not a prefix of each other and do not overlap.\n */\nfunction getDirectionalDeterminismEqClasses(alternatives, dir, flags) {\n    // Step 1:\n    // We map each alternative to an array of CharSets. Each array represents a\n    // concatenation that we are sure of. E.g. the alternative `abc*de` will\n    // get the array `a, b, [cd]`, and `abc` will get `a, b, c`.\n    const getPrefixCharSets = cachedFn(a => {\n        let prefix = getLongestPrefix(a, dir, flags, LONGEST_PREFIX_OPTIONS);\n        // We optimize a little here.\n        // All trailing all-characters sets can be removed without affecting\n        // the result of the equivalence classes.\n        let all = 0;\n        for (let i = prefix.length - 1; i >= 0; i--) {\n            if (prefix[i].isAll) {\n                all++;\n            }\n            else {\n                break;\n            }\n        }\n        if (all > 0) {\n            prefix = prefix.slice(0, prefix.length - all);\n        }\n        return prefix;\n    });\n    // Step 2:\n    // Remap the prefix CharSets to use base sets instead. The following\n    // operations will scale linearly with the number of characters. By using\n    // base sets instead of the raw CharSets, we can drastically reduce the\n    // number \"logical\" characters. It's the same trick refa uses for its DFA\n    // operations (creation, minimization).\n    const allCharSets = new Set();\n    for (const a of alternatives) {\n        getPrefixCharSets(a).forEach(cs => allCharSets.add(cs));\n    }\n    const base = new CharBase(allCharSets);\n    const prefixes = [];\n    for (const a of alternatives) {\n        prefixes.push({\n            characters: getPrefixCharSets(a).map(cs => base.split(cs)),\n            alternative: a,\n        });\n    }\n    // Step 3:\n    // Create equivalence classes from the prefixes. In the first iteration, we\n    // will only look at the first character and create equivalence classes\n    // based on that. Then we will try to further sub-divide the equivalence\n    // classes based on the second character of the prefixes. This sub-division\n    // process will continue until one prefix in the a equivalence class runs\n    // out of characters.\n    /** Subdivide */\n    function subdivide(eqClass, index) {\n        if (eqClass.length < 2) {\n            return [eqClass];\n        }\n        for (const prefix of eqClass) {\n            if (index >= prefix.characters.length) {\n                // ran out of characters\n                return [eqClass];\n            }\n        }\n        const disjointSets = mergeOverlappingSets(eqClass, p => p.characters[index]);\n        const result = [];\n        for (const set of disjointSets) {\n            result.push(...subdivide(set, index + 1));\n        }\n        return result;\n    }\n    return subdivide(prefixes, 0).map(eq => eq.map(p => p.alternative));\n}\n/**\n * Given a set of sets (`S`), this will merge all overlapping sets until all\n * sets are disjoint.\n *\n * This assumes that all sets contain at least one element.\n *\n * This function will not merge the given sets itself. Instead, it will\n * return an iterable of sets (`Set<S>`) of sets (`S`) to merge. Each set (`S`)\n * is guaranteed to be returned exactly once.\n *\n * Note: Instead of actual JS `Set` instances, the implementation will treat\n * `readonly S[]` instances as sets. This makes the whole implementation a lot\n * more efficient.\n */\nfunction mergeOverlappingSets(sets, getElements) {\n    if (sets.length < 2) {\n        return [sets];\n    }\n    const eq = new SetEquivalence(sets.length);\n    const elementMap = new Map();\n    for (let i = 0; i < sets.length; i++) {\n        const s = sets[i];\n        for (const e of getElements(s)) {\n            const elementSet = elementMap.get(e);\n            if (elementSet === undefined) {\n                // It's the first time we see this element.\n                elementMap.set(e, i);\n            }\n            else {\n                // We've seen this element before in another set.\n                // Make the 2 sets equal.\n                eq.makeEqual(i, elementSet);\n            }\n        }\n    }\n    const eqSets = eq.getEquivalenceSets();\n    const result = [];\n    for (let i = 0; i < eqSets.count; i++) {\n        result.push([]);\n    }\n    for (let i = 0; i < sets.length; i++) {\n        result[eqSets.indexes[i]].push(sets[i]);\n    }\n    return result;\n}\n/**\n * Create a new cached function.\n */\nfunction cachedFn(fn) {\n    /** */\n    function wrapper(value) {\n        let cached = wrapper.cache.get(value);\n        if (cached === undefined) {\n            cached = fn(value);\n            wrapper.cache.set(value, cached);\n        }\n        return cached;\n    }\n    wrapper.cache = new Map();\n    return wrapper;\n}\n","import { hasSomeDescendant, isEmptyBackreference } from \"./basic\";\nimport { Chars } from \"./chars\";\nimport { toUnicodeSet } from \"./to-char-set\";\n/**\n * Returns the union of all characters that can possibly be consumed by the\n * given element.\n */\nexport function getConsumedChars(element, flags) {\n    const sets = [];\n    let exact = true;\n    // we misuse hasSomeDescendant to iterate all relevant elements\n    hasSomeDescendant(element, d => {\n        if (d.type === \"Character\" ||\n            d.type === \"CharacterClass\" ||\n            d.type === \"CharacterSet\" ||\n            d.type === \"ExpressionCharacterClass\") {\n            const c = toUnicodeSet(d, flags);\n            sets.push(c.chars);\n            if (!c.accept.isEmpty) {\n                const chars = new Set();\n                for (const word of c.accept.wordSets) {\n                    for (const char of word) {\n                        chars.add(char);\n                    }\n                }\n                sets.push(Chars.empty(flags).union(...chars));\n            }\n            exact = exact && !c.isEmpty;\n        }\n        else if (d.type === \"Backreference\" && !isEmptyBackreference(d, flags)) {\n            const c = getConsumedChars(d.resolved, flags);\n            sets.push(c.chars);\n            exact = exact && c.exact && c.chars.size < 2;\n        }\n        // always continue to the next element\n        return false;\n    }, \n    // don't go into assertions\n    d => {\n        if (d.type === \"CharacterClass\" || d.type === \"ExpressionCharacterClass\") {\n            return false;\n        }\n        if (d.type === \"Assertion\") {\n            exact = false;\n            return false;\n        }\n        return true;\n    });\n    const chars = Chars.empty(flags).union(...sets);\n    return { chars, exact };\n}\n","import { containsCapturingGroup, getLengthRange, getMatchingDirection, } from \"./basic\";\nimport { toCache } from \"./cache\";\nimport { Chars } from \"./chars\";\nimport { getDeterminismEqClasses } from \"./determinism\";\nimport { getFirstCharAfter } from \"./next-char\";\nimport { toUnicodeSet } from \"./to-char-set\";\nimport { asReadonlySet, assertSameParent } from \"./util\";\nimport { getConsumedChars } from \"./consumed-chars\";\n/**\n * Returns whether the given alternatives can all be reordered.\n *\n * In other words, given a set of alternatives, this will return whether all\n * permutations of those alternatives behave exactly the same as the current\n * permutation of those alternatives.\n *\n * The function makes one more guarantee when some alternatives of the same\n * parent are not given. Let `T` be the set of the given alternatives and let\n * `U` be the set of alternatives that are **not** given and have the same\n * parent as the given alternatives. Let `M` be all alternatives in `U` that\n * are positioned between two alternatives `T`. As long as the relative order\n * of the alternatives in `M` is preserved, all permutations of `T âˆª M` are\n * guaranteed to be have equivalently.\n *\n * Note that this function makes no guarantees about the alternative\n * `U \\ (T âˆª M)`. Permutations that change the position of those alternatives\n * are **not** guaranteed to be valid.\n *\n * Example: `/0|1|2|ðŸ’š|3|4|ðŸ’¯|ðŸ‘‹|5|6/` with `T = ðŸ’š|ðŸ’¯|ðŸ‘‹`, `U = 0|1|2|3|4|5|6`, and\n * `M = 3|4`.\n *\n * This function will return `true` and the following are **guaranteed** to be\n * valid permutations:\n *\n * - `/0|1|2|ðŸ’š|3|4|ðŸ’¯|ðŸ‘‹|5|6/` (unchanged)\n * - `/0|1|2|3|ðŸ’š|4|ðŸ’¯|ðŸ‘‹|5|6/`\n * - `/0|1|2|3|4|ðŸ’š|ðŸ’¯|ðŸ‘‹|5|6/`\n * - `/0|1|2|ðŸ’š|ðŸ’¯|3|4|ðŸ‘‹|5|6/`\n * - `/0|1|2|ðŸ’š|ðŸ’¯|ðŸ‘‹|3|4|5|6/`\n * - `/0|1|2|ðŸ‘‹|ðŸ’¯|ðŸ’š|3|4|5|6/`\n * - `/0|1|2|ðŸ‘‹|3|4|ðŸ’¯|ðŸ’š|5|6/`\n *\n * The following are **not guaranteed** to be valid permutations:\n *\n * - `/0|1|2|ðŸ’š|4|3|ðŸ’¯|ðŸ‘‹|5|6/` (`3` and `4` were swapped)\n * - `/ðŸ’š|0|1|2|3|4|ðŸ’¯|ðŸ‘‹|5|6/` (the position of `0` was changed)\n * - `/0|1|2|ðŸ’š|3|4|ðŸ‘‹|5|6|ðŸ’¯/` (the position of `6` was changed)\n */\nexport function canReorder(alternatives, flags, options = {}) {\n    flags = toCache(flags);\n    const { ignoreCapturingGroups = false, matchingDirection } = options;\n    const target = asReadonlySet(alternatives);\n    if (target.size < 2) {\n        // we can trivially reorder 0 or 1 alternatives\n        return true;\n    }\n    assertSameParent(target);\n    const slice = getAlternativesSlice(target);\n    const direction = matchingDirection !== null && matchingDirection !== void 0 ? matchingDirection : getMatchingDirection(slice[0]);\n    if (direction === \"unknown\") {\n        return (canReorderDirectional(target, slice, \"ltr\", flags, ignoreCapturingGroups) &&\n            canReorderDirectional(target, slice, \"rtl\", flags, ignoreCapturingGroups));\n    }\n    return canReorderDirectional(target, slice, direction, flags, ignoreCapturingGroups);\n}\nexport function canReorderDirectional(target, slice, direction, flags, ignoreCapturingGroups) {\n    const eqClasses = getDeterminismEqClasses(slice, direction, flags);\n    if (!ignoreCapturingGroups && !canReorderCapturingGroups(target, slice, eqClasses)) {\n        return false;\n    }\n    // from this point onward, we don't have to worry about capturing groups\n    // anymore\n    // we only have to prove that we can reorder alternatives within each\n    // equivalence class.\n    return eqClasses.every(eq => {\n        if (eq.length < 2) {\n            return true;\n        }\n        if (eq.every(a => !target.has(a))) {\n            // This equivalence class contains only non-target alternatives.\n            // As by the guarantees provided by this function, these\n            // alternatives are not required to be reorderable.\n            return true;\n        }\n        return canReorderBasedOnLength(eq, flags) || canReorderBasedOnConsumedChars(eq, direction, flags);\n    });\n}\n/**\n * Returns whether the capturing groups in the slice alternative can be\n * reordered.\n */\nfunction canReorderCapturingGroups(target, slice, eqClasses) {\n    // Reordering and capturing groups:\n    // Reordering doesn't play well with capturing groups because changing\n    // the order of two capturing groups is a change that can be observed\n    // by the user and might break the regex. So we have to avoid changing\n    // the relative order of two alternatives with capturing groups.\n    //\n    // Since target alternatives can be reordered, there must be at most one\n    // target alternative containing capturing groups. If one target\n    // alternative contains capturing groups, no other alternative in the\n    // slice is allowed to contain capturing groups.\n    let targetCG = 0;\n    let nonTargetCG = 0;\n    for (const a of slice) {\n        if (containsCapturingGroup(a)) {\n            if (target.has(a)) {\n                targetCG++;\n            }\n            else {\n                nonTargetCG++;\n            }\n        }\n    }\n    if (targetCG > 1 || (targetCG === 1 && nonTargetCG !== 0)) {\n        return false;\n    }\n    if (nonTargetCG !== 0) {\n        // A equivalence class containing a capturing group must not contain a\n        // target alternative.\n        //\n        // Here is an example where this doesn't work: `/^(?:a|(b)|b)$/` with\n        // the targets `a` and `b`. Since `/^(?:a|(b)|b)$/` !=\n        // `/^(?:a|b|(b))$/`, we cannot reorder the target alternatives.\n        return eqClasses.every(eq => {\n            return (\n            // no capturing groups\n            !eq.some(containsCapturingGroup) ||\n                // or no target alternatives\n                eq.every(a => !target.has(a)));\n        });\n    }\n    else if (targetCG !== 0) {\n        // The target alternative with the capturing group must be in its own\n        // equivalence class.\n        return eqClasses.every(eq => {\n            return eq.length < 2 || !eq.some(containsCapturingGroup);\n        });\n    }\n    return true;\n}\n/**\n * Returns whether alternatives can be reordered because they all have the same\n * length.\n *\n * No matter which alternative the regex engine picks, we will always end up in\n * the same place after.\n */\nfunction canReorderBasedOnLength(slice, flags) {\n    const lengthRange = getLengthRange(slice, flags);\n    return Boolean(lengthRange && lengthRange.min === lengthRange.max);\n}\n/**\n * Returns whether alternatives can be reordered because the characters\n * consumed.\n *\n * If the given alternatives are followed (in their current matching direction)\n * by characters not consumed by the alternatives, then the order order of the\n * alternatives doesn't matter.\n *\n * Furthermore, we can factor out common prefixes and suffixes. E.g. checking\n * whether `(?:foobar|footwear)` can be reordered is the same as checking\n * whether `foo(?:b|twe)ar` can be reordered. Using this idea, we can narrow\n * down the consumed characters and find additional characters that also have\n * to be disjoint with the consumed characters.\n */\nfunction canReorderBasedOnConsumedChars(slice, direction, flags) {\n    const factoredOut = factorOutCommon(slice.map(a => a.elements), flags);\n    const elements = [];\n    for (const alternative of factoredOut.rest) {\n        elements.push(...alternative);\n    }\n    const consumedChars = Chars.empty(flags).union(...elements.map(e => getConsumedChars(e, flags).chars));\n    // we first check all suffix characters because we get them for free when factoring out.\n    const suffix = direction === \"ltr\" ? factoredOut.right : factoredOut.left;\n    if (suffix.some(cs => cs.isDisjointWith(consumedChars))) {\n        return true;\n    }\n    // now we check the character after the parent of the given alternatives\n    const parent = slice[0].parent;\n    if (parent.type === \"Pattern\" || parent.type === \"Assertion\") {\n        return false;\n    }\n    return getFirstCharAfter(parent, direction, flags).char.isDisjointWith(consumedChars);\n}\nfunction factorOutCommon(alternatives, flags) {\n    const prefix = factorOutCommonPrefix(alternatives, \"ltr\", flags);\n    const suffix = factorOutCommonPrefix(prefix.rest, \"rtl\", flags);\n    return { left: prefix.prefix, right: suffix.prefix, rest: suffix.rest };\n}\nfunction factorOutCommonPrefix(alternatives, direction, flags) {\n    const prefix = getLongestPureCharPrefix(alternatives, direction, flags);\n    if (prefix.length === 0) {\n        return { prefix, rest: alternatives };\n    }\n    else {\n        // remove prefix\n        return {\n            prefix,\n            rest: alternatives.map(elements => {\n                const start = direction === \"ltr\" ? prefix.length : 0;\n                const end = direction === \"ltr\" ? elements.length : elements.length - prefix.length;\n                return elements.slice(start, end);\n            }),\n        };\n    }\n}\nfunction getLongestPureCharPrefix(alternatives, direction, flags) {\n    const prefix = [];\n    for (let i = 0;; i++) {\n        let char = null;\n        for (const elements of alternatives) {\n            const current = direction === \"ltr\" ? i : elements.length - 1 - i;\n            if (i >= 0 && i < elements.length) {\n                const element = elements[current];\n                switch (element.type) {\n                    case \"Character\":\n                    case \"CharacterClass\":\n                    case \"CharacterSet\":\n                    case \"ExpressionCharacterClass\": {\n                        const set = toUnicodeSet(element, flags);\n                        if (!set.accept.isEmpty) {\n                            return prefix;\n                        }\n                        if (char === null) {\n                            char = set.chars;\n                        }\n                        else {\n                            if (!char.equals(set.chars)) {\n                                return prefix;\n                            }\n                        }\n                        break;\n                    }\n                    default:\n                        return prefix;\n                }\n            }\n            else {\n                return prefix;\n            }\n        }\n        if (char === null)\n            throw new Error();\n        prefix.push(char);\n    }\n}\n/**\n * Returns the smallest slice of alternatives that contains all given\n * alternatives.\n */\nfunction getAlternativesSlice(set) {\n    if (set.size <= 1) {\n        return [...set];\n    }\n    let first;\n    for (const item of set) {\n        first = item;\n        break;\n    }\n    if (!first) {\n        throw new Error();\n    }\n    const parentAlternatives = first.parent.alternatives;\n    let min = set.size;\n    let max = 0;\n    for (let i = 0; i < parentAlternatives.length; i++) {\n        const a = parentAlternatives[i];\n        if (set.has(a)) {\n            min = Math.min(min, i);\n            max = Math.max(max, i);\n        }\n    }\n    return parentAlternatives.slice(min, max + 1);\n}\n"],"names":["isUnicode","flags","unicode","unicodeSets","assertNever","value","message","Error","assertSameParent","alternatives","parent","a","Chars","maxChar","EMPTY_UTF16_CHARSET","CharSet","empty","EMPTY_UNICODE_CHARSET","ALL_UTF16_CHARSET","all","ALL_UNICODE_CHARSET","LINE_TERMINATOR_UTF16_CHARSET","JS","createCharSet","kind","negate","LINE_TERMINATOR_UNICODE_CHARSET","lineTerminator","WORD_UTF16_CHARSET","WORD_UNICODE_CHARSET","ignoreCase","WORD_UNICODE_IGNORE_CASE_CHARSET","word","DIGIT_UTF16_CHARSET","DIGIT_UNICODE_CHARSET","digit","SPACE_UTF16_CHARSET","SPACE_UNICODE_CHARSET","space","isReadonlyArray","Array","isArray","CharUnion","char","this","_exactChars","union","_inexactChars","exact","isSupersetOf","constructor","add","static","maximum","intersectInexact","left","right","intersect","isEmpty","SetEquivalence","count","_indexes","i","push","makeEqual","b","aValue","bValue","getEquivalenceSets","counter","indexes","toCache","CacheInstance","from","toCharSet","WeakMap","toUnicodeSet","getFirstConsumedCharLTR","getFirstConsumedCharRTL","getLongestPrefix","Map","dotAll","global","hasIndices","multiline","sticky","elements","isFlags","length","toCharSetSimpleCached","map","e","element","cached","get","undefined","parseCharSet","set","UnicodeSet","toUnicodeSetSimpleCached","parseUnicodeSet","matchesAllCharacters","type","min","max","strings","isAll","every","matchesNoCharacters","chars","expression","characterIsEmpty","lengthRange","getLengthRange","characterIsPotentiallyEmpty","some","isInvokeEvery","fn","isInvokeSome","isZeroLength","isZeroLengthImpl","isEmptyBackreference","isPotentiallyZeroLengthImpl","root","impl","backreferenceIsPotentiallyEmpty","isEmptyImpl","back","hasSomeAncestor","resolved","isStrictBackreference","node","condition","hasSomeAncestorFnImpl","hasSomeAncestorNodeImpl","hasSomeDescendant","descentConditionFn","hasSomeDescendantImpl","d","conditionFn","pattern","getPattern","p","getMatchingDirection","closestLookaround","invertMatchingDirection","direction","getMatchingDirectionFromAssertionKind","backreference","group","closestAncestor","getClosestAncestor","backRefAncestors","Set","findBackreference","index","indexOf","next","slice","has","parentParent","containsCapturingGroup","isCapturingGroup","ZERO_LENGTH_RANGE","ONE_LENGTH_RANGE","getLengthRangeAlternativesImpl","getLengthRangeElementImpl","Infinity","eRange","Math","RangeError","unicodeSetToLengthRange","range","elementRange","resolvedRange","isLengthRangeMinZero","isLengthRangeMinZeroAlternativesImpl","isLengthRangeMinZeroElementImpl","hasEmptyWord","args","reduce","getClosestAncestorImpl","aPath","getPathToRoot","bPath","pop","path","an","structurallyEqual","x","y","other","manyAreStructurallyEqual","otherLookaround","raw","key","greedy","followPaths","start","startMode","initialState","operations","opEnter","state","_a","_b","enter","continueInto","call","assertionDirection","assertion","join","enterAlternative","doFork","endPath","assert","leave","alternative","increment","continueAfter","getNextElement","nextIndex","nextElement","continueOutside","reason","after","quant","opNext","fork","FirstLookChars","FirstConsumedChars","edge","toConsumed","look","emptyConcat","emptyUnion","toLook","consumed","unionInexact","fromFlags","looks","itemChar","lookUnion","concat","item","lookIntersection","makeOptional","ImplOptions","_currentWordBoundaries","_ltrCache","_rtlCache","isCurrentWordBoundary","pushWordBoundary","popWordBoundary","getCached","dir","setCached","result","getFirstConsumedChar","options","getFirstConsumedCharAlternativesImpl","getFirstConsumedCharImpl","misdirectedAssertion","before","getFirstCharAfterImpl","isDisjointWith","wordAssertion","isSubsetOf","lineAssertion","edgeAssertion","firstChar","getFirstConsumedCharAssertionImpl","accept","firstChars","wordSet","wordSets","reverse","resolvedChar","size","Object","assign","getFirstConsumedCharUncachedImpl","getFirstConsumedCharAfter","afterThis","getFirstConsumedCharAfterImpl","states","first","_","getFirstCharAfter","getFirstConsumedCharAfterWithContributorsImpl","option","contributors","forEach","s","cacheInstance","includeAfter","onlyInside","looseGroups","cache","cacheKey","weakCache","complete","getAlternativePrefix","getFirstCharAfterAlternative","getLongestPrefixImpl","EMPTY_COMPLETE","EMPTY_INCOMPLETE","inc","inner","getElementPrefix","prefixes","getAlternationPrefix","getGroupPrefix","mayLookAhead","getFirstConsumedCharPlusAfter","mayLookAheadAfter","getQuantifierPrefix","differentCount","cs","end","c","equals","total","isNextCharacterInsideAfter","isNextCharacterInside","grandparent","getDeterminismEqClasses","ltr","getDirectionalDeterminismEqClasses","rtl","disjoint","mergeOverlappingSets","sets","eq","getDirectionIndependentDeterminismEqClasses","LONGEST_PREFIX_OPTIONS","getPrefixCharSets","wrapper","cachedFn","prefix","allCharSets","base","CharBase","characters","split","subdivide","eqClass","disjointSets","getElements","elementMap","elementSet","eqSets","getConsumedChars","canReorderDirectional","target","ignoreCapturingGroups","eqClasses","targetCG","nonTargetCG","canReorderCapturingGroups","Boolean","canReorderBasedOnLength","factoredOut","factorOutCommonPrefix","suffix","rest","factorOutCommon","consumedChars","canReorderBasedOnConsumedChars","current","getLongestPureCharPrefix","matchingDirection","iter","parentAlternatives","getAlternativesSlice","found","visitRegExpAST","onCapturingGroupEnter","error","n","getFirstCharAfterWithContributorsImpl","hasStrings","isPotentiallyEmptyImpl"],"mappings":"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"}