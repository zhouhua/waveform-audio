import * as AST from '@eslint-react/ast';
import { useComponentCollector, useComponentCollectorLegacy, isUseStateCall, isReactHookCallWithNameLoose } from '@eslint-react/core';
import { O, isString, isObject, MutRef, F, isNullable } from '@eslint-react/eff';
import * as JSX from '@eslint-react/jsx';
import { createRuleForPlugin, decodeSettings, RE_CONSTANT_CASE, RE_PASCAL_CASE, RE_CAMEL_CASE, RE_KEBAB_CASE, RE_SNAKE_CASE } from '@eslint-react/shared';
import { match } from 'ts-pattern';
import path from 'node:path';
import { capitalize, pascalCase, camelCase, kebabCase, snakeCase } from 'string-ts';
import { AST_NODE_TYPES } from '@typescript-eslint/types';

// package.json
var name = "eslint-plugin-react-naming-convention";
var version = "1.22.1";
var createRule = createRuleForPlugin("naming-convention");

// src/rules/component-name.ts
var RULE_NAME = "component-name";
var defaultOptions = [
  {
    allowAllCaps: false,
    allowLeadingUnderscore: false,
    allowNamespace: false,
    excepts: [],
    rule: "PascalCase"
  }
];
var schema = [
  {
    anyOf: [
      {
        type: "string",
        enum: ["PascalCase", "CONSTANT_CASE"]
      },
      {
        type: "object",
        additionalProperties: false,
        properties: {
          allowAllCaps: { type: "boolean" },
          allowLeadingUnderscore: { type: "boolean" },
          allowNamespace: { type: "boolean" },
          excepts: {
            type: "array",
            items: { type: "string", format: "regex" }
          },
          rule: {
            type: "string",
            enum: ["PascalCase", "CONSTANT_CASE"]
          }
        }
      }
    ]
  }
];
function normalizeOptions(options) {
  const [opts] = options;
  if (isNullable(opts)) return defaultOptions[0];
  if (isString(opts)) return { ...defaultOptions[0], rule: opts };
  return {
    ...opts,
    excepts: opts.excepts?.map((pattern) => new RegExp(pattern, "u")) ?? []
  };
}
function validate(name2, options) {
  if (options.excepts.some((regex) => regex.test(name2))) return true;
  let normalized = name2.normalize("NFKD").replace(/[\u0300-\u036F]/g, "");
  normalized = normalized.split(".").at(-1) ?? normalized;
  if (options.allowNamespace) {
    normalized = normalized.replace(":", "");
  }
  if (options.allowLeadingUnderscore) {
    normalized = normalized.replace(/^_/, "");
  }
  return match(options.rule).with("CONSTANT_CASE", () => RE_CONSTANT_CASE.test(normalized)).with("PascalCase", () => {
    if ([...normalized].length > 3 && /^[A-Z]+$/u.test(normalized)) return options.allowAllCaps;
    return RE_PASCAL_CASE.test(normalized);
  }).otherwise(F.constFalse);
}
var component_name_default = createRule({
  meta: {
    type: "problem",
    defaultOptions: [...defaultOptions],
    docs: {
      description: "enforce component naming convention to 'PascalCase' or 'CONSTANT_CASE'"
    },
    messages: {
      componentName: "A component name must be in {{case}}."
    },
    schema
  },
  name: RULE_NAME,
  create(context) {
    const options = normalizeOptions(context.options);
    const collector = useComponentCollector(context);
    const collectorLegacy = useComponentCollectorLegacy();
    return {
      ...collector.listeners,
      ...collectorLegacy.listeners,
      JSXOpeningElement(node) {
        const name2 = JSX.getElementName(node);
        if (/^[a-z]/u.test(name2)) return;
        if (validate(name2, options)) return;
        context.report({
          messageId: "componentName",
          node,
          data: {
            case: options.rule
          }
        });
      },
      "Program:exit"(node) {
        const functionComponents = collector.ctx.getAllComponents(node);
        const classComponents = collectorLegacy.ctx.getAllComponents(node);
        for (const { node: component } of functionComponents.values()) {
          const maybeId = AST.getFunctionIdentifier(component);
          if (O.isNone(maybeId)) continue;
          const id = maybeId.value;
          const { name: name2 } = id;
          if (validate(name2, options)) continue;
          context.report({
            messageId: "componentName",
            node: id,
            data: {
              case: options.rule
            }
          });
        }
        for (const { node: component } of classComponents.values()) {
          const maybeId = AST.getClassIdentifier(component);
          if (O.isNone(maybeId)) continue;
          const id = maybeId.value;
          const { name: name2 } = id;
          if (validate(name2, options)) continue;
          context.report({
            messageId: "componentName",
            node: id,
            data: {
              case: options.rule
            }
          });
        }
      }
    };
  },
  defaultOptions
});
var RULE_NAME2 = "filename";
var defaultOptions2 = [
  {
    excepts: ["^index$"],
    extensions: [".js", ".jsx", ".ts", ".tsx"],
    rule: "PascalCase"
  }
];
var schema2 = [
  {
    anyOf: [
      {
        type: "string",
        enum: ["PascalCase", "camelCase", "kebab-case", "snake_case"]
      },
      {
        type: "object",
        additionalProperties: false,
        properties: {
          excepts: {
            type: "array",
            items: { type: "string", format: "regex" }
          },
          extensions: {
            type: "array",
            items: { type: "string" },
            uniqueItems: true
          },
          rule: {
            type: "string",
            enum: ["PascalCase", "camelCase", "kebab-case", "snake_case"]
          }
        }
      }
    ]
  }
];
var filename_default = createRule({
  meta: {
    type: "problem",
    defaultOptions: [...defaultOptions2],
    docs: {
      description: "enforce naming convention for JSX filenames"
    },
    messages: {
      // filenameCaseMismatch: "A file with name '{{name}}' does not match {{rule}}.",
      filenameCaseMismatchSuggestion: "A file with name '{{name}}' does not match {{rule}}. Should rename to '{{suggestion}}'.",
      filenameEmpty: "A file must have non-empty name."
    },
    schema: schema2
  },
  name: RULE_NAME2,
  create(context) {
    const options = context.options[0] ?? defaultOptions2[0];
    const rule = isString(options) ? options : options.rule ?? "PascalCase";
    const excepts = isString(options) ? [] : options.excepts ?? [];
    const filename = context.filename;
    function validate2(name2, casing = rule, ignores = excepts) {
      if (ignores.map((pattern) => new RegExp(pattern, "u")).some((pattern) => pattern.test(name2))) {
        return true;
      }
      return match(casing).with("PascalCase", () => RE_PASCAL_CASE.test(name2)).with("camelCase", () => RE_CAMEL_CASE.test(name2)).with("kebab-case", () => RE_KEBAB_CASE.test(name2)).with("snake_case", () => RE_SNAKE_CASE.test(name2)).exhaustive();
    }
    function getSuggestion(name2, casing = rule) {
      return match(casing).with("PascalCase", () => pascalCase(name2)).with("camelCase", () => camelCase(name2)).with("kebab-case", () => kebabCase(name2)).with("snake_case", () => snakeCase(name2)).exhaustive();
    }
    return {
      Program(node) {
        const [basename = "", ...rest] = path.basename(context.filename).split(".");
        if (basename.length === 0) {
          context.report({ messageId: "filenameEmpty", node });
          return;
        }
        if (validate2(basename)) return;
        context.report({
          messageId: "filenameCaseMismatchSuggestion",
          node,
          data: {
            name: filename,
            rule,
            suggestion: [getSuggestion(basename), ...rest].join(".")
          }
        });
      }
    };
  },
  defaultOptions: defaultOptions2
});
var RULE_NAME3 = "filename-extension";
var defaultOptions3 = [{
  allow: "as-needed",
  extensions: [".jsx", ".tsx"],
  ignoreFilesWithoutCode: false
}];
var schema3 = [
  {
    anyOf: [
      {
        type: "string",
        enum: ["always", "as-needed"]
      },
      {
        type: "object",
        additionalProperties: false,
        properties: {
          allow: {
            type: "string",
            enum: ["always", "as-needed"]
          },
          extensions: {
            type: "array",
            items: {
              type: "string"
            },
            uniqueItems: true
          },
          ignoreFilesWithoutCode: {
            type: "boolean"
          }
        }
      }
    ]
  }
];
var filename_extension_default = createRule({
  meta: {
    type: "problem",
    defaultOptions: [...defaultOptions3],
    docs: {
      description: "enforce naming convention for JSX file extensions"
    },
    messages: {
      filenameExtensionInvalid: "The JSX file extension is required.",
      filenameExtensionUnexpected: "Use JSX file extension as needed."
    },
    schema: schema3
  },
  name: RULE_NAME3,
  create(context) {
    const options = context.options[0] ?? defaultOptions3[0];
    const allow = isObject(options) ? options.allow : options;
    const extensions = isObject(options) && "extensions" in options ? options.extensions : defaultOptions3[0].extensions;
    const filename = context.filename;
    const hasJSXNodeRef = MutRef.make(false);
    return {
      JSXElement() {
        MutRef.set(hasJSXNodeRef, true);
      },
      JSXFragment() {
        MutRef.set(hasJSXNodeRef, true);
      },
      "Program:exit"(node) {
        const fileNameExt = filename.slice(filename.lastIndexOf("."));
        const isJSXExt = extensions.includes(fileNameExt);
        const hasJSXCode = MutRef.get(hasJSXNodeRef);
        if (hasJSXCode && !isJSXExt) {
          context.report({
            messageId: "filenameExtensionInvalid",
            node
          });
          return;
        }
        const hasCode = node.body.length > 0;
        const ignoreFilesWithoutCode = isObject(options) && options.ignoreFilesWithoutCode;
        if (!hasCode && ignoreFilesWithoutCode) return;
        if (!hasJSXCode && isJSXExt && allow === "as-needed") {
          context.report({
            messageId: "filenameExtensionUnexpected",
            node
          });
        }
      }
    };
  },
  defaultOptions: defaultOptions3
});
var RULE_NAME4 = "use-state";
var RULE_FEATURES = [
  "CHK"
];
function isSetterNameLoose(name2) {
  const fourthChar = [...name2][3];
  return name2.startsWith("set") && fourthChar === fourthChar?.toUpperCase();
}
var use_state_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce destructuring and symmetric naming of 'useState' hook value and setter variables",
      [Symbol.for("rule_features")]: RULE_FEATURES
    },
    messages: {
      useState: "An useState call is not destructured into value + setter pair."
    },
    schema: []
  },
  name: RULE_NAME4,
  create(context) {
    const alias = decodeSettings(context.settings).additionalHooks?.useState ?? [];
    const { ctx, listeners } = useComponentCollector(context);
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { hookCalls } of components.values()) {
          if (hookCalls.length === 0) continue;
          for (const hookCall of hookCalls) {
            if (!isUseStateCall(hookCall, context) && !alias.some(isReactHookCallWithNameLoose(hookCall))) {
              continue;
            }
            if (hookCall.parent.type !== AST_NODE_TYPES.VariableDeclarator) {
              continue;
            }
            const { id } = hookCall.parent;
            const descriptor = O.some({ messageId: "useState", node: id });
            F.pipe(
              match(id).with({ type: AST_NODE_TYPES.Identifier }, F.constant(descriptor)).with({ type: AST_NODE_TYPES.ArrayPattern }, (n) => {
                const [state, setState] = n.elements;
                if (state?.type === AST_NODE_TYPES.ObjectPattern && setState?.type === AST_NODE_TYPES.Identifier) {
                  return isSetterNameLoose(setState.name) ? O.none() : descriptor;
                }
                if (state?.type !== AST_NODE_TYPES.Identifier || setState?.type !== AST_NODE_TYPES.Identifier) {
                  return O.none();
                }
                const [stateName, setStateName] = [state.name, setState.name];
                const expectedSetterName = `set${capitalize(stateName)}`;
                if (setStateName === expectedSetterName) return O.none();
                return descriptor;
              }).otherwise(O.none),
              O.map(context.report)
            );
          }
        }
      }
    };
  },
  defaultOptions: []
});

// src/index.ts
var index_default = {
  meta: {
    name,
    version
  },
  rules: {
    "component-name": component_name_default,
    filename: filename_default,
    "filename-extension": filename_extension_default,
    "use-state": use_state_default
  }
};

export { index_default as default };
