'use strict';

var AST = require('@eslint-react/ast');
var core = require('@eslint-react/core');
var eff = require('@eslint-react/eff');
var JSX = require('@eslint-react/jsx');
var shared = require('@eslint-react/shared');
var tsPattern = require('ts-pattern');
var path = require('path');
var stringTs = require('string-ts');
var types = require('@typescript-eslint/types');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var AST__namespace = /*#__PURE__*/_interopNamespace(AST);
var JSX__namespace = /*#__PURE__*/_interopNamespace(JSX);
var path__default = /*#__PURE__*/_interopDefault(path);

// package.json
var name = "eslint-plugin-react-naming-convention";
var version = "1.22.1";
var createRule = shared.createRuleForPlugin("naming-convention");

// src/rules/component-name.ts
var RULE_NAME = "component-name";
var defaultOptions = [
  {
    allowAllCaps: false,
    allowLeadingUnderscore: false,
    allowNamespace: false,
    excepts: [],
    rule: "PascalCase"
  }
];
var schema = [
  {
    anyOf: [
      {
        type: "string",
        enum: ["PascalCase", "CONSTANT_CASE"]
      },
      {
        type: "object",
        additionalProperties: false,
        properties: {
          allowAllCaps: { type: "boolean" },
          allowLeadingUnderscore: { type: "boolean" },
          allowNamespace: { type: "boolean" },
          excepts: {
            type: "array",
            items: { type: "string", format: "regex" }
          },
          rule: {
            type: "string",
            enum: ["PascalCase", "CONSTANT_CASE"]
          }
        }
      }
    ]
  }
];
function normalizeOptions(options) {
  const [opts] = options;
  if (eff.isNullable(opts)) return defaultOptions[0];
  if (eff.isString(opts)) return { ...defaultOptions[0], rule: opts };
  return {
    ...opts,
    excepts: opts.excepts?.map((pattern) => new RegExp(pattern, "u")) ?? []
  };
}
function validate(name2, options) {
  if (options.excepts.some((regex) => regex.test(name2))) return true;
  let normalized = name2.normalize("NFKD").replace(/[\u0300-\u036F]/g, "");
  normalized = normalized.split(".").at(-1) ?? normalized;
  if (options.allowNamespace) {
    normalized = normalized.replace(":", "");
  }
  if (options.allowLeadingUnderscore) {
    normalized = normalized.replace(/^_/, "");
  }
  return tsPattern.match(options.rule).with("CONSTANT_CASE", () => shared.RE_CONSTANT_CASE.test(normalized)).with("PascalCase", () => {
    if ([...normalized].length > 3 && /^[A-Z]+$/u.test(normalized)) return options.allowAllCaps;
    return shared.RE_PASCAL_CASE.test(normalized);
  }).otherwise(eff.F.constFalse);
}
var component_name_default = createRule({
  meta: {
    type: "problem",
    defaultOptions: [...defaultOptions],
    docs: {
      description: "enforce component naming convention to 'PascalCase' or 'CONSTANT_CASE'"
    },
    messages: {
      componentName: "A component name must be in {{case}}."
    },
    schema
  },
  name: RULE_NAME,
  create(context) {
    const options = normalizeOptions(context.options);
    const collector = core.useComponentCollector(context);
    const collectorLegacy = core.useComponentCollectorLegacy();
    return {
      ...collector.listeners,
      ...collectorLegacy.listeners,
      JSXOpeningElement(node) {
        const name2 = JSX__namespace.getElementName(node);
        if (/^[a-z]/u.test(name2)) return;
        if (validate(name2, options)) return;
        context.report({
          messageId: "componentName",
          node,
          data: {
            case: options.rule
          }
        });
      },
      "Program:exit"(node) {
        const functionComponents = collector.ctx.getAllComponents(node);
        const classComponents = collectorLegacy.ctx.getAllComponents(node);
        for (const { node: component } of functionComponents.values()) {
          const maybeId = AST__namespace.getFunctionIdentifier(component);
          if (eff.O.isNone(maybeId)) continue;
          const id = maybeId.value;
          const { name: name2 } = id;
          if (validate(name2, options)) continue;
          context.report({
            messageId: "componentName",
            node: id,
            data: {
              case: options.rule
            }
          });
        }
        for (const { node: component } of classComponents.values()) {
          const maybeId = AST__namespace.getClassIdentifier(component);
          if (eff.O.isNone(maybeId)) continue;
          const id = maybeId.value;
          const { name: name2 } = id;
          if (validate(name2, options)) continue;
          context.report({
            messageId: "componentName",
            node: id,
            data: {
              case: options.rule
            }
          });
        }
      }
    };
  },
  defaultOptions
});
var RULE_NAME2 = "filename";
var defaultOptions2 = [
  {
    excepts: ["^index$"],
    extensions: [".js", ".jsx", ".ts", ".tsx"],
    rule: "PascalCase"
  }
];
var schema2 = [
  {
    anyOf: [
      {
        type: "string",
        enum: ["PascalCase", "camelCase", "kebab-case", "snake_case"]
      },
      {
        type: "object",
        additionalProperties: false,
        properties: {
          excepts: {
            type: "array",
            items: { type: "string", format: "regex" }
          },
          extensions: {
            type: "array",
            items: { type: "string" },
            uniqueItems: true
          },
          rule: {
            type: "string",
            enum: ["PascalCase", "camelCase", "kebab-case", "snake_case"]
          }
        }
      }
    ]
  }
];
var filename_default = createRule({
  meta: {
    type: "problem",
    defaultOptions: [...defaultOptions2],
    docs: {
      description: "enforce naming convention for JSX filenames"
    },
    messages: {
      // filenameCaseMismatch: "A file with name '{{name}}' does not match {{rule}}.",
      filenameCaseMismatchSuggestion: "A file with name '{{name}}' does not match {{rule}}. Should rename to '{{suggestion}}'.",
      filenameEmpty: "A file must have non-empty name."
    },
    schema: schema2
  },
  name: RULE_NAME2,
  create(context) {
    const options = context.options[0] ?? defaultOptions2[0];
    const rule = eff.isString(options) ? options : options.rule ?? "PascalCase";
    const excepts = eff.isString(options) ? [] : options.excepts ?? [];
    const filename = context.filename;
    function validate2(name2, casing = rule, ignores = excepts) {
      if (ignores.map((pattern) => new RegExp(pattern, "u")).some((pattern) => pattern.test(name2))) {
        return true;
      }
      return tsPattern.match(casing).with("PascalCase", () => shared.RE_PASCAL_CASE.test(name2)).with("camelCase", () => shared.RE_CAMEL_CASE.test(name2)).with("kebab-case", () => shared.RE_KEBAB_CASE.test(name2)).with("snake_case", () => shared.RE_SNAKE_CASE.test(name2)).exhaustive();
    }
    function getSuggestion(name2, casing = rule) {
      return tsPattern.match(casing).with("PascalCase", () => stringTs.pascalCase(name2)).with("camelCase", () => stringTs.camelCase(name2)).with("kebab-case", () => stringTs.kebabCase(name2)).with("snake_case", () => stringTs.snakeCase(name2)).exhaustive();
    }
    return {
      Program(node) {
        const [basename = "", ...rest] = path__default.default.basename(context.filename).split(".");
        if (basename.length === 0) {
          context.report({ messageId: "filenameEmpty", node });
          return;
        }
        if (validate2(basename)) return;
        context.report({
          messageId: "filenameCaseMismatchSuggestion",
          node,
          data: {
            name: filename,
            rule,
            suggestion: [getSuggestion(basename), ...rest].join(".")
          }
        });
      }
    };
  },
  defaultOptions: defaultOptions2
});
var RULE_NAME3 = "filename-extension";
var defaultOptions3 = [{
  allow: "as-needed",
  extensions: [".jsx", ".tsx"],
  ignoreFilesWithoutCode: false
}];
var schema3 = [
  {
    anyOf: [
      {
        type: "string",
        enum: ["always", "as-needed"]
      },
      {
        type: "object",
        additionalProperties: false,
        properties: {
          allow: {
            type: "string",
            enum: ["always", "as-needed"]
          },
          extensions: {
            type: "array",
            items: {
              type: "string"
            },
            uniqueItems: true
          },
          ignoreFilesWithoutCode: {
            type: "boolean"
          }
        }
      }
    ]
  }
];
var filename_extension_default = createRule({
  meta: {
    type: "problem",
    defaultOptions: [...defaultOptions3],
    docs: {
      description: "enforce naming convention for JSX file extensions"
    },
    messages: {
      filenameExtensionInvalid: "The JSX file extension is required.",
      filenameExtensionUnexpected: "Use JSX file extension as needed."
    },
    schema: schema3
  },
  name: RULE_NAME3,
  create(context) {
    const options = context.options[0] ?? defaultOptions3[0];
    const allow = eff.isObject(options) ? options.allow : options;
    const extensions = eff.isObject(options) && "extensions" in options ? options.extensions : defaultOptions3[0].extensions;
    const filename = context.filename;
    const hasJSXNodeRef = eff.MutRef.make(false);
    return {
      JSXElement() {
        eff.MutRef.set(hasJSXNodeRef, true);
      },
      JSXFragment() {
        eff.MutRef.set(hasJSXNodeRef, true);
      },
      "Program:exit"(node) {
        const fileNameExt = filename.slice(filename.lastIndexOf("."));
        const isJSXExt = extensions.includes(fileNameExt);
        const hasJSXCode = eff.MutRef.get(hasJSXNodeRef);
        if (hasJSXCode && !isJSXExt) {
          context.report({
            messageId: "filenameExtensionInvalid",
            node
          });
          return;
        }
        const hasCode = node.body.length > 0;
        const ignoreFilesWithoutCode = eff.isObject(options) && options.ignoreFilesWithoutCode;
        if (!hasCode && ignoreFilesWithoutCode) return;
        if (!hasJSXCode && isJSXExt && allow === "as-needed") {
          context.report({
            messageId: "filenameExtensionUnexpected",
            node
          });
        }
      }
    };
  },
  defaultOptions: defaultOptions3
});
var RULE_NAME4 = "use-state";
var RULE_FEATURES = [
  "CHK"
];
function isSetterNameLoose(name2) {
  const fourthChar = [...name2][3];
  return name2.startsWith("set") && fourthChar === fourthChar?.toUpperCase();
}
var use_state_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce destructuring and symmetric naming of 'useState' hook value and setter variables",
      [Symbol.for("rule_features")]: RULE_FEATURES
    },
    messages: {
      useState: "An useState call is not destructured into value + setter pair."
    },
    schema: []
  },
  name: RULE_NAME4,
  create(context) {
    const alias = shared.decodeSettings(context.settings).additionalHooks?.useState ?? [];
    const { ctx, listeners } = core.useComponentCollector(context);
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { hookCalls } of components.values()) {
          if (hookCalls.length === 0) continue;
          for (const hookCall of hookCalls) {
            if (!core.isUseStateCall(hookCall, context) && !alias.some(core.isReactHookCallWithNameLoose(hookCall))) {
              continue;
            }
            if (hookCall.parent.type !== types.AST_NODE_TYPES.VariableDeclarator) {
              continue;
            }
            const { id } = hookCall.parent;
            const descriptor = eff.O.some({ messageId: "useState", node: id });
            eff.F.pipe(
              tsPattern.match(id).with({ type: types.AST_NODE_TYPES.Identifier }, eff.F.constant(descriptor)).with({ type: types.AST_NODE_TYPES.ArrayPattern }, (n) => {
                const [state, setState] = n.elements;
                if (state?.type === types.AST_NODE_TYPES.ObjectPattern && setState?.type === types.AST_NODE_TYPES.Identifier) {
                  return isSetterNameLoose(setState.name) ? eff.O.none() : descriptor;
                }
                if (state?.type !== types.AST_NODE_TYPES.Identifier || setState?.type !== types.AST_NODE_TYPES.Identifier) {
                  return eff.O.none();
                }
                const [stateName, setStateName] = [state.name, setState.name];
                const expectedSetterName = `set${stringTs.capitalize(stateName)}`;
                if (setStateName === expectedSetterName) return eff.O.none();
                return descriptor;
              }).otherwise(eff.O.none),
              eff.O.map(context.report)
            );
          }
        }
      }
    };
  },
  defaultOptions: []
});

// src/index.ts
var index_default = {
  meta: {
    name,
    version
  },
  rules: {
    "component-name": component_name_default,
    filename: filename_default,
    "filename-extension": filename_extension_default,
    "use-state": use_state_default
  }
};

module.exports = index_default;
