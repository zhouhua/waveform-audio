'use strict';

var eff = require('@eslint-react/eff');
var types = require('@typescript-eslint/types');
var utils = require('@typescript-eslint/utils');
var tsPattern = require('ts-pattern');
var typescriptEstree = require('@typescript-eslint/typescript-estree');
var types$1 = require('@eslint-react/types');
var stringTs = require('string-ts');

// src/function-init-path.ts
function getFunctionInitPath(node) {
  const { parent } = node;
  if (node.type === types.AST_NODE_TYPES.FunctionDeclaration) return eff.O.some([node]);
  if (parent.type === types.AST_NODE_TYPES.VariableDeclarator) {
    return eff.O.some([
      parent.parent,
      parent,
      node
    ]);
  }
  if (parent.type === types.AST_NODE_TYPES.CallExpression && parent.parent.type === types.AST_NODE_TYPES.VariableDeclarator) {
    return eff.O.some([
      parent.parent.parent,
      parent.parent,
      parent,
      node
    ]);
  }
  if (parent.type === types.AST_NODE_TYPES.CallExpression && parent.parent.type === types.AST_NODE_TYPES.CallExpression && parent.parent.parent.type === types.AST_NODE_TYPES.VariableDeclarator) {
    return eff.O.some([
      parent.parent.parent.parent,
      parent.parent.parent,
      parent.parent,
      parent,
      node
    ]);
  }
  if (parent.type === types.AST_NODE_TYPES.Property && parent.parent.type === types.AST_NODE_TYPES.ObjectExpression && parent.parent.parent.type === types.AST_NODE_TYPES.VariableDeclarator) {
    return eff.O.some([
      parent.parent.parent.parent,
      parent.parent.parent,
      parent.parent,
      parent,
      node
    ]);
  }
  if (parent.type === types.AST_NODE_TYPES.MethodDefinition && parent.parent.parent.type === types.AST_NODE_TYPES.ClassDeclaration) {
    return eff.O.some([
      parent.parent.parent,
      parent.parent,
      parent,
      node
    ]);
  }
  if (parent.type === types.AST_NODE_TYPES.PropertyDefinition && parent.parent.parent.type === types.AST_NODE_TYPES.ClassDeclaration) {
    return eff.O.some([
      parent.parent.parent,
      parent.parent,
      parent,
      node
    ]);
  }
  return eff.O.none();
}
function hasCallInFunctionInitPath(callName) {
  return (initPath) => {
    return eff.F.pipe(
      initPath,
      eff.O.filter((p) => p.length > 0),
      eff.O.exists((nodes) => {
        return nodes.some(
          // TODO: Re-evaluate dot notation callName
          // callName.includes(".")
          //   ? n => {
          //     const [objectName, propertyName] = callName.split(".");
          //     return "callee" in n
          //       && n.callee.type === AST_NODE_TYPES.MemberExpression
          //       && n.callee.object.type === AST_NODE_TYPES.Identifier
          //       && n.callee.object.name === objectName
          //       && n.callee.property.type === AST_NODE_TYPES.Identifier
          //       && n.callee.property.name === propertyName;
          //   }
          //   : n => {
          //     return "callee" in n
          //       && n.callee.type === AST_NODE_TYPES.Identifier
          //       && n.callee.name === callName;
          //   },
          (n) => {
            if (n.type !== types.AST_NODE_TYPES.CallExpression) return false;
            if (n.callee.type === types.AST_NODE_TYPES.Identifier) return n.callee.name === callName;
            return "property" in n.callee && "name" in n.callee.property && n.callee.property.name === callName;
          }
        );
      })
    );
  };
}
function getClassIdentifier(node) {
  if (node.id) return eff.O.fromNullable(node.id);
  if (node.parent.type === types.AST_NODE_TYPES.VariableDeclarator && node.parent.id.type === types.AST_NODE_TYPES.Identifier) {
    return eff.O.fromNullable(node.parent.id);
  }
  return eff.O.none();
}
var is = utils.ASTUtils.isNodeOfType;
var isOneOf = utils.ASTUtils.isNodeOfTypes;
var isFunction = isOneOf([
  types.AST_NODE_TYPES.ArrowFunctionExpression,
  types.AST_NODE_TYPES.FunctionDeclaration,
  types.AST_NODE_TYPES.FunctionExpression
]);
var isFunctionType = isOneOf([
  types.AST_NODE_TYPES.ArrowFunctionExpression,
  types.AST_NODE_TYPES.FunctionDeclaration,
  types.AST_NODE_TYPES.FunctionExpression,
  types.AST_NODE_TYPES.TSCallSignatureDeclaration,
  types.AST_NODE_TYPES.TSConstructSignatureDeclaration,
  types.AST_NODE_TYPES.TSDeclareFunction,
  types.AST_NODE_TYPES.TSEmptyBodyFunctionExpression,
  types.AST_NODE_TYPES.TSFunctionType,
  types.AST_NODE_TYPES.TSMethodSignature
]);
var isClass = isOneOf([types.AST_NODE_TYPES.ClassDeclaration, types.AST_NODE_TYPES.ClassExpression]);
var isLoop = isOneOf([
  types.AST_NODE_TYPES.DoWhileStatement,
  types.AST_NODE_TYPES.ForInStatement,
  types.AST_NODE_TYPES.ForOfStatement,
  types.AST_NODE_TYPES.ForStatement,
  types.AST_NODE_TYPES.WhileStatement
]);
var isControlFlow = eff.or(
  isLoop,
  isOneOf([
    types.AST_NODE_TYPES.IfStatement,
    types.AST_NODE_TYPES.SwitchStatement
  ])
);
var isConditional = eff.or(
  isControlFlow,
  isOneOf([
    types.AST_NODE_TYPES.LogicalExpression,
    types.AST_NODE_TYPES.ConditionalExpression
  ])
);
var isArrayTupleType = isOneOf([types.AST_NODE_TYPES.TSArrayType, types.AST_NODE_TYPES.TSTupleType]);
var isProperty = isOneOf([
  types.AST_NODE_TYPES.PropertyDefinition,
  types.AST_NODE_TYPES.TSIndexSignature,
  types.AST_NODE_TYPES.TSParameterProperty,
  types.AST_NODE_TYPES.TSPropertySignature
]);
var isJSXElement = is(types.AST_NODE_TYPES.JSXElement);
var isJSXFragment = is(types.AST_NODE_TYPES.JSXFragment);
var isJSX = isOneOf([
  types.AST_NODE_TYPES.JSXAttribute,
  types.AST_NODE_TYPES.JSXSpreadChild,
  types.AST_NODE_TYPES.JSXClosingElement,
  types.AST_NODE_TYPES.JSXClosingFragment,
  types.AST_NODE_TYPES.JSXElement,
  types.AST_NODE_TYPES.JSXEmptyExpression,
  types.AST_NODE_TYPES.JSXExpressionContainer,
  types.AST_NODE_TYPES.JSXFragment,
  types.AST_NODE_TYPES.JSXIdentifier,
  types.AST_NODE_TYPES.JSXMemberExpression,
  types.AST_NODE_TYPES.JSXNamespacedName,
  types.AST_NODE_TYPES.JSXOpeningElement,
  types.AST_NODE_TYPES.JSXOpeningFragment,
  types.AST_NODE_TYPES.JSXSpreadAttribute,
  types.AST_NODE_TYPES.JSXSpreadChild,
  types.AST_NODE_TYPES.JSXText
]);
var isJSXTagNameExpression = isOneOf([
  types.AST_NODE_TYPES.JSXIdentifier,
  types.AST_NODE_TYPES.JSXMemberExpression,
  types.AST_NODE_TYPES.JSXNamespacedName
]);
var isDestructuringPattern = isOneOf([
  types.AST_NODE_TYPES.ArrayPattern,
  types.AST_NODE_TYPES.AssignmentPattern,
  types.AST_NODE_TYPES.ObjectPattern,
  types.AST_NODE_TYPES.RestElement
]);
var isTypeDeclaration = isOneOf([
  types.AST_NODE_TYPES.TSInterfaceDeclaration,
  types.AST_NODE_TYPES.TSTypeAliasDeclaration
]);
var isLeftHandSideExpression = isOneOf([
  types.AST_NODE_TYPES.ArrayExpression,
  types.AST_NODE_TYPES.ArrayPattern,
  types.AST_NODE_TYPES.ArrowFunctionExpression,
  types.AST_NODE_TYPES.CallExpression,
  types.AST_NODE_TYPES.ClassExpression,
  types.AST_NODE_TYPES.FunctionExpression,
  types.AST_NODE_TYPES.Identifier,
  types.AST_NODE_TYPES.JSXElement,
  types.AST_NODE_TYPES.JSXFragment,
  types.AST_NODE_TYPES.Literal,
  types.AST_NODE_TYPES.TemplateLiteral,
  types.AST_NODE_TYPES.MemberExpression,
  types.AST_NODE_TYPES.MetaProperty,
  types.AST_NODE_TYPES.ObjectExpression,
  types.AST_NODE_TYPES.ObjectPattern,
  types.AST_NODE_TYPES.SequenceExpression,
  types.AST_NODE_TYPES.Super,
  types.AST_NODE_TYPES.TaggedTemplateExpression,
  types.AST_NODE_TYPES.ThisExpression
]);
var isLeftHandSideExpressionType = isOneOf([
  types.AST_NODE_TYPES.ArrayExpression,
  types.AST_NODE_TYPES.ArrayPattern,
  types.AST_NODE_TYPES.ArrowFunctionExpression,
  types.AST_NODE_TYPES.CallExpression,
  types.AST_NODE_TYPES.ClassExpression,
  types.AST_NODE_TYPES.FunctionExpression,
  types.AST_NODE_TYPES.Identifier,
  types.AST_NODE_TYPES.JSXElement,
  types.AST_NODE_TYPES.JSXFragment,
  types.AST_NODE_TYPES.Literal,
  types.AST_NODE_TYPES.TemplateLiteral,
  types.AST_NODE_TYPES.MemberExpression,
  types.AST_NODE_TYPES.MetaProperty,
  types.AST_NODE_TYPES.ObjectExpression,
  types.AST_NODE_TYPES.ObjectPattern,
  types.AST_NODE_TYPES.SequenceExpression,
  types.AST_NODE_TYPES.Super,
  types.AST_NODE_TYPES.TaggedTemplateExpression,
  types.AST_NODE_TYPES.ThisExpression,
  types.AST_NODE_TYPES.TSAsExpression,
  types.AST_NODE_TYPES.TSNonNullExpression,
  types.AST_NODE_TYPES.TSTypeAssertion
]);

// src/get-function-identifier.ts
function getFunctionIdentifier(node) {
  switch (true) {
    // function MaybeComponent() {}
    case ("id" in node && !!node.id):
      return eff.O.some(node.id);
    // const whatever = function MaybeComponent() {};
    case (node.parent.type === types.AST_NODE_TYPES.VariableDeclarator && node.parent.init === node && node.parent.id.type === types.AST_NODE_TYPES.Identifier):
      return eff.O.some(node.parent.id);
    // MaybeComponent = () => {};
    case (node.parent.type === types.AST_NODE_TYPES.AssignmentExpression && node.parent.right === node && node.parent.operator === "=" && node.parent.left.type === types.AST_NODE_TYPES.Identifier):
      return eff.O.some(node.parent.left);
    // {MaybeComponent: () => {}}
    // {MaybeComponent() {}}
    case (node.parent.type === types.AST_NODE_TYPES.Property && node.parent.value === node && !node.parent.computed && node.parent.key.type === types.AST_NODE_TYPES.Identifier):
      return eff.O.some(node.parent.key);
    // class {MaybeComponent = () => {}}
    // class {MaybeComponent() {}}
    case (isOneOf([types.AST_NODE_TYPES.MethodDefinition, types.AST_NODE_TYPES.PropertyDefinition])(node.parent) && node.parent.value === node && node.parent.key.type === types.AST_NODE_TYPES.Identifier):
      return eff.O.some(node.parent.key);
    // Follow spec convention for `IsAnonymousFunctionDefinition()` usage.
    //
    // const {MaybeComponent = () => {}} = {};
    // ({MaybeComponent = () => {}} = {});
    case (node.parent.type === types.AST_NODE_TYPES.AssignmentPattern && node.parent.right === node && node.parent.left.type === types.AST_NODE_TYPES.Identifier):
      return eff.O.some(node.parent.left);
    // const MaybeComponent = (() => {}) as FunctionComponent;
    // const MaybeComponent = (() => {}) satisfies FunctionComponent;
    case isOneOf([types.AST_NODE_TYPES.TSAsExpression, types.AST_NODE_TYPES.TSSatisfiesExpression])(node.parent):
      return getFunctionIdentifier(node.parent);
  }
  return eff.O.none();
}
function getIdentifiersFromBinaryExpression(side) {
  if (side.type === types.AST_NODE_TYPES.Identifier) return [side];
  if (side.type === types.AST_NODE_TYPES.BinaryExpression) {
    return [
      ...getIdentifiersFromBinaryExpression(side.left),
      ...getIdentifiersFromBinaryExpression(side.right)
    ];
  }
  return [];
}
function getLiteralValueType(input) {
  return tsPattern.match(input).with(null, () => "Null").with(tsPattern.P.boolean, () => "Boolean").with(tsPattern.P.number, () => "Number").with(tsPattern.P.string, () => "String").with(tsPattern.P.bigint, () => "BigInt").with(tsPattern.P.symbol, () => "Symbol").exhaustive();
}
function getNestedExpressionsOfType(type) {
  const isNodeOfType = utils.ASTUtils.isNodeOfType(type);
  return function(node) {
    const boundGetNestedExpressionsOfType = getNestedExpressionsOfType(type);
    const expressions = [];
    if (isNodeOfType(node)) {
      expressions.push(node);
    }
    if ("arguments" in node) {
      const chunk = node.arguments.map(getNestedExpressionsOfType(type)).flat(1);
      expressions.push(...chunk);
    }
    if ("expression" in node && node.expression !== true && node.expression !== false) {
      const chunk = boundGetNestedExpressionsOfType(node.expression);
      expressions.push(...chunk);
    }
    if ("left" in node) {
      const chunk = boundGetNestedExpressionsOfType(node.left);
      expressions.push(...chunk);
    }
    if ("right" in node) {
      const chunk = boundGetNestedExpressionsOfType(node.right);
      expressions.push(...chunk);
    }
    if ("test" in node && node.test !== null) {
      const chunk = boundGetNestedExpressionsOfType(node.test);
      expressions.push(...chunk);
    }
    if ("consequent" in node) {
      const chunk = Array.isArray(node.consequent) ? node.consequent.map(boundGetNestedExpressionsOfType).flat(1) : boundGetNestedExpressionsOfType(node.consequent);
      expressions.push(...chunk);
    }
    if ("alternate" in node && node.alternate !== null) {
      const chunk = Array.isArray(node.alternate) ? node.alternate.map(boundGetNestedExpressionsOfType).flat(1) : boundGetNestedExpressionsOfType(node.alternate);
      expressions.push(...chunk);
    }
    if ("elements" in node) {
      const chunk = node.elements.filter((x) => x !== null).map(getNestedExpressionsOfType(type)).flat(1);
      expressions.push(...chunk);
    }
    if ("properties" in node) {
      const chunk = node.properties.map(boundGetNestedExpressionsOfType).flat(1);
      expressions.push(...chunk);
    }
    if ("expressions" in node) {
      const chunk = node.expressions.map(boundGetNestedExpressionsOfType).flat(1);
      expressions.push(...chunk);
    }
    if (node.type === typescriptEstree.AST_NODE_TYPES.Property) {
      const chunk = boundGetNestedExpressionsOfType(node.value);
      expressions.push(...chunk);
    }
    if (node.type === typescriptEstree.AST_NODE_TYPES.SpreadElement) {
      const chunk = boundGetNestedExpressionsOfType(node.argument);
      expressions.push(...chunk);
    }
    if (node.type === typescriptEstree.AST_NODE_TYPES.MemberExpression) {
      const chunk = boundGetNestedExpressionsOfType(node.object);
      expressions.push(...chunk);
    }
    if (node.type === typescriptEstree.AST_NODE_TYPES.UnaryExpression) {
      const chunk = boundGetNestedExpressionsOfType(node.argument);
      expressions.push(...chunk);
    }
    if (node.type === typescriptEstree.AST_NODE_TYPES.ChainExpression) {
      const chunk = boundGetNestedExpressionsOfType(node.expression);
      expressions.push(...chunk);
    }
    if (node.type === typescriptEstree.AST_NODE_TYPES.TSNonNullExpression) {
      const chunk = boundGetNestedExpressionsOfType(node.expression);
      expressions.push(...chunk);
    }
    return expressions;
  };
}

// src/get-nested-call-expressions.ts
var getNestedCallExpressions = getNestedExpressionsOfType(typescriptEstree.AST_NODE_TYPES.CallExpression);
function getNestedIdentifiers(node) {
  const identifiers = [];
  if (node.type === types.AST_NODE_TYPES.Identifier) {
    identifiers.push(node);
  }
  if ("arguments" in node) {
    const chunk = node.arguments.map(getNestedIdentifiers).flat(1);
    identifiers.push(...chunk);
  }
  if ("elements" in node) {
    const chunk = node.elements.filter((x) => x !== null).map(getNestedIdentifiers).flat(1);
    identifiers.push(...chunk);
  }
  if ("properties" in node) {
    const chunk = node.properties.map(getNestedIdentifiers).flat(1);
    identifiers.push(...chunk);
  }
  if ("expressions" in node) {
    const chunk = node.expressions.map(getNestedIdentifiers).flat(1);
    identifiers.push(...chunk);
  }
  if ("left" in node) {
    const chunk = getNestedIdentifiers(node.left);
    identifiers.push(...chunk);
  }
  if ("right" in node) {
    const chunk = getNestedIdentifiers(node.right);
    identifiers.push(...chunk);
  }
  if (node.type === types.AST_NODE_TYPES.Property) {
    const chunk = getNestedIdentifiers(node.value);
    identifiers.push(...chunk);
  }
  if (node.type === types.AST_NODE_TYPES.SpreadElement) {
    const chunk = getNestedIdentifiers(node.argument);
    identifiers.push(...chunk);
  }
  if (node.type === types.AST_NODE_TYPES.MemberExpression) {
    const chunk = getNestedIdentifiers(node.object);
    identifiers.push(...chunk);
  }
  if (node.type === types.AST_NODE_TYPES.UnaryExpression) {
    const chunk = getNestedIdentifiers(node.argument);
    identifiers.push(...chunk);
  }
  if (node.type === types.AST_NODE_TYPES.ChainExpression) {
    const chunk = getNestedIdentifiers(node.expression);
    identifiers.push(...chunk);
  }
  if (node.type === types.AST_NODE_TYPES.TSNonNullExpression) {
    const chunk = getNestedIdentifiers(node.expression);
    identifiers.push(...chunk);
  }
  return identifiers;
}
var getNestedNewExpressions = getNestedExpressionsOfType(typescriptEstree.AST_NODE_TYPES.NewExpression);
var traverseUpGuard = eff.F.dual(2, (node, predicate) => {
  const { parent } = node;
  if (!parent || parent.type === types.AST_NODE_TYPES.Program) return eff.O.none();
  return predicate(parent) ? eff.O.some(parent) : traverseUpGuard(parent, predicate);
});

// src/get-nested-return-statements.ts
function getNestedReturnStatements(node) {
  const returnStatements = [];
  const functionNode = isFunction(node) ? node : eff.O.getOrNull(traverseUpGuard(node, isFunction));
  typescriptEstree.simpleTraverse(node, {
    enter(node2) {
      if (node2.type !== types.AST_NODE_TYPES.ReturnStatement) return;
      const parentFunction = eff.O.getOrNull(traverseUpGuard(node2, isFunction));
      if (parentFunction !== functionNode) return;
      returnStatements.push(node2);
    }
  });
  return returnStatements;
}
function getTopLevelIdentifier(node) {
  switch (node.type) {
    case types.AST_NODE_TYPES.Identifier:
      return eff.O.some(node);
    case types.AST_NODE_TYPES.MemberExpression:
      return getTopLevelIdentifier(node.object);
    default:
      return eff.O.none();
  }
}
function isEmptyFunction(node) {
  return node.body.type === types.AST_NODE_TYPES.BlockStatement && node.body.body.length === 0;
}
var isFunctionOfClassMethod = tsPattern.isMatching({
  type: tsPattern.P.union([types.AST_NODE_TYPES.FunctionExpression, types.AST_NODE_TYPES.ArrowFunctionExpression]),
  parent: {
    type: types.AST_NODE_TYPES.MethodDefinition,
    parent: {
      type: types.AST_NODE_TYPES.ClassBody
    }
  }
});
var isFunctionOfClassProperty = tsPattern.isMatching({
  type: tsPattern.P.union([types.AST_NODE_TYPES.FunctionExpression, types.AST_NODE_TYPES.ArrowFunctionExpression]),
  parent: {
    type: types.AST_NODE_TYPES.Property,
    parent: {
      type: types.AST_NODE_TYPES.ClassBody
    }
  }
});
function isFunctionOfImmediatelyInvoked(node) {
  return node.type !== types.AST_NODE_TYPES.FunctionDeclaration && node.parent.type === types.AST_NODE_TYPES.CallExpression && node.parent.callee === node;
}
var isFunctionOfObjectMethod = tsPattern.isMatching({
  type: tsPattern.P.union([types.AST_NODE_TYPES.FunctionExpression, types.AST_NODE_TYPES.ArrowFunctionExpression]),
  parent: {
    type: types.AST_NODE_TYPES.Property,
    parent: {
      type: types.AST_NODE_TYPES.ObjectExpression
    }
  }
});
function isKeyLiteralLike(node, property) {
  return tsPattern.match(property).with({ type: types.AST_NODE_TYPES.Literal }, eff.F.constTrue).with({ type: types.AST_NODE_TYPES.TemplateLiteral, expressions: [] }, eff.F.constTrue).with({ type: types.AST_NODE_TYPES.Identifier }, () => !node.computed).otherwise(eff.F.constFalse);
}
function isMapCallLoose(node) {
  if (node.type !== types.AST_NODE_TYPES.CallExpression) return false;
  if (node.callee.type !== types.AST_NODE_TYPES.MemberExpression) return false;
  if (node.callee.property.type !== types.AST_NODE_TYPES.Identifier) return false;
  const { name } = node.callee.property;
  return name === "map" || name.endsWith("Map");
}

// src/is-multi-line.ts
function isMultiLine(node) {
  return node.loc.start.line !== node.loc.end.line;
}
var isNodeEqual = eff.F.dual(2, (a, b) => {
  if (a.type !== b.type) return false;
  if (a.type === types.AST_NODE_TYPES.ThisExpression && b.type === types.AST_NODE_TYPES.ThisExpression) return true;
  if (a.type === types.AST_NODE_TYPES.Literal && b.type === types.AST_NODE_TYPES.Literal) return a.value === b.value;
  if (a.type === types.AST_NODE_TYPES.TemplateElement && b.type === types.AST_NODE_TYPES.TemplateElement) {
    return a.value.raw === b.value.raw;
  }
  if (a.type === types.AST_NODE_TYPES.TemplateLiteral && b.type === types.AST_NODE_TYPES.TemplateLiteral) {
    if (a.quasis.length !== b.quasis.length || a.expressions.length !== b.expressions.length) return false;
    if (!types$1.zip(a.quasis, b.quasis).every(([a2, b2]) => isNodeEqual(a2, b2))) return false;
    if (!types$1.zip(a.expressions, b.expressions).every(([a2, b2]) => isNodeEqual(a2, b2))) return false;
    return true;
  }
  if (a.type === types.AST_NODE_TYPES.Identifier && b.type === types.AST_NODE_TYPES.Identifier) return a.name === b.name;
  if (a.type === types.AST_NODE_TYPES.PrivateIdentifier && b.type === types.AST_NODE_TYPES.PrivateIdentifier) {
    return a.name === b.name;
  }
  if (a.type === types.AST_NODE_TYPES.MemberExpression && b.type === types.AST_NODE_TYPES.MemberExpression) {
    return isNodeEqual(a.property, b.property) && isNodeEqual(a.object, b.object);
  }
  return false;
});
function isRegExpLiteral(node) {
  return node.type === types.AST_NODE_TYPES.Literal && "regex" in node;
}
function isStringLiteral(node) {
  return node.type === types.AST_NODE_TYPES.Literal && eff.isString(node.value);
}
function isThisExpression(node) {
  if (node.type === types.AST_NODE_TYPES.TSAsExpression) {
    return isThisExpression(node.expression);
  }
  return node.type === types.AST_NODE_TYPES.ThisExpression;
}
function toReadableNodeName(node, getText) {
  switch (node.type) {
    case types.AST_NODE_TYPES.CallExpression:
      return toReadableNodeName(node.callee, getText);
    case types.AST_NODE_TYPES.Identifier:
      return node.name;
    case types.AST_NODE_TYPES.JSXIdentifier:
      return `<${node.name}>`;
    case types.AST_NODE_TYPES.JSXMemberExpression:
      return `${toReadableNodeName(node.object, getText)}.${toReadableNodeName(node.property, getText)}`;
    case types.AST_NODE_TYPES.JSXNamespacedName:
      return `${node.namespace.name}:${node.name.name}`;
    case types.AST_NODE_TYPES.JSXText:
      return node.value;
    case types.AST_NODE_TYPES.Literal:
      return node.raw;
    case types.AST_NODE_TYPES.MemberExpression:
      return `${toReadableNodeName(node.object, getText)}.${toReadableNodeName(node.property, getText)}`;
    default:
      return getText(node);
  }
}
function toReadableNodeType(node) {
  if (node.type === types.AST_NODE_TYPES.Literal) {
    if ("regex" in node) return "RegExp literal";
    return `${getLiteralValueType(node.value)} literal`;
  }
  if (isJSX(node)) return `JSX ${stringTs.toLowerCase(stringTs.delimiterCase(stringTs.replace(node.type, "JSX", ""), " "))}`;
  return stringTs.toLowerCase(stringTs.delimiterCase(node.type, " "));
}
var traverseUp = eff.F.dual(2, (node, predicate) => {
  const { parent } = node;
  if (!parent || parent.type === types.AST_NODE_TYPES.Program) return eff.O.none();
  return predicate(parent) ? eff.O.some(parent) : traverseUp(parent, predicate);
});

exports.getClassIdentifier = getClassIdentifier;
exports.getFunctionIdentifier = getFunctionIdentifier;
exports.getFunctionInitPath = getFunctionInitPath;
exports.getIdentifiersFromBinaryExpression = getIdentifiersFromBinaryExpression;
exports.getLiteralValueType = getLiteralValueType;
exports.getNestedCallExpressions = getNestedCallExpressions;
exports.getNestedIdentifiers = getNestedIdentifiers;
exports.getNestedNewExpressions = getNestedNewExpressions;
exports.getNestedReturnStatements = getNestedReturnStatements;
exports.getTopLevelIdentifier = getTopLevelIdentifier;
exports.hasCallInFunctionInitPath = hasCallInFunctionInitPath;
exports.is = is;
exports.isArrayTupleType = isArrayTupleType;
exports.isClass = isClass;
exports.isConditional = isConditional;
exports.isControlFlow = isControlFlow;
exports.isDestructuringPattern = isDestructuringPattern;
exports.isEmptyFunction = isEmptyFunction;
exports.isFunction = isFunction;
exports.isFunctionOfClassMethod = isFunctionOfClassMethod;
exports.isFunctionOfClassProperty = isFunctionOfClassProperty;
exports.isFunctionOfImmediatelyInvoked = isFunctionOfImmediatelyInvoked;
exports.isFunctionOfObjectMethod = isFunctionOfObjectMethod;
exports.isFunctionType = isFunctionType;
exports.isJSX = isJSX;
exports.isJSXElement = isJSXElement;
exports.isJSXFragment = isJSXFragment;
exports.isJSXTagNameExpression = isJSXTagNameExpression;
exports.isKeyLiteralLike = isKeyLiteralLike;
exports.isLeftHandSideExpression = isLeftHandSideExpression;
exports.isLeftHandSideExpressionType = isLeftHandSideExpressionType;
exports.isLoop = isLoop;
exports.isMapCallLoose = isMapCallLoose;
exports.isMultiLine = isMultiLine;
exports.isNodeEqual = isNodeEqual;
exports.isOneOf = isOneOf;
exports.isProperty = isProperty;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isStringLiteral = isStringLiteral;
exports.isThisExpression = isThisExpression;
exports.isTypeDeclaration = isTypeDeclaration;
exports.toReadableNodeName = toReadableNodeName;
exports.toReadableNodeType = toReadableNodeType;
exports.traverseUp = traverseUp;
exports.traverseUpGuard = traverseUpGuard;
