import { O } from '@eslint-react/eff';
import { TSESTree as TSESTree$1, AST_NODE_TYPES as AST_NODE_TYPES$1 } from '@typescript-eslint/types';
import { TSESTree } from '@typescript-eslint/utils';
import { SyntaxKind } from 'typescript';
import * as effect_Predicate from 'effect/Predicate';

type TSESTreeFunction = TSESTree.ArrowFunctionExpression | TSESTree.FunctionDeclaration | TSESTree.FunctionExpression;
type TSESTreeFunctionType = TSESTree.TSCallSignatureDeclaration | TSESTree.TSConstructSignatureDeclaration | TSESTree.TSDeclareFunction | TSESTree.TSEmptyBodyFunctionExpression | TSESTree.TSFunctionType | TSESTree.TSMethodSignature | TSESTreeFunction;
type TSESTreeClass = TSESTree.ClassDeclaration | TSESTree.ClassExpression;
type TSESTreeLoop = TSESTree.DoWhileStatement | TSESTree.ForInStatement | TSESTree.ForOfStatement | TSESTree.ForStatement | TSESTree.WhileStatement;
type TSESTreeArrayTupleType = TSESTree.TSArrayType | TSESTree.TSTupleType;
type TSESTreeProperty = TSESTree.PropertyDefinition | TSESTree.TSIndexSignature | TSESTree.TSParameterProperty | TSESTree.TSPropertySignature;
type TSESTreeJSX = TSESTree.JSXAttribute | TSESTree.JSXChild | TSESTree.JSXClosingElement | TSESTree.JSXClosingFragment | TSESTree.JSXElement | TSESTree.JSXEmptyExpression | TSESTree.JSXExpression | TSESTree.JSXExpressionContainer | TSESTree.JSXFragment | TSESTree.JSXIdentifier | TSESTree.JSXIdentifierToken | TSESTree.JSXMemberExpression | TSESTree.JSXNamespacedName | TSESTree.JSXOpeningElement | TSESTree.JSXOpeningFragment | TSESTree.JSXSpreadAttribute | TSESTree.JSXSpreadChild | TSESTree.JSXTagNameExpression | TSESTree.JSXText | TSESTree.JSXTextToken;
type TSESTreeDestructuringPattern = TSESTree.ArrayPattern | TSESTree.AssignmentPattern | TSESTree.ObjectPattern | TSESTree.RestElement;
type TSESTreeTypeDeclaration = TSESTree.TSInterfaceDeclaration | TSESTree.TSTypeAliasDeclaration;

type FunctionInitPath = 
/**
 * function Comp() { return <div />; }
 */
readonly [TSESTree$1.FunctionDeclaration]
/**
 * const Comp = () => <div />;
 * const Comp = function () { return <div />; };
 */
 | readonly [
    TSESTree$1.VariableDeclaration,
    TSESTree$1.VariableDeclarator,
    TSESTreeFunction
]
/**
 * const Comp = React.memo(() => <div />);
 * const Comp = React.forwardRef(() => <div />);
 */
 | readonly [
    TSESTree$1.VariableDeclaration,
    TSESTree$1.VariableDeclarator,
    TSESTree$1.CallExpression,
    TSESTreeFunction
]
/**
 * const Comp = React.memo(React.forwardRef(() => <div />));
 */
 | readonly [
    TSESTree$1.VariableDeclaration,
    TSESTree$1.VariableDeclarator,
    TSESTree$1.CallExpression,
    TSESTree$1.CallExpression,
    TSESTreeFunction
]
/**
 * const Comps = {
 *  TopNav() { return <div />; },
 *  SidPanel: () => <div />,
 * }
 */
 | readonly [
    TSESTree$1.VariableDeclaration,
    TSESTree$1.VariableDeclarator,
    TSESTree$1.ObjectExpression,
    TSESTree$1.Property,
    TSESTreeFunction
]
/**
 * const Comps = {
 *  TopNav: React.memo(() => <div />),
 *  SidPanel: React.forwardRef(() => <div />),
 * }
 */
 | readonly [
    TSESTree$1.VariableDeclaration,
    TSESTree$1.VariableDeclarator,
    TSESTree$1.ObjectExpression,
    TSESTree$1.Property,
    TSESTree$1.CallExpression,
    TSESTreeFunction
]
/**
 * const Comps = {
 * TopNav: React.memo(React.forwardRef(() => <div />)),
 * SidPanel: React.forwardRef(React.memo(() => <div />)),
 * }
 */
 | readonly [
    TSESTree$1.VariableDeclaration,
    TSESTree$1.VariableDeclarator,
    TSESTree$1.ObjectExpression,
    TSESTree$1.Property,
    TSESTree$1.CallExpression,
    TSESTree$1.CallExpression,
    TSESTreeFunction
]
/**
 * class Comp {
 *   TopNav() { return <div />; }
 * }
 */
 | readonly [
    TSESTree$1.ClassDeclaration,
    TSESTree$1.ClassBody,
    TSESTree$1.MethodDefinition,
    TSESTreeFunction
]
/**
 * class Comp {
 *   TopNav = () => <div />;
 * }
 */
 | readonly [
    TSESTree$1.ClassDeclaration,
    TSESTree$1.ClassBody,
    TSESTree$1.PropertyDefinition,
    TSESTreeFunction
];
declare function getFunctionInitPath(node: TSESTreeFunction): O.Option<FunctionInitPath>;
declare function hasCallInFunctionInitPath(callName: string): (initPath: O.Option<FunctionInitPath>) => boolean;

/**
 * Gets class identifier from ClassDeclaration or ClassExpression
 * @param node The AST node to check
 * @returns class identifier or null
 */
declare function getClassIdentifier(node: TSESTreeClass): O.Option<TSESTree$1.Identifier>;

/**
 * Gets the static name of a function AST node. For function declarations it is
 * easy. For anonymous function expressions it is much harder. If you search for
 * `IsAnonymousFunctionDefinition()` in the ECMAScript spec you'll find places
 * where JS gives anonymous function expressions names. We roughly detect the
 * same AST nodes with some exceptions to better fit our use case.
 */

declare function getFunctionIdentifier(node: TSESTree$1.Expression | TSESTreeFunction): O.Option<TSESTree$1.Identifier>;

declare function getIdentifiersFromBinaryExpression(side: TSESTree$1.BinaryExpression | TSESTree$1.BinaryExpression["left"] | TSESTree$1.BinaryExpression["right"]): TSESTree$1.Identifier[];

declare function getLiteralValueType(input: bigint | boolean | null | number | string | symbol): "Null" | "Boolean" | "Number" | "String" | "BigInt" | "Symbol";

/**********************************************
 *      DO NOT MODIFY THIS FILE MANUALLY      *
 *                                            *
 *  THIS FILE HAS BEEN COPIED FROM ast-spec.  *
 * ANY CHANGES WILL BE LOST ON THE NEXT BUILD *
 *                                            *
 *   MAKE CHANGES TO ast-spec AND THEN RUN    *
 *                 yarn build                 *
 **********************************************/

declare type Accessibility = 'private' | 'protected' | 'public';
declare type AccessorProperty = AccessorPropertyComputedName | AccessorPropertyNonComputedName;
declare interface AccessorPropertyComputedName extends PropertyDefinitionComputedNameBase {
    type: AST_NODE_TYPES.AccessorProperty;
}
declare interface AccessorPropertyNonComputedName extends PropertyDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.AccessorProperty;
}
declare interface ArrayExpression extends BaseNode {
    type: AST_NODE_TYPES.ArrayExpression;
    /**
     * an element will be `null` in the case of a sparse array: `[1, ,3]`
     */
    elements: (Expression | SpreadElement | null)[];
}
declare interface ArrayPattern extends BaseNode {
    type: AST_NODE_TYPES.ArrayPattern;
    decorators: Decorator[];
    elements: (DestructuringPattern | null)[];
    optional: boolean;
    typeAnnotation: TSTypeAnnotation | undefined;
}
declare interface ArrowFunctionExpression extends BaseNode {
    type: AST_NODE_TYPES.ArrowFunctionExpression;
    async: boolean;
    body: BlockStatement | Expression;
    expression: boolean;
    generator: boolean;
    id: null;
    params: Parameter[];
    returnType: TSTypeAnnotation | undefined;
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare interface AssignmentExpression extends BaseNode {
    type: AST_NODE_TYPES.AssignmentExpression;
    left: Expression;
    operator: ValueOf<AssignmentOperatorToText>;
    right: Expression;
}
declare interface AssignmentOperatorToText {
    [SyntaxKind.AmpersandAmpersandEqualsToken]: '&&=';
    [SyntaxKind.AmpersandEqualsToken]: '&=';
    [SyntaxKind.AsteriskAsteriskEqualsToken]: '**=';
    [SyntaxKind.AsteriskEqualsToken]: '*=';
    [SyntaxKind.BarBarEqualsToken]: '||=';
    [SyntaxKind.BarEqualsToken]: '|=';
    [SyntaxKind.CaretEqualsToken]: '^=';
    [SyntaxKind.EqualsToken]: '=';
    [SyntaxKind.GreaterThanGreaterThanEqualsToken]: '>>=';
    [SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken]: '>>>=';
    [SyntaxKind.LessThanLessThanEqualsToken]: '<<=';
    [SyntaxKind.MinusEqualsToken]: '-=';
    [SyntaxKind.PercentEqualsToken]: '%=';
    [SyntaxKind.PlusEqualsToken]: '+=';
    [SyntaxKind.QuestionQuestionEqualsToken]: '??=';
    [SyntaxKind.SlashEqualsToken]: '/=';
}
declare interface AssignmentPattern extends BaseNode {
    type: AST_NODE_TYPES.AssignmentPattern;
    decorators: Decorator[];
    left: BindingName;
    optional: boolean;
    right: Expression;
    typeAnnotation: TSTypeAnnotation | undefined;
}
declare enum AST_NODE_TYPES {
    AccessorProperty = "AccessorProperty",
    ArrayExpression = "ArrayExpression",
    ArrayPattern = "ArrayPattern",
    ArrowFunctionExpression = "ArrowFunctionExpression",
    AssignmentExpression = "AssignmentExpression",
    AssignmentPattern = "AssignmentPattern",
    AwaitExpression = "AwaitExpression",
    BinaryExpression = "BinaryExpression",
    BlockStatement = "BlockStatement",
    BreakStatement = "BreakStatement",
    CallExpression = "CallExpression",
    CatchClause = "CatchClause",
    ChainExpression = "ChainExpression",
    ClassBody = "ClassBody",
    ClassDeclaration = "ClassDeclaration",
    ClassExpression = "ClassExpression",
    ConditionalExpression = "ConditionalExpression",
    ContinueStatement = "ContinueStatement",
    DebuggerStatement = "DebuggerStatement",
    Decorator = "Decorator",
    DoWhileStatement = "DoWhileStatement",
    EmptyStatement = "EmptyStatement",
    ExportAllDeclaration = "ExportAllDeclaration",
    ExportDefaultDeclaration = "ExportDefaultDeclaration",
    ExportNamedDeclaration = "ExportNamedDeclaration",
    ExportSpecifier = "ExportSpecifier",
    ExpressionStatement = "ExpressionStatement",
    ForInStatement = "ForInStatement",
    ForOfStatement = "ForOfStatement",
    ForStatement = "ForStatement",
    FunctionDeclaration = "FunctionDeclaration",
    FunctionExpression = "FunctionExpression",
    Identifier = "Identifier",
    IfStatement = "IfStatement",
    ImportAttribute = "ImportAttribute",
    ImportDeclaration = "ImportDeclaration",
    ImportDefaultSpecifier = "ImportDefaultSpecifier",
    ImportExpression = "ImportExpression",
    ImportNamespaceSpecifier = "ImportNamespaceSpecifier",
    ImportSpecifier = "ImportSpecifier",
    JSXAttribute = "JSXAttribute",
    JSXClosingElement = "JSXClosingElement",
    JSXClosingFragment = "JSXClosingFragment",
    JSXElement = "JSXElement",
    JSXEmptyExpression = "JSXEmptyExpression",
    JSXExpressionContainer = "JSXExpressionContainer",
    JSXFragment = "JSXFragment",
    JSXIdentifier = "JSXIdentifier",
    JSXMemberExpression = "JSXMemberExpression",
    JSXNamespacedName = "JSXNamespacedName",
    JSXOpeningElement = "JSXOpeningElement",
    JSXOpeningFragment = "JSXOpeningFragment",
    JSXSpreadAttribute = "JSXSpreadAttribute",
    JSXSpreadChild = "JSXSpreadChild",
    JSXText = "JSXText",
    LabeledStatement = "LabeledStatement",
    Literal = "Literal",
    LogicalExpression = "LogicalExpression",
    MemberExpression = "MemberExpression",
    MetaProperty = "MetaProperty",
    MethodDefinition = "MethodDefinition",
    NewExpression = "NewExpression",
    ObjectExpression = "ObjectExpression",
    ObjectPattern = "ObjectPattern",
    PrivateIdentifier = "PrivateIdentifier",
    Program = "Program",
    Property = "Property",
    PropertyDefinition = "PropertyDefinition",
    RestElement = "RestElement",
    ReturnStatement = "ReturnStatement",
    SequenceExpression = "SequenceExpression",
    SpreadElement = "SpreadElement",
    StaticBlock = "StaticBlock",
    Super = "Super",
    SwitchCase = "SwitchCase",
    SwitchStatement = "SwitchStatement",
    TaggedTemplateExpression = "TaggedTemplateExpression",
    TemplateElement = "TemplateElement",
    TemplateLiteral = "TemplateLiteral",
    ThisExpression = "ThisExpression",
    ThrowStatement = "ThrowStatement",
    TryStatement = "TryStatement",
    UnaryExpression = "UnaryExpression",
    UpdateExpression = "UpdateExpression",
    VariableDeclaration = "VariableDeclaration",
    VariableDeclarator = "VariableDeclarator",
    WhileStatement = "WhileStatement",
    WithStatement = "WithStatement",
    YieldExpression = "YieldExpression",
    TSAbstractAccessorProperty = "TSAbstractAccessorProperty",
    TSAbstractKeyword = "TSAbstractKeyword",
    TSAbstractMethodDefinition = "TSAbstractMethodDefinition",
    TSAbstractPropertyDefinition = "TSAbstractPropertyDefinition",
    TSAnyKeyword = "TSAnyKeyword",
    TSArrayType = "TSArrayType",
    TSAsExpression = "TSAsExpression",
    TSAsyncKeyword = "TSAsyncKeyword",
    TSBigIntKeyword = "TSBigIntKeyword",
    TSBooleanKeyword = "TSBooleanKeyword",
    TSCallSignatureDeclaration = "TSCallSignatureDeclaration",
    TSClassImplements = "TSClassImplements",
    TSConditionalType = "TSConditionalType",
    TSConstructorType = "TSConstructorType",
    TSConstructSignatureDeclaration = "TSConstructSignatureDeclaration",
    TSDeclareFunction = "TSDeclareFunction",
    TSDeclareKeyword = "TSDeclareKeyword",
    TSEmptyBodyFunctionExpression = "TSEmptyBodyFunctionExpression",
    TSEnumBody = "TSEnumBody",
    TSEnumDeclaration = "TSEnumDeclaration",
    TSEnumMember = "TSEnumMember",
    TSExportAssignment = "TSExportAssignment",
    TSExportKeyword = "TSExportKeyword",
    TSExternalModuleReference = "TSExternalModuleReference",
    TSFunctionType = "TSFunctionType",
    TSImportEqualsDeclaration = "TSImportEqualsDeclaration",
    TSImportType = "TSImportType",
    TSIndexedAccessType = "TSIndexedAccessType",
    TSIndexSignature = "TSIndexSignature",
    TSInferType = "TSInferType",
    TSInstantiationExpression = "TSInstantiationExpression",
    TSInterfaceBody = "TSInterfaceBody",
    TSInterfaceDeclaration = "TSInterfaceDeclaration",
    TSInterfaceHeritage = "TSInterfaceHeritage",
    TSIntersectionType = "TSIntersectionType",
    TSIntrinsicKeyword = "TSIntrinsicKeyword",
    TSLiteralType = "TSLiteralType",
    TSMappedType = "TSMappedType",
    TSMethodSignature = "TSMethodSignature",
    TSModuleBlock = "TSModuleBlock",
    TSModuleDeclaration = "TSModuleDeclaration",
    TSNamedTupleMember = "TSNamedTupleMember",
    TSNamespaceExportDeclaration = "TSNamespaceExportDeclaration",
    TSNeverKeyword = "TSNeverKeyword",
    TSNonNullExpression = "TSNonNullExpression",
    TSNullKeyword = "TSNullKeyword",
    TSNumberKeyword = "TSNumberKeyword",
    TSObjectKeyword = "TSObjectKeyword",
    TSOptionalType = "TSOptionalType",
    TSParameterProperty = "TSParameterProperty",
    TSPrivateKeyword = "TSPrivateKeyword",
    TSPropertySignature = "TSPropertySignature",
    TSProtectedKeyword = "TSProtectedKeyword",
    TSPublicKeyword = "TSPublicKeyword",
    TSQualifiedName = "TSQualifiedName",
    TSReadonlyKeyword = "TSReadonlyKeyword",
    TSRestType = "TSRestType",
    TSSatisfiesExpression = "TSSatisfiesExpression",
    TSStaticKeyword = "TSStaticKeyword",
    TSStringKeyword = "TSStringKeyword",
    TSSymbolKeyword = "TSSymbolKeyword",
    TSTemplateLiteralType = "TSTemplateLiteralType",
    TSThisType = "TSThisType",
    TSTupleType = "TSTupleType",
    TSTypeAliasDeclaration = "TSTypeAliasDeclaration",
    TSTypeAnnotation = "TSTypeAnnotation",
    TSTypeAssertion = "TSTypeAssertion",
    TSTypeLiteral = "TSTypeLiteral",
    TSTypeOperator = "TSTypeOperator",
    TSTypeParameter = "TSTypeParameter",
    TSTypeParameterDeclaration = "TSTypeParameterDeclaration",
    TSTypeParameterInstantiation = "TSTypeParameterInstantiation",
    TSTypePredicate = "TSTypePredicate",
    TSTypeQuery = "TSTypeQuery",
    TSTypeReference = "TSTypeReference",
    TSUndefinedKeyword = "TSUndefinedKeyword",
    TSUnionType = "TSUnionType",
    TSUnknownKeyword = "TSUnknownKeyword",
    TSVoidKeyword = "TSVoidKeyword"
}
declare enum AST_TOKEN_TYPES {
    Boolean = "Boolean",
    Identifier = "Identifier",
    JSXIdentifier = "JSXIdentifier",
    JSXText = "JSXText",
    Keyword = "Keyword",
    Null = "Null",
    Numeric = "Numeric",
    Punctuator = "Punctuator",
    RegularExpression = "RegularExpression",
    String = "String",
    Template = "Template",
    Block = "Block",
    Line = "Line"
}
declare interface AwaitExpression extends BaseNode {
    type: AST_NODE_TYPES.AwaitExpression;
    argument: Expression;
}
declare interface BaseNode extends NodeOrTokenData {
    type: AST_NODE_TYPES;
}
declare interface BaseToken extends NodeOrTokenData {
    type: AST_TOKEN_TYPES;
    value: string;
}
declare interface BigIntLiteral extends LiteralBase {
    bigint: string;
    value: bigint | null;
}
declare interface BinaryExpression extends BaseNode {
    type: AST_NODE_TYPES.BinaryExpression;
    left: Expression | PrivateIdentifier;
    operator: ValueOf<BinaryOperatorToText>;
    right: Expression;
}
declare interface BinaryOperatorToText {
    [SyntaxKind.AmpersandAmpersandToken]: '&&';
    [SyntaxKind.AmpersandToken]: '&';
    [SyntaxKind.AsteriskAsteriskToken]: '**';
    [SyntaxKind.AsteriskToken]: '*';
    [SyntaxKind.BarBarToken]: '||';
    [SyntaxKind.BarToken]: '|';
    [SyntaxKind.CaretToken]: '^';
    [SyntaxKind.EqualsEqualsEqualsToken]: '===';
    [SyntaxKind.EqualsEqualsToken]: '==';
    [SyntaxKind.ExclamationEqualsEqualsToken]: '!==';
    [SyntaxKind.ExclamationEqualsToken]: '!=';
    [SyntaxKind.GreaterThanEqualsToken]: '>=';
    [SyntaxKind.GreaterThanGreaterThanGreaterThanToken]: '>>>';
    [SyntaxKind.GreaterThanGreaterThanToken]: '>>';
    [SyntaxKind.GreaterThanToken]: '>';
    [SyntaxKind.InKeyword]: 'in';
    [SyntaxKind.InstanceOfKeyword]: 'instanceof';
    [SyntaxKind.LessThanEqualsToken]: '<=';
    [SyntaxKind.LessThanLessThanToken]: '<<';
    [SyntaxKind.LessThanToken]: '<';
    [SyntaxKind.MinusToken]: '-';
    [SyntaxKind.PercentToken]: '%';
    [SyntaxKind.PlusToken]: '+';
    [SyntaxKind.SlashToken]: '/';
}
declare type BindingName = BindingPattern | Identifier;
declare type BindingPattern = ArrayPattern | ObjectPattern;
declare interface BlockComment extends BaseToken {
    type: AST_TOKEN_TYPES.Block;
}
declare interface BlockStatement extends BaseNode {
    type: AST_NODE_TYPES.BlockStatement;
    body: Statement[];
}
declare interface BooleanLiteral extends LiteralBase {
    raw: 'false' | 'true';
    value: boolean;
}
declare interface BooleanToken extends BaseToken {
    type: AST_TOKEN_TYPES.Boolean;
}
declare interface BreakStatement extends BaseNode {
    type: AST_NODE_TYPES.BreakStatement;
    label: Identifier | null;
}
declare interface CallExpression extends BaseNode {
    type: AST_NODE_TYPES.CallExpression;
    arguments: CallExpressionArgument[];
    callee: Expression;
    optional: boolean;
    typeArguments: TSTypeParameterInstantiation | undefined;
}
declare type CallExpressionArgument = Expression | SpreadElement;
declare interface CatchClause extends BaseNode {
    type: AST_NODE_TYPES.CatchClause;
    body: BlockStatement;
    param: BindingName | null;
}
declare type ChainElement = CallExpression | MemberExpression | TSNonNullExpression;
declare interface ChainExpression extends BaseNode {
    type: AST_NODE_TYPES.ChainExpression;
    expression: ChainElement;
}
declare interface ClassBase extends BaseNode {
    /**
     * Whether the class is an abstract class.
     * @example
     * ```ts
     * abstract class Foo {}
     * ```
     */
    abstract: boolean;
    /**
     * The class body.
     */
    body: ClassBody;
    /**
     * Whether the class has been `declare`d:
     * @example
     * ```ts
     * declare class Foo {}
     * ```
     */
    declare: boolean;
    /**
     * The decorators declared for the class.
     * @example
     * ```ts
     * @deco
     * class Foo {}
     * ```
     */
    decorators: Decorator[];
    /**
     * The class's name.
     * - For a `ClassExpression` this may be `null` if the name is omitted.
     * - For a `ClassDeclaration` this may be `null` if and only if the parent is
     *   an `ExportDefaultDeclaration`.
     */
    id: Identifier | null;
    /**
     * The implemented interfaces for the class.
     */
    implements: TSClassImplements[];
    /**
     * The super class this class extends.
     */
    superClass: LeftHandSideExpression | null;
    /**
     * The generic type parameters passed to the superClass.
     */
    superTypeArguments: TSTypeParameterInstantiation | undefined;
    /**
     * The generic type parameters declared for the class.
     */
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare interface ClassBody extends BaseNode {
    type: AST_NODE_TYPES.ClassBody;
    body: ClassElement[];
}
declare type ClassDeclaration = ClassDeclarationWithName | ClassDeclarationWithOptionalName;
declare interface ClassDeclarationBase extends ClassBase {
    type: AST_NODE_TYPES.ClassDeclaration;
}
/**
 * A normal class declaration:
 * ```
 * class A {}
 * ```
 */
declare interface ClassDeclarationWithName extends ClassDeclarationBase {
    id: Identifier;
}
/**
 * Default-exported class declarations have optional names:
 * ```
 * export default class {}
 * ```
 */
declare interface ClassDeclarationWithOptionalName extends ClassDeclarationBase {
    id: Identifier | null;
}
declare type ClassElement = AccessorProperty | MethodDefinition | PropertyDefinition | StaticBlock | TSAbstractAccessorProperty | TSAbstractMethodDefinition | TSAbstractPropertyDefinition | TSIndexSignature;
declare interface ClassExpression extends ClassBase {
    type: AST_NODE_TYPES.ClassExpression;
    abstract: false;
    declare: false;
}
declare interface ClassMethodDefinitionNonComputedNameBase extends MethodDefinitionBase {
    computed: false;
    key: ClassPropertyNameNonComputed;
}
declare interface ClassPropertyDefinitionNonComputedNameBase extends PropertyDefinitionBase {
    computed: false;
    key: ClassPropertyNameNonComputed;
}
declare type ClassPropertyNameNonComputed = PrivateIdentifier | PropertyNameNonComputed;
declare type Comment = BlockComment | LineComment;
declare interface ConditionalExpression extends BaseNode {
    type: AST_NODE_TYPES.ConditionalExpression;
    alternate: Expression;
    consequent: Expression;
    test: Expression;
}
declare interface ConstDeclaration extends LetOrConstOrVarDeclarationBase {
    /**
     * In a `declare const` declaration, the declarators may have initializers, but
     * not definite assignment assertions. Each declarator cannot have both an
     * initializer and a type annotation.
     *
     * Even if the declaration has no `declare`, it may still be ambient and have
     * no initializer.
     */
    declarations: VariableDeclaratorMaybeInit[];
    kind: 'const';
}
declare interface ContinueStatement extends BaseNode {
    type: AST_NODE_TYPES.ContinueStatement;
    label: Identifier | null;
}
declare interface DebuggerStatement extends BaseNode {
    type: AST_NODE_TYPES.DebuggerStatement;
}
declare interface Decorator extends BaseNode {
    type: AST_NODE_TYPES.Decorator;
    expression: LeftHandSideExpression;
}
declare type DefaultExportDeclarations = ClassDeclarationWithOptionalName | Expression | FunctionDeclarationWithName | FunctionDeclarationWithOptionalName | TSDeclareFunction | TSEnumDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSTypeAliasDeclaration | VariableDeclaration;
declare type DestructuringPattern = ArrayPattern | AssignmentPattern | Identifier | MemberExpression | ObjectPattern | RestElement;
declare interface DoWhileStatement extends BaseNode {
    type: AST_NODE_TYPES.DoWhileStatement;
    body: Statement;
    test: Expression;
}
declare interface EmptyStatement extends BaseNode {
    type: AST_NODE_TYPES.EmptyStatement;
}
declare type EntityName = Identifier | ThisExpression | TSQualifiedName;
declare interface ExportAllDeclaration extends BaseNode {
    type: AST_NODE_TYPES.ExportAllDeclaration;
    /**
     * The assertions declared for the export.
     * @example
     * ```ts
     * export * from 'mod' assert \{ type: 'json' \};
     * ```
     * @deprecated Replaced with {@link `attributes`}.
     */
    assertions: ImportAttribute[];
    /**
     * The attributes declared for the export.
     * @example
     * ```ts
     * export * from 'mod' with \{ type: 'json' \};
     * ```
     */
    attributes: ImportAttribute[];
    /**
     * The name for the exported items (`as X`). `null` if no name is assigned.
     */
    exported: Identifier | null;
    /**
     * The kind of the export.
     */
    exportKind: ExportKind;
    /**
     * The source module being exported from.
     */
    source: StringLiteral;
}
declare type ExportAndImportKind = 'type' | 'value';
declare interface ExportDefaultDeclaration extends BaseNode {
    type: AST_NODE_TYPES.ExportDefaultDeclaration;
    /**
     * The declaration being exported.
     */
    declaration: DefaultExportDeclarations;
    /**
     * The kind of the export. Always `value` for default exports.
     */
    exportKind: 'value';
}
declare type ExportKind = ExportAndImportKind;
declare type ExportNamedDeclaration = ExportNamedDeclarationWithoutSourceWithMultiple | ExportNamedDeclarationWithoutSourceWithSingle | ExportNamedDeclarationWithSource;
declare interface ExportNamedDeclarationBase extends BaseNode {
    type: AST_NODE_TYPES.ExportNamedDeclaration;
    /**
     * The assertions declared for the export.
     * @example
     * ```ts
     * export { foo } from 'mod' assert \{ type: 'json' \};
     * ```
     * This will be an empty array if `source` is `null`
     * @deprecated Replaced with {@link `attributes`}.
     */
    assertions: ImportAttribute[];
    /**
     * The attributes declared for the export.
     * @example
     * ```ts
     * export { foo } from 'mod' with \{ type: 'json' \};
     * ```
     * This will be an empty array if `source` is `null`
     */
    attributes: ImportAttribute[];
    /**
     * The exported declaration.
     * @example
     * ```ts
     * export const x = 1;
     * ```
     * This will be `null` if `source` is not `null`, or if there are `specifiers`
     */
    declaration: NamedExportDeclarations | null;
    /**
     * The kind of the export.
     */
    exportKind: ExportKind;
    /**
     * The source module being exported from.
     */
    source: StringLiteral | null;
    /**
     * The specifiers being exported.
     * @example
     * ```ts
     * export { a, b };
     * ```
     * This will be an empty array if `declaration` is not `null`
     */
    specifiers: ExportSpecifier[];
}
/**
 * Exporting names from the current module.
 * ```
 * export {};
 * export { a, b };
 * ```
 */
declare interface ExportNamedDeclarationWithoutSourceWithMultiple extends ExportNamedDeclarationBase {
    /**
     * This will always be an empty array.
     * @deprecated Replaced with {@link `attributes`}.
     */
    assertions: ImportAttribute[];
    /**
     * This will always be an empty array.
     */
    attributes: ImportAttribute[];
    declaration: null;
    source: null;
    specifiers: ExportSpecifierWithIdentifierLocal[];
}
/**
 * Exporting a single named declaration.
 * ```
 * export const x = 1;
 * ```
 */
declare interface ExportNamedDeclarationWithoutSourceWithSingle extends ExportNamedDeclarationBase {
    /**
     * This will always be an empty array.
     * @deprecated Replaced with {@link `attributes`}.
     */
    assertions: ImportAttribute[];
    /**
     * This will always be an empty array.
     */
    attributes: ImportAttribute[];
    declaration: NamedExportDeclarations;
    source: null;
    /**
     * This will always be an empty array.
     */
    specifiers: ExportSpecifierWithIdentifierLocal[];
}
/**
 * Export names from another module.
 * ```
 * export { a, b } from 'mod';
 * ```
 */
declare interface ExportNamedDeclarationWithSource extends ExportNamedDeclarationBase {
    declaration: null;
    source: StringLiteral;
}
declare type ExportSpecifier = ExportSpecifierWithIdentifierLocal | ExportSpecifierWithStringOrLiteralLocal;
declare interface ExportSpecifierBase extends BaseNode {
    type: AST_NODE_TYPES.ExportSpecifier;
    exported: Identifier | StringLiteral;
    exportKind: ExportKind;
    local: Identifier | StringLiteral;
}
declare interface ExportSpecifierWithIdentifierLocal extends ExportSpecifierBase {
    local: Identifier;
}
declare interface ExportSpecifierWithStringOrLiteralLocal extends ExportSpecifierBase {
    local: Identifier | StringLiteral;
}
declare type Expression = ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AwaitExpression | BinaryExpression | CallExpression | ChainExpression | ClassExpression | ConditionalExpression | FunctionExpression | Identifier | ImportExpression | JSXElement | JSXFragment | LiteralExpression | LogicalExpression | MemberExpression | MetaProperty | NewExpression | ObjectExpression | ObjectPattern | SequenceExpression | Super | TaggedTemplateExpression | TemplateLiteral | ThisExpression | TSAsExpression | TSInstantiationExpression | TSNonNullExpression | TSSatisfiesExpression | TSTypeAssertion | UnaryExpression | UpdateExpression | YieldExpression;
declare interface ExpressionStatement extends BaseNode {
    type: AST_NODE_TYPES.ExpressionStatement;
    directive: string | undefined;
    expression: Expression;
}
declare type ForInitialiser = Expression | LetOrConstOrVarDeclaration;
declare interface ForInStatement extends BaseNode {
    type: AST_NODE_TYPES.ForInStatement;
    body: Statement;
    left: ForInitialiser;
    right: Expression;
}
declare type ForOfInitialiser = Expression | LetOrConstOrVarDeclaration | UsingInForOfDeclaration;
declare interface ForOfStatement extends BaseNode {
    type: AST_NODE_TYPES.ForOfStatement;
    await: boolean;
    body: Statement;
    left: ForOfInitialiser;
    right: Expression;
}
declare interface ForStatement extends BaseNode {
    type: AST_NODE_TYPES.ForStatement;
    body: Statement;
    init: Expression | ForInitialiser | null;
    test: Expression | null;
    update: Expression | null;
}
declare interface FunctionBase extends BaseNode {
    /**
     * Whether the function is async:
     * ```
     * async function foo() {}
     * const x = async function () {}
     * const x = async () => {}
     * ```
     */
    async: boolean;
    /**
     * The body of the function.
     * - For an `ArrowFunctionExpression` this may be an `Expression` or `BlockStatement`.
     * - For a `FunctionDeclaration` or `FunctionExpression` this is always a `BlockStatement`.
     * - For a `TSDeclareFunction` this is always `undefined`.
     * - For a `TSEmptyBodyFunctionExpression` this is always `null`.
     */
    body: BlockStatement | Expression | null | undefined;
    /**
     * This is only `true` if and only if the node is a `TSDeclareFunction` and it has `declare`:
     * ```
     * declare function foo() {}
     * ```
     */
    declare: boolean;
    /**
     * This is only ever `true` if and only the node is an `ArrowFunctionExpression` and the body
     * is an expression:
     * ```
     * (() => 1)
     * ```
     */
    expression: boolean;
    /**
     * Whether the function is a generator function:
     * ```
     * function *foo() {}
     * const x = function *() {}
     * ```
     * This is always `false` for arrow functions as they cannot be generators.
     */
    generator: boolean;
    /**
     * The function's name.
     * - For an `ArrowFunctionExpression` this is always `null`.
     * - For a `FunctionExpression` this may be `null` if the name is omitted.
     * - For a `FunctionDeclaration` or `TSDeclareFunction` this may be `null` if
     *   and only if the parent is an `ExportDefaultDeclaration`.
     */
    id: Identifier | null;
    /**
     * The list of parameters declared for the function.
     */
    params: Parameter[];
    /**
     * The return type annotation for the function.
     */
    returnType: TSTypeAnnotation | undefined;
    /**
     * The generic type parameter declaration for the function.
     */
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare type FunctionDeclaration = FunctionDeclarationWithName | FunctionDeclarationWithOptionalName;
declare interface FunctionDeclarationBase extends FunctionBase {
    type: AST_NODE_TYPES.FunctionDeclaration;
    body: BlockStatement;
    declare: false;
    expression: false;
}
/**
 * A normal function declaration:
 * ```
 * function f() {}
 * ```
 */
declare interface FunctionDeclarationWithName extends FunctionDeclarationBase {
    id: Identifier;
}
/**
 * Default-exported function declarations have optional names:
 * ```
 * export default function () {}
 * ```
 */
declare interface FunctionDeclarationWithOptionalName extends FunctionDeclarationBase {
    id: Identifier | null;
}
declare interface FunctionExpression extends FunctionBase {
    type: AST_NODE_TYPES.FunctionExpression;
    body: BlockStatement;
    expression: false;
}
declare interface Identifier extends BaseNode {
    type: AST_NODE_TYPES.Identifier;
    decorators: Decorator[];
    name: string;
    optional: boolean;
    typeAnnotation: TSTypeAnnotation | undefined;
}
declare interface IdentifierToken extends BaseToken {
    type: AST_TOKEN_TYPES.Identifier;
}
declare interface IfStatement extends BaseNode {
    type: AST_NODE_TYPES.IfStatement;
    alternate: Statement | null;
    consequent: Statement;
    test: Expression;
}
declare interface ImportAttribute extends BaseNode {
    type: AST_NODE_TYPES.ImportAttribute;
    key: Identifier | Literal;
    value: Literal;
}
declare type ImportClause = ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier;
declare interface ImportDeclaration extends BaseNode {
    type: AST_NODE_TYPES.ImportDeclaration;
    /**
     * The assertions declared for the export.
     * @example
     * ```ts
     * import * from 'mod' assert \{ type: 'json' \};
     * ```
     * @deprecated Replaced with {@link `attributes`}.
     */
    assertions: ImportAttribute[];
    /**
     * The attributes declared for the export.
     * @example
     * ```ts
     * import * from 'mod' with \{ type: 'json' \};
     * ```
     */
    attributes: ImportAttribute[];
    /**
     * The kind of the import.
     */
    importKind: ImportKind;
    /**
     * The source module being imported from.
     */
    source: StringLiteral;
    /**
     * The specifiers being imported.
     * If this is an empty array then either there are no specifiers:
     * ```
     * import {} from 'mod';
     * ```
     * Or it is a side-effect import:
     * ```
     * import 'mod';
     * ```
     */
    specifiers: ImportClause[];
}
declare interface ImportDefaultSpecifier extends BaseNode {
    type: AST_NODE_TYPES.ImportDefaultSpecifier;
    local: Identifier;
}
declare interface ImportExpression extends BaseNode {
    type: AST_NODE_TYPES.ImportExpression;
    /**
     * The attributes declared for the dynamic import.
     * @example
     * ```ts
     * import('mod', \{ assert: \{ type: 'json' \} \});
     * ```
     * @deprecated Replaced with {@link `options`}.
     */
    attributes: Expression | null;
    /**
     * The options bag declared for the dynamic import.
     * @example
     * ```ts
     * import('mod', \{ assert: \{ type: 'json' \} \});
     * ```
     */
    options: Expression | null;
    source: Expression;
}
declare type ImportKind = ExportAndImportKind;
declare interface ImportNamespaceSpecifier extends BaseNode {
    type: AST_NODE_TYPES.ImportNamespaceSpecifier;
    local: Identifier;
}
declare interface ImportSpecifier extends BaseNode {
    type: AST_NODE_TYPES.ImportSpecifier;
    imported: Identifier | StringLiteral;
    importKind: ImportKind;
    local: Identifier;
}
declare interface JSXAttribute extends BaseNode {
    type: AST_NODE_TYPES.JSXAttribute;
    name: JSXIdentifier | JSXNamespacedName;
    value: JSXElement | JSXExpression | Literal | null;
}
declare type JSXChild = JSXElement | JSXExpression | JSXFragment | JSXText;
declare interface JSXClosingElement extends BaseNode {
    type: AST_NODE_TYPES.JSXClosingElement;
    name: JSXTagNameExpression;
}
declare interface JSXClosingFragment extends BaseNode {
    type: AST_NODE_TYPES.JSXClosingFragment;
}
declare interface JSXElement extends BaseNode {
    type: AST_NODE_TYPES.JSXElement;
    children: JSXChild[];
    closingElement: JSXClosingElement | null;
    openingElement: JSXOpeningElement;
}
declare interface JSXEmptyExpression extends BaseNode {
    type: AST_NODE_TYPES.JSXEmptyExpression;
}
declare type JSXExpression = JSXExpressionContainer | JSXSpreadChild;
declare interface JSXExpressionContainer extends BaseNode {
    type: AST_NODE_TYPES.JSXExpressionContainer;
    expression: Expression | JSXEmptyExpression;
}
declare interface JSXFragment extends BaseNode {
    type: AST_NODE_TYPES.JSXFragment;
    children: JSXChild[];
    closingFragment: JSXClosingFragment;
    openingFragment: JSXOpeningFragment;
}
declare interface JSXIdentifier extends BaseNode {
    type: AST_NODE_TYPES.JSXIdentifier;
    name: string;
}
declare interface JSXIdentifierToken extends BaseToken {
    type: AST_TOKEN_TYPES.JSXIdentifier;
}
declare interface JSXMemberExpression extends BaseNode {
    type: AST_NODE_TYPES.JSXMemberExpression;
    object: JSXTagNameExpression;
    property: JSXIdentifier;
}
declare interface JSXNamespacedName extends BaseNode {
    type: AST_NODE_TYPES.JSXNamespacedName;
    name: JSXIdentifier;
    namespace: JSXIdentifier;
}
declare interface JSXOpeningElement extends BaseNode {
    type: AST_NODE_TYPES.JSXOpeningElement;
    attributes: (JSXAttribute | JSXSpreadAttribute)[];
    name: JSXTagNameExpression;
    selfClosing: boolean;
    typeArguments: TSTypeParameterInstantiation | undefined;
}
declare interface JSXOpeningFragment extends BaseNode {
    type: AST_NODE_TYPES.JSXOpeningFragment;
}
declare interface JSXSpreadAttribute extends BaseNode {
    type: AST_NODE_TYPES.JSXSpreadAttribute;
    argument: Expression;
}
declare interface JSXSpreadChild extends BaseNode {
    type: AST_NODE_TYPES.JSXSpreadChild;
    expression: Expression | JSXEmptyExpression;
}
declare type JSXTagNameExpression = JSXIdentifier | JSXMemberExpression | JSXNamespacedName;
declare interface JSXText extends BaseNode {
    type: AST_NODE_TYPES.JSXText;
    raw: string;
    value: string;
}
declare interface JSXTextToken extends BaseToken {
    type: AST_TOKEN_TYPES.JSXText;
}
declare interface KeywordToken extends BaseToken {
    type: AST_TOKEN_TYPES.Keyword;
}
declare interface LabeledStatement extends BaseNode {
    type: AST_NODE_TYPES.LabeledStatement;
    body: Statement;
    label: Identifier;
}
declare type LeftHandSideExpression = ArrayExpression | ArrayPattern | ArrowFunctionExpression | CallExpression | ClassExpression | FunctionExpression | Identifier | JSXElement | JSXFragment | LiteralExpression | MemberExpression | MetaProperty | ObjectExpression | ObjectPattern | SequenceExpression | Super | TaggedTemplateExpression | ThisExpression | TSAsExpression | TSNonNullExpression | TSTypeAssertion;
declare type LetOrConstOrVarDeclaration = ConstDeclaration | LetOrVarDeclaredDeclaration | LetOrVarNonDeclaredDeclaration;
declare interface LetOrConstOrVarDeclarationBase extends BaseNode {
    type: AST_NODE_TYPES.VariableDeclaration;
    /**
     * The variables declared by this declaration.
     * Always non-empty.
     * @example
     * ```ts
     * let x;
     * let y, z;
     * ```
     */
    declarations: LetOrConstOrVarDeclarator[];
    /**
     * Whether the declaration is `declare`d
     * @example
     * ```ts
     * declare const x = 1;
     * ```
     */
    declare: boolean;
    /**
     * The keyword used to declare the variable(s)
     * @example
     * ```ts
     * const x = 1;
     * let y = 2;
     * var z = 3;
     * ```
     */
    kind: 'const' | 'let' | 'var';
}
declare type LetOrConstOrVarDeclarator = VariableDeclaratorDefiniteAssignment | VariableDeclaratorMaybeInit | VariableDeclaratorNoInit;
declare interface LetOrVarDeclaredDeclaration extends LetOrConstOrVarDeclarationBase {
    /**
     * In a `declare let` declaration, the declarators must not have definite assignment
     * assertions or initializers.
     *
     * @example
     * ```ts
     * using x = 1;
     * using y =1, z = 2;
     * ```
     */
    declarations: VariableDeclaratorNoInit[];
    declare: true;
    kind: 'let' | 'var';
}
declare interface LetOrVarNonDeclaredDeclaration extends LetOrConstOrVarDeclarationBase {
    /**
     * In a `let`/`var` declaration, the declarators may have definite assignment
     * assertions or initializers, but not both.
     */
    declarations: (VariableDeclaratorDefiniteAssignment | VariableDeclaratorMaybeInit)[];
    declare: false;
    kind: 'let' | 'var';
}
declare interface LineComment extends BaseToken {
    type: AST_TOKEN_TYPES.Line;
}
declare type Literal = BigIntLiteral | BooleanLiteral | NullLiteral | NumberLiteral | RegExpLiteral | StringLiteral;
declare interface LiteralBase extends BaseNode {
    type: AST_NODE_TYPES.Literal;
    raw: string;
    value: bigint | boolean | number | string | RegExp | null;
}
declare type LiteralExpression = Literal | TemplateLiteral;
declare interface LogicalExpression extends BaseNode {
    type: AST_NODE_TYPES.LogicalExpression;
    left: Expression;
    operator: '&&' | '??' | '||';
    right: Expression;
}
declare type MemberExpression = MemberExpressionComputedName | MemberExpressionNonComputedName;
declare interface MemberExpressionBase extends BaseNode {
    computed: boolean;
    object: Expression;
    optional: boolean;
    property: Expression | Identifier | PrivateIdentifier;
}
declare interface MemberExpressionComputedName extends MemberExpressionBase {
    type: AST_NODE_TYPES.MemberExpression;
    computed: true;
    property: Expression;
}
declare interface MemberExpressionNonComputedName extends MemberExpressionBase {
    type: AST_NODE_TYPES.MemberExpression;
    computed: false;
    property: Identifier | PrivateIdentifier;
}
declare interface MetaProperty extends BaseNode {
    type: AST_NODE_TYPES.MetaProperty;
    meta: Identifier;
    property: Identifier;
}
declare type MethodDefinition = MethodDefinitionComputedName | MethodDefinitionNonComputedName;
/** this should not be directly used - instead use MethodDefinitionComputedNameBase or MethodDefinitionNonComputedNameBase */
declare interface MethodDefinitionBase extends BaseNode {
    accessibility: Accessibility | undefined;
    computed: boolean;
    decorators: Decorator[];
    key: PropertyName;
    kind: 'constructor' | 'get' | 'method' | 'set';
    optional: boolean;
    override: boolean;
    static: boolean;
    value: FunctionExpression | TSEmptyBodyFunctionExpression;
}
declare interface MethodDefinitionComputedName extends MethodDefinitionComputedNameBase {
    type: AST_NODE_TYPES.MethodDefinition;
}
declare interface MethodDefinitionComputedNameBase extends MethodDefinitionBase {
    computed: true;
    key: PropertyNameComputed;
}
declare interface MethodDefinitionNonComputedName extends ClassMethodDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.MethodDefinition;
}
declare interface MethodDefinitionNonComputedNameBase extends MethodDefinitionBase {
    computed: false;
    key: PropertyNameNonComputed;
}
declare type NamedExportDeclarations = ClassDeclarationWithName | ClassDeclarationWithOptionalName | FunctionDeclarationWithName | FunctionDeclarationWithOptionalName | TSDeclareFunction | TSEnumDeclaration | TSImportEqualsDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSTypeAliasDeclaration | VariableDeclaration;
declare interface NewExpression extends BaseNode {
    type: AST_NODE_TYPES.NewExpression;
    arguments: CallExpressionArgument[];
    callee: Expression;
    typeArguments: TSTypeParameterInstantiation | undefined;
}
declare type Node = AccessorProperty | ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BlockStatement | BreakStatement | CallExpression | CatchClause | ChainExpression | ClassBody | ClassDeclaration | ClassExpression | ConditionalExpression | ContinueStatement | DebuggerStatement | Decorator | DoWhileStatement | EmptyStatement | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ExportSpecifier | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | Identifier | IfStatement | ImportAttribute | ImportDeclaration | ImportDefaultSpecifier | ImportExpression | ImportNamespaceSpecifier | ImportSpecifier | JSXAttribute | JSXClosingElement | JSXClosingFragment | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXFragment | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXOpeningFragment | JSXSpreadAttribute | JSXSpreadChild | JSXText | LabeledStatement | Literal | LogicalExpression | MemberExpression | MetaProperty | MethodDefinition | NewExpression | ObjectExpression | ObjectPattern | PrivateIdentifier | Program | Property | PropertyDefinition | RestElement | ReturnStatement | SequenceExpression | SpreadElement | StaticBlock | Super | SwitchCase | SwitchStatement | TaggedTemplateExpression | TemplateElement | TemplateLiteral | ThisExpression | ThrowStatement | TryStatement | TSAbstractAccessorProperty | TSAbstractKeyword | TSAbstractMethodDefinition | TSAbstractPropertyDefinition | TSAnyKeyword | TSArrayType | TSAsExpression | TSAsyncKeyword | TSBigIntKeyword | TSBooleanKeyword | TSCallSignatureDeclaration | TSClassImplements | TSConditionalType | TSConstructorType | TSConstructSignatureDeclaration | TSDeclareFunction | TSDeclareKeyword | TSEmptyBodyFunctionExpression | TSEnumBody | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSExportKeyword | TSExternalModuleReference | TSFunctionType | TSImportEqualsDeclaration | TSImportType | TSIndexedAccessType | TSIndexSignature | TSInferType | TSInstantiationExpression | TSInterfaceBody | TSInterfaceDeclaration | TSInterfaceHeritage | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSMethodSignature | TSModuleBlock | TSModuleDeclaration | TSNamedTupleMember | TSNamespaceExportDeclaration | TSNeverKeyword | TSNonNullExpression | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSParameterProperty | TSPrivateKeyword | TSPropertySignature | TSProtectedKeyword | TSPublicKeyword | TSQualifiedName | TSReadonlyKeyword | TSRestType | TSSatisfiesExpression | TSStaticKeyword | TSStringKeyword | TSSymbolKeyword | TSTemplateLiteralType | TSThisType | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeLiteral | TSTypeOperator | TSTypeParameter | TSTypeParameterDeclaration | TSTypeParameterInstantiation | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword | UnaryExpression | UpdateExpression | VariableDeclaration | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
declare interface NodeOrTokenData {
    type: string;
    /**
     * The source location information of the node.
     *
     * The loc property is defined as nullable by ESTree, but ESLint requires this property.
     */
    loc: SourceLocation;
    range: Range;
}
declare interface NullLiteral extends LiteralBase {
    raw: 'null';
    value: null;
}
declare interface NullToken extends BaseToken {
    type: AST_TOKEN_TYPES.Null;
}
declare interface NumberLiteral extends LiteralBase {
    value: number;
}
declare interface NumericToken extends BaseToken {
    type: AST_TOKEN_TYPES.Numeric;
}
declare interface ObjectExpression extends BaseNode {
    type: AST_NODE_TYPES.ObjectExpression;
    properties: ObjectLiteralElement[];
}
declare type ObjectLiteralElement = Property | SpreadElement;
declare interface ObjectPattern extends BaseNode {
    type: AST_NODE_TYPES.ObjectPattern;
    decorators: Decorator[];
    optional: boolean;
    properties: (Property | RestElement)[];
    typeAnnotation: TSTypeAnnotation | undefined;
}
declare type Parameter = ArrayPattern | AssignmentPattern | Identifier | ObjectPattern | RestElement | TSParameterProperty;
declare interface Position {
    /**
     * Column number on the line (0-indexed)
     */
    column: number;
    /**
     * Line number (1-indexed)
     */
    line: number;
}
declare interface PrivateIdentifier extends BaseNode {
    type: AST_NODE_TYPES.PrivateIdentifier;
    name: string;
}
declare interface Program extends NodeOrTokenData {
    type: AST_NODE_TYPES.Program;
    body: ProgramStatement[];
    comments: Comment[] | undefined;
    sourceType: 'module' | 'script';
    tokens: Token[] | undefined;
}
declare type ProgramStatement = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration | Statement | TSImportEqualsDeclaration | TSNamespaceExportDeclaration;
declare type Property = PropertyComputedName | PropertyNonComputedName;
declare interface PropertyBase extends BaseNode {
    type: AST_NODE_TYPES.Property;
    computed: boolean;
    key: PropertyName;
    kind: 'get' | 'init' | 'set';
    method: boolean;
    optional: boolean;
    shorthand: boolean;
    value: AssignmentPattern | BindingName | Expression | TSEmptyBodyFunctionExpression;
}
declare interface PropertyComputedName extends PropertyBase {
    computed: true;
    key: PropertyNameComputed;
}
declare type PropertyDefinition = PropertyDefinitionComputedName | PropertyDefinitionNonComputedName;
declare interface PropertyDefinitionBase extends BaseNode {
    accessibility: Accessibility | undefined;
    computed: boolean;
    declare: boolean;
    decorators: Decorator[];
    definite: boolean;
    key: PropertyName;
    optional: boolean;
    override: boolean;
    readonly: boolean;
    static: boolean;
    typeAnnotation: TSTypeAnnotation | undefined;
    value: Expression | null;
}
declare interface PropertyDefinitionComputedName extends PropertyDefinitionComputedNameBase {
    type: AST_NODE_TYPES.PropertyDefinition;
}
declare interface PropertyDefinitionComputedNameBase extends PropertyDefinitionBase {
    computed: true;
    key: PropertyNameComputed;
}
declare interface PropertyDefinitionNonComputedName extends ClassPropertyDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.PropertyDefinition;
}
declare interface PropertyDefinitionNonComputedNameBase extends PropertyDefinitionBase {
    computed: false;
    key: PropertyNameNonComputed;
}
declare type PropertyName = ClassPropertyNameNonComputed | PropertyNameComputed | PropertyNameNonComputed;
declare type PropertyNameComputed = Expression;
declare type PropertyNameNonComputed = Identifier | NumberLiteral | StringLiteral;
declare interface PropertyNonComputedName extends PropertyBase {
    computed: false;
    key: PropertyNameNonComputed;
}
declare interface PunctuatorToken extends BaseToken {
    type: AST_TOKEN_TYPES.Punctuator;
    value: ValueOf<PunctuatorTokenToText>;
}
declare interface PunctuatorTokenToText extends AssignmentOperatorToText {
    [SyntaxKind.AmpersandAmpersandToken]: '&&';
    [SyntaxKind.AmpersandToken]: '&';
    [SyntaxKind.AsteriskAsteriskToken]: '**';
    [SyntaxKind.AsteriskToken]: '*';
    [SyntaxKind.AtToken]: '@';
    [SyntaxKind.BacktickToken]: '`';
    [SyntaxKind.BarBarToken]: '||';
    [SyntaxKind.BarToken]: '|';
    [SyntaxKind.CaretToken]: '^';
    [SyntaxKind.CloseBraceToken]: '}';
    [SyntaxKind.CloseBracketToken]: ']';
    [SyntaxKind.CloseParenToken]: ')';
    [SyntaxKind.ColonToken]: ':';
    [SyntaxKind.CommaToken]: ',';
    [SyntaxKind.DotDotDotToken]: '...';
    [SyntaxKind.DotToken]: '.';
    [SyntaxKind.EqualsEqualsEqualsToken]: '===';
    [SyntaxKind.EqualsEqualsToken]: '==';
    [SyntaxKind.EqualsGreaterThanToken]: '=>';
    [SyntaxKind.ExclamationEqualsEqualsToken]: '!==';
    [SyntaxKind.ExclamationEqualsToken]: '!=';
    [SyntaxKind.ExclamationToken]: '!';
    [SyntaxKind.GreaterThanEqualsToken]: '>=';
    [SyntaxKind.GreaterThanGreaterThanGreaterThanToken]: '>>>';
    [SyntaxKind.GreaterThanGreaterThanToken]: '>>';
    [SyntaxKind.GreaterThanToken]: '>';
    [SyntaxKind.HashToken]: '#';
    [SyntaxKind.LessThanEqualsToken]: '<=';
    [SyntaxKind.LessThanLessThanToken]: '<<';
    [SyntaxKind.LessThanSlashToken]: '</';
    [SyntaxKind.LessThanToken]: '<';
    [SyntaxKind.MinusMinusToken]: '--';
    [SyntaxKind.MinusToken]: '-';
    [SyntaxKind.OpenBraceToken]: '{';
    [SyntaxKind.OpenBracketToken]: '[';
    [SyntaxKind.OpenParenToken]: '(';
    [SyntaxKind.PercentToken]: '%';
    [SyntaxKind.PlusPlusToken]: '++';
    [SyntaxKind.PlusToken]: '+';
    [SyntaxKind.QuestionDotToken]: '?.';
    [SyntaxKind.QuestionQuestionToken]: '??';
    [SyntaxKind.QuestionToken]: '?';
    [SyntaxKind.SemicolonToken]: ';';
    [SyntaxKind.SlashToken]: '/';
    [SyntaxKind.TildeToken]: '~';
}
/**
 * An array of two numbers.
 * Both numbers are a 0-based index which is the position in the array of source code characters.
 * The first is the start position of the node, the second is the end position of the node.
 */
declare type Range = [number, number];
declare interface RegExpLiteral extends LiteralBase {
    regex: {
        flags: string;
        pattern: string;
    };
    value: RegExp | null;
}
declare interface RegularExpressionToken extends BaseToken {
    type: AST_TOKEN_TYPES.RegularExpression;
    regex: {
        flags: string;
        pattern: string;
    };
}
declare interface RestElement extends BaseNode {
    type: AST_NODE_TYPES.RestElement;
    argument: DestructuringPattern;
    decorators: Decorator[];
    optional: boolean;
    typeAnnotation: TSTypeAnnotation | undefined;
    value: AssignmentPattern | undefined;
}
declare interface ReturnStatement extends BaseNode {
    type: AST_NODE_TYPES.ReturnStatement;
    argument: Expression | null;
}
declare interface SequenceExpression extends BaseNode {
    type: AST_NODE_TYPES.SequenceExpression;
    expressions: Expression[];
}
declare interface SourceLocation {
    /**
     * The position of the first character after the parsed source region
     */
    end: Position;
    /**
     * The position of the first character of the parsed source region
     */
    start: Position;
}
declare interface SpreadElement extends BaseNode {
    type: AST_NODE_TYPES.SpreadElement;
    argument: Expression;
}
declare type Statement = BlockStatement | BreakStatement | ClassDeclarationWithName | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclarationWithName | IfStatement | ImportDeclaration | LabeledStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | TSDeclareFunction | TSEnumDeclaration | TSExportAssignment | TSImportEqualsDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSNamespaceExportDeclaration | TSTypeAliasDeclaration | VariableDeclaration | WhileStatement | WithStatement;
declare interface StaticBlock extends BaseNode {
    type: AST_NODE_TYPES.StaticBlock;
    body: Statement[];
}
declare interface StringLiteral extends LiteralBase {
    value: string;
}
declare interface StringToken extends BaseToken {
    type: AST_TOKEN_TYPES.String;
}
declare interface Super extends BaseNode {
    type: AST_NODE_TYPES.Super;
}
declare interface SwitchCase extends BaseNode {
    type: AST_NODE_TYPES.SwitchCase;
    consequent: Statement[];
    test: Expression | null;
}
declare interface SwitchStatement extends BaseNode {
    type: AST_NODE_TYPES.SwitchStatement;
    cases: SwitchCase[];
    discriminant: Expression;
}
declare interface TaggedTemplateExpression extends BaseNode {
    type: AST_NODE_TYPES.TaggedTemplateExpression;
    quasi: TemplateLiteral;
    tag: Expression;
    typeArguments: TSTypeParameterInstantiation | undefined;
}
declare interface TemplateElement extends BaseNode {
    type: AST_NODE_TYPES.TemplateElement;
    tail: boolean;
    value: {
        cooked: string;
        raw: string;
    };
}
declare interface TemplateLiteral extends BaseNode {
    type: AST_NODE_TYPES.TemplateLiteral;
    expressions: Expression[];
    quasis: TemplateElement[];
}
declare interface TemplateToken extends BaseToken {
    type: AST_TOKEN_TYPES.Template;
}
declare interface ThisExpression extends BaseNode {
    type: AST_NODE_TYPES.ThisExpression;
}
declare interface ThrowStatement extends BaseNode {
    type: AST_NODE_TYPES.ThrowStatement;
    argument: Expression;
}
declare type Token = BooleanToken | Comment | IdentifierToken | JSXIdentifierToken | JSXTextToken | KeywordToken | NullToken | NumericToken | PunctuatorToken | RegularExpressionToken | StringToken | TemplateToken;
declare interface TryStatement extends BaseNode {
    type: AST_NODE_TYPES.TryStatement;
    block: BlockStatement;
    finalizer: BlockStatement | null;
    handler: CatchClause | null;
}
declare type TSAbstractAccessorProperty = TSAbstractAccessorPropertyComputedName | TSAbstractAccessorPropertyNonComputedName;
declare interface TSAbstractAccessorPropertyComputedName extends PropertyDefinitionComputedNameBase {
    type: AST_NODE_TYPES.TSAbstractAccessorProperty;
    value: null;
}
declare interface TSAbstractAccessorPropertyNonComputedName extends PropertyDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.TSAbstractAccessorProperty;
    value: null;
}
declare interface TSAbstractKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSAbstractKeyword;
}
declare type TSAbstractMethodDefinition = TSAbstractMethodDefinitionComputedName | TSAbstractMethodDefinitionNonComputedName;
declare interface TSAbstractMethodDefinitionComputedName extends MethodDefinitionComputedNameBase {
    type: AST_NODE_TYPES.TSAbstractMethodDefinition;
}
declare interface TSAbstractMethodDefinitionNonComputedName extends MethodDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.TSAbstractMethodDefinition;
}
declare type TSAbstractPropertyDefinition = TSAbstractPropertyDefinitionComputedName | TSAbstractPropertyDefinitionNonComputedName;
declare interface TSAbstractPropertyDefinitionComputedName extends PropertyDefinitionComputedNameBase {
    type: AST_NODE_TYPES.TSAbstractPropertyDefinition;
    value: null;
}
declare interface TSAbstractPropertyDefinitionNonComputedName extends PropertyDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.TSAbstractPropertyDefinition;
    value: null;
}
declare interface TSAnyKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSAnyKeyword;
}
declare interface TSArrayType extends BaseNode {
    type: AST_NODE_TYPES.TSArrayType;
    elementType: TypeNode;
}
declare interface TSAsExpression extends BaseNode {
    type: AST_NODE_TYPES.TSAsExpression;
    expression: Expression;
    typeAnnotation: TypeNode;
}
declare interface TSAsyncKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSAsyncKeyword;
}
declare interface TSBigIntKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSBigIntKeyword;
}
declare interface TSBooleanKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSBooleanKeyword;
}
declare interface TSCallSignatureDeclaration extends TSFunctionSignatureBase {
    type: AST_NODE_TYPES.TSCallSignatureDeclaration;
}
declare interface TSClassImplements extends TSHeritageBase {
    type: AST_NODE_TYPES.TSClassImplements;
}
declare interface TSConditionalType extends BaseNode {
    type: AST_NODE_TYPES.TSConditionalType;
    checkType: TypeNode;
    extendsType: TypeNode;
    falseType: TypeNode;
    trueType: TypeNode;
}
declare interface TSConstructorType extends TSFunctionSignatureBase {
    type: AST_NODE_TYPES.TSConstructorType;
    abstract: boolean;
}
declare interface TSConstructSignatureDeclaration extends TSFunctionSignatureBase {
    type: AST_NODE_TYPES.TSConstructSignatureDeclaration;
}
declare type TSDeclareFunction = TSDeclareFunctionNoDeclare | TSDeclareFunctionWithDeclare;
declare interface TSDeclareFunctionBase extends FunctionBase {
    type: AST_NODE_TYPES.TSDeclareFunction;
    /**
     * TS1183: An implementation cannot be declared in ambient contexts.
     */
    body: undefined;
    /**
     * Whether the declaration has `declare` modifier.
     */
    declare: boolean;
    expression: false;
}
/**
 * Function declaration without the `declare` keyword:
 * ```
 * function foo(): void;
 * ```
 * This can either be an overload signature or a declaration in an ambient context
 * (e.g. `declare module`)
 */
declare interface TSDeclareFunctionNoDeclare extends TSDeclareFunctionBase {
    declare: false;
    /**
     * - TS1221: Generators are not allowed in an ambient context.
     * - TS1222: An overload signature cannot be declared as a generator.
     */
    generator: false;
}
/**
 * Function declaration with the `declare` keyword:
 * ```
 * declare function foo(): void;
 * ```
 */
declare interface TSDeclareFunctionWithDeclare extends TSDeclareFunctionBase {
    /**
     * TS1040: 'async' modifier cannot be used in an ambient context.
     */
    async: false;
    declare: true;
    /**
     * TS1221: Generators are not allowed in an ambient context.
     */
    generator: false;
}
declare interface TSDeclareKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSDeclareKeyword;
}
declare interface TSEmptyBodyFunctionExpression extends FunctionBase {
    type: AST_NODE_TYPES.TSEmptyBodyFunctionExpression;
    body: null;
    id: null;
}
declare interface TSEnumBody extends BaseNode {
    type: AST_NODE_TYPES.TSEnumBody;
    members: TSEnumMember[];
}
declare interface TSEnumDeclaration extends BaseNode {
    type: AST_NODE_TYPES.TSEnumDeclaration;
    /**
     * The body of the enum.
     */
    body: TSEnumBody;
    /**
     * Whether this is a `const` enum.
     * @example
     * ```ts
     * const enum Foo {}
     * ```
     */
    const: boolean;
    /**
     * Whether this is a `declare`d enum.
     * @example
     * ```ts
     * declare enum Foo {}
     * ```
     */
    declare: boolean;
    /**
     * The enum name.
     */
    id: Identifier;
    /**
     * The enum members.
     * @deprecated Use {@link body} instead.
     */
    members: TSEnumMember[];
}
declare type TSEnumMember = TSEnumMemberComputedName | TSEnumMemberNonComputedName;
declare interface TSEnumMemberBase extends BaseNode {
    type: AST_NODE_TYPES.TSEnumMember;
    computed: boolean;
    id: PropertyNameComputed | PropertyNameNonComputed;
    initializer: Expression | undefined;
}
/**
 * this should only really happen in semantically invalid code (errors 1164 and 2452)
 *
 * @example
 * ```ts
 * // VALID:
 * enum Foo { ['a'] }
 *
 * // INVALID:
 * const x = 'a';
 * enum Foo { [x] }
 * enum Bar { ['a' + 'b'] }
 * ```
 */
declare interface TSEnumMemberComputedName extends TSEnumMemberBase {
    computed: true;
    id: PropertyNameComputed;
}
declare interface TSEnumMemberNonComputedName extends TSEnumMemberBase {
    computed: false;
    id: PropertyNameNonComputed;
}
declare interface TSExportAssignment extends BaseNode {
    type: AST_NODE_TYPES.TSExportAssignment;
    expression: Expression;
}
declare interface TSExportKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSExportKeyword;
}
declare interface TSExternalModuleReference extends BaseNode {
    type: AST_NODE_TYPES.TSExternalModuleReference;
    expression: StringLiteral;
}
declare interface TSFunctionSignatureBase extends BaseNode {
    params: Parameter[];
    returnType: TSTypeAnnotation | undefined;
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare interface TSFunctionType extends TSFunctionSignatureBase {
    type: AST_NODE_TYPES.TSFunctionType;
}
declare interface TSHeritageBase extends BaseNode {
    expression: Expression;
    typeArguments: TSTypeParameterInstantiation | undefined;
}
declare type TSImportEqualsDeclaration = TSImportEqualsNamespaceDeclaration | TSImportEqualsRequireDeclaration;
declare interface TSImportEqualsDeclarationBase extends BaseNode {
    type: AST_NODE_TYPES.TSImportEqualsDeclaration;
    /**
     * The locally imported name.
     */
    id: Identifier;
    /**
     * The kind of the import. Always `'value'` unless `moduleReference` is a
     * `TSExternalModuleReference`.
     */
    importKind: ImportKind;
    /**
     * The value being aliased.
     * @example
     * ```ts
     * import F1 = A;
     * import F2 = A.B.C;
     * import F3 = require('mod');
     * ```
     */
    moduleReference: Identifier | TSExternalModuleReference | TSQualifiedName;
}
declare interface TSImportEqualsNamespaceDeclaration extends TSImportEqualsDeclarationBase {
    /**
     * The kind of the import.
     */
    importKind: 'value';
    /**
     * The value being aliased.
     * ```
     * import F1 = A;
     * import F2 = A.B.C;
     * ```
     */
    moduleReference: Identifier | TSQualifiedName;
}
declare interface TSImportEqualsRequireDeclaration extends TSImportEqualsDeclarationBase {
    /**
     * The kind of the import.
     */
    importKind: ImportKind;
    /**
     * The value being aliased.
     * ```
     * import F3 = require('mod');
     * ```
     */
    moduleReference: TSExternalModuleReference;
}
declare interface TSImportType extends BaseNode {
    type: AST_NODE_TYPES.TSImportType;
    argument: TypeNode;
    qualifier: EntityName | null;
    typeArguments: TSTypeParameterInstantiation | null;
}
declare interface TSIndexedAccessType extends BaseNode {
    type: AST_NODE_TYPES.TSIndexedAccessType;
    indexType: TypeNode;
    objectType: TypeNode;
}
declare interface TSIndexSignature extends BaseNode {
    type: AST_NODE_TYPES.TSIndexSignature;
    accessibility: Accessibility | undefined;
    parameters: Parameter[];
    readonly: boolean;
    static: boolean;
    typeAnnotation: TSTypeAnnotation | undefined;
}
declare interface TSInferType extends BaseNode {
    type: AST_NODE_TYPES.TSInferType;
    typeParameter: TSTypeParameter;
}
declare interface TSInstantiationExpression extends BaseNode {
    type: AST_NODE_TYPES.TSInstantiationExpression;
    expression: Expression;
    typeArguments: TSTypeParameterInstantiation;
}
declare interface TSInterfaceBody extends BaseNode {
    type: AST_NODE_TYPES.TSInterfaceBody;
    body: TypeElement[];
}
declare interface TSInterfaceDeclaration extends BaseNode {
    type: AST_NODE_TYPES.TSInterfaceDeclaration;
    /**
     * The body of the interface
     */
    body: TSInterfaceBody;
    /**
     * Whether the interface was `declare`d
     */
    declare: boolean;
    /**
     * The types this interface `extends`
     */
    extends: TSInterfaceHeritage[];
    /**
     * The name of this interface
     */
    id: Identifier;
    /**
     * The generic type parameters declared for the interface. Empty declaration
     * (`<>`) is different from no declaration.
     */
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare interface TSInterfaceHeritage extends TSHeritageBase {
    type: AST_NODE_TYPES.TSInterfaceHeritage;
}
declare interface TSIntersectionType extends BaseNode {
    type: AST_NODE_TYPES.TSIntersectionType;
    types: TypeNode[];
}
declare interface TSIntrinsicKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSIntrinsicKeyword;
}
declare interface TSLiteralType extends BaseNode {
    type: AST_NODE_TYPES.TSLiteralType;
    literal: LiteralExpression | UnaryExpression | UpdateExpression;
}
declare interface TSMappedType extends BaseNode {
    type: AST_NODE_TYPES.TSMappedType;
    constraint: TypeNode;
    key: Identifier;
    nameType: TypeNode | null;
    optional: boolean | '+' | '-' | undefined;
    readonly: boolean | '+' | '-' | undefined;
    typeAnnotation: TypeNode | undefined;
    /** @deprecated Use {@link `constraint`} and {@link `key`} instead. */
    typeParameter: TSTypeParameter;
}
declare type TSMethodSignature = TSMethodSignatureComputedName | TSMethodSignatureNonComputedName;
declare interface TSMethodSignatureBase extends BaseNode {
    type: AST_NODE_TYPES.TSMethodSignature;
    accessibility: Accessibility | undefined;
    computed: boolean;
    key: PropertyName;
    kind: 'get' | 'method' | 'set';
    optional: boolean;
    params: Parameter[];
    readonly: boolean;
    returnType: TSTypeAnnotation | undefined;
    static: boolean;
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare interface TSMethodSignatureComputedName extends TSMethodSignatureBase {
    computed: true;
    key: PropertyNameComputed;
}
declare interface TSMethodSignatureNonComputedName extends TSMethodSignatureBase {
    computed: false;
    key: PropertyNameNonComputed;
}
declare interface TSModuleBlock extends BaseNode {
    type: AST_NODE_TYPES.TSModuleBlock;
    body: ProgramStatement[];
}
declare type TSModuleDeclaration = TSModuleDeclarationGlobal | TSModuleDeclarationModule | TSModuleDeclarationNamespace;
declare interface TSModuleDeclarationBase extends BaseNode {
    type: AST_NODE_TYPES.TSModuleDeclaration;
    /**
     * The body of the module.
     * This can only be `undefined` for the code `declare module 'mod';`
     */
    body?: TSModuleBlock;
    /**
     * Whether the module is `declare`d
     * @example
     * ```ts
     * declare namespace F {}
     * ```
     */
    declare: boolean;
    /**
     * Whether this is a global declaration
     * @example
     * ```ts
     * declare global {}
     * ```
     *
     * @deprecated Use {@link kind} instead
     */
    global: boolean;
    /**
     * The name of the module
     * ```
     * namespace A {}
     * namespace A.B.C {}
     * module 'a' {}
     * ```
     */
    id: Identifier | Literal | TSQualifiedName;
    /**
     * The keyword used to define this module declaration
     * @example
     * ```ts
     * namespace Foo {}
     * ^^^^^^^^^
     *
     * module 'foo' {}
     * ^^^^^^
     *
     * global {}
     * ^^^^^^
     * ```
     */
    kind: TSModuleDeclarationKind;
}
declare interface TSModuleDeclarationGlobal extends TSModuleDeclarationBase {
    body: TSModuleBlock;
    /**
     * This will always be an Identifier with name `global`
     */
    id: Identifier;
    kind: 'global';
}
declare type TSModuleDeclarationKind = 'global' | 'module' | 'namespace';
declare type TSModuleDeclarationModule = TSModuleDeclarationModuleWithIdentifierId | TSModuleDeclarationModuleWithStringId;
declare interface TSModuleDeclarationModuleBase extends TSModuleDeclarationBase {
    kind: 'module';
}
/**
 * The legacy module declaration, replaced with namespace declarations.
 * ```
 * module A {}
 * ```
 */
declare interface TSModuleDeclarationModuleWithIdentifierId extends TSModuleDeclarationModuleBase {
    body: TSModuleBlock;
    id: Identifier;
    kind: 'module';
}
declare type TSModuleDeclarationModuleWithStringId = TSModuleDeclarationModuleWithStringIdDeclared | TSModuleDeclarationModuleWithStringIdNotDeclared;
/**
 * A string module declaration that is declared:
 * ```
 * declare module 'foo' {}
 * declare module 'foo';
 * ```
 */
declare interface TSModuleDeclarationModuleWithStringIdDeclared extends TSModuleDeclarationModuleBase {
    body?: TSModuleBlock;
    declare: true;
    id: StringLiteral;
    kind: 'module';
}
/**
 * A string module declaration that is not declared:
 * ```
 * module 'foo' {}
 * ```
 */
declare interface TSModuleDeclarationModuleWithStringIdNotDeclared extends TSModuleDeclarationModuleBase {
    body: TSModuleBlock;
    declare: false;
    id: StringLiteral;
    kind: 'module';
}
declare interface TSModuleDeclarationNamespace extends TSModuleDeclarationBase {
    body: TSModuleBlock;
    id: Identifier | TSQualifiedName;
    kind: 'namespace';
}
declare interface TSNamedTupleMember extends BaseNode {
    type: AST_NODE_TYPES.TSNamedTupleMember;
    elementType: TypeNode;
    label: Identifier;
    optional: boolean;
}
/**
 * For the following declaration:
 * ```
 * export as namespace X;
 * ```
 */
declare interface TSNamespaceExportDeclaration extends BaseNode {
    type: AST_NODE_TYPES.TSNamespaceExportDeclaration;
    /**
     * The name of the global variable that's exported as namespace
     */
    id: Identifier;
}
declare interface TSNeverKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSNeverKeyword;
}
declare interface TSNonNullExpression extends BaseNode {
    type: AST_NODE_TYPES.TSNonNullExpression;
    expression: Expression;
}
declare interface TSNullKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSNullKeyword;
}
declare interface TSNumberKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSNumberKeyword;
}
declare interface TSObjectKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSObjectKeyword;
}
declare interface TSOptionalType extends BaseNode {
    type: AST_NODE_TYPES.TSOptionalType;
    typeAnnotation: TypeNode;
}
declare interface TSParameterProperty extends BaseNode {
    type: AST_NODE_TYPES.TSParameterProperty;
    accessibility: Accessibility | undefined;
    decorators: Decorator[];
    override: boolean;
    parameter: AssignmentPattern | BindingName | RestElement;
    readonly: boolean;
    static: boolean;
}
declare interface TSPrivateKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSPrivateKeyword;
}
declare type TSPropertySignature = TSPropertySignatureComputedName | TSPropertySignatureNonComputedName;
declare interface TSPropertySignatureBase extends BaseNode {
    type: AST_NODE_TYPES.TSPropertySignature;
    accessibility: Accessibility | undefined;
    computed: boolean;
    key: PropertyName;
    optional: boolean;
    readonly: boolean;
    static: boolean;
    typeAnnotation: TSTypeAnnotation | undefined;
}
declare interface TSPropertySignatureComputedName extends TSPropertySignatureBase {
    computed: true;
    key: PropertyNameComputed;
}
declare interface TSPropertySignatureNonComputedName extends TSPropertySignatureBase {
    computed: false;
    key: PropertyNameNonComputed;
}
declare interface TSProtectedKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSProtectedKeyword;
}
declare interface TSPublicKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSPublicKeyword;
}
declare interface TSQualifiedName extends BaseNode {
    type: AST_NODE_TYPES.TSQualifiedName;
    left: EntityName;
    right: Identifier;
}
declare interface TSReadonlyKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSReadonlyKeyword;
}
declare interface TSRestType extends BaseNode {
    type: AST_NODE_TYPES.TSRestType;
    typeAnnotation: TypeNode;
}
declare interface TSSatisfiesExpression extends BaseNode {
    type: AST_NODE_TYPES.TSSatisfiesExpression;
    expression: Expression;
    typeAnnotation: TypeNode;
}
declare interface TSStaticKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSStaticKeyword;
}
declare interface TSStringKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSStringKeyword;
}
declare interface TSSymbolKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSSymbolKeyword;
}
declare interface TSTemplateLiteralType extends BaseNode {
    type: AST_NODE_TYPES.TSTemplateLiteralType;
    quasis: TemplateElement[];
    types: TypeNode[];
}
declare interface TSThisType extends BaseNode {
    type: AST_NODE_TYPES.TSThisType;
}
declare interface TSTupleType extends BaseNode {
    type: AST_NODE_TYPES.TSTupleType;
    elementTypes: TypeNode[];
}
declare interface TSTypeAliasDeclaration extends BaseNode {
    type: AST_NODE_TYPES.TSTypeAliasDeclaration;
    /**
     * Whether the type was `declare`d.
     * @example
     * ```ts
     * declare type T = 1;
     * ```
     */
    declare: boolean;
    /**
     * The name of the type.
     */
    id: Identifier;
    /**
     * The "value" (type) of the declaration
     */
    typeAnnotation: TypeNode;
    /**
     * The generic type parameters declared for the type. Empty declaration
     * (`<>`) is different from no declaration.
     */
    typeParameters: TSTypeParameterDeclaration | undefined;
}
declare interface TSTypeAnnotation extends BaseNode {
    type: AST_NODE_TYPES.TSTypeAnnotation;
    typeAnnotation: TypeNode;
}
declare interface TSTypeAssertion extends BaseNode {
    type: AST_NODE_TYPES.TSTypeAssertion;
    expression: Expression;
    typeAnnotation: TypeNode;
}
declare interface TSTypeLiteral extends BaseNode {
    type: AST_NODE_TYPES.TSTypeLiteral;
    members: TypeElement[];
}
declare interface TSTypeOperator extends BaseNode {
    type: AST_NODE_TYPES.TSTypeOperator;
    operator: 'keyof' | 'readonly' | 'unique';
    typeAnnotation: TypeNode | undefined;
}
declare interface TSTypeParameter extends BaseNode {
    type: AST_NODE_TYPES.TSTypeParameter;
    const: boolean;
    constraint: TypeNode | undefined;
    default: TypeNode | undefined;
    in: boolean;
    name: Identifier;
    out: boolean;
}
declare interface TSTypeParameterDeclaration extends BaseNode {
    type: AST_NODE_TYPES.TSTypeParameterDeclaration;
    params: TSTypeParameter[];
}
declare interface TSTypeParameterInstantiation extends BaseNode {
    type: AST_NODE_TYPES.TSTypeParameterInstantiation;
    params: TypeNode[];
}
declare interface TSTypePredicate extends BaseNode {
    type: AST_NODE_TYPES.TSTypePredicate;
    asserts: boolean;
    parameterName: Identifier | TSThisType;
    typeAnnotation: TSTypeAnnotation | null;
}
declare interface TSTypeQuery extends BaseNode {
    type: AST_NODE_TYPES.TSTypeQuery;
    exprName: EntityName | TSImportType;
    typeArguments: TSTypeParameterInstantiation | undefined;
}
declare interface TSTypeReference extends BaseNode {
    type: AST_NODE_TYPES.TSTypeReference;
    typeArguments: TSTypeParameterInstantiation | undefined;
    typeName: EntityName;
}
declare interface TSUndefinedKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSUndefinedKeyword;
}
declare interface TSUnionType extends BaseNode {
    type: AST_NODE_TYPES.TSUnionType;
    types: TypeNode[];
}
declare interface TSUnknownKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSUnknownKeyword;
}
declare interface TSVoidKeyword extends BaseNode {
    type: AST_NODE_TYPES.TSVoidKeyword;
}
declare type TypeElement = TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSIndexSignature | TSMethodSignature | TSPropertySignature;
declare type TypeNode = TSAbstractKeyword | TSAnyKeyword | TSArrayType | TSAsyncKeyword | TSBigIntKeyword | TSBooleanKeyword | TSConditionalType | TSConstructorType | TSDeclareKeyword | TSExportKeyword | TSFunctionType | TSImportType | TSIndexedAccessType | TSInferType | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSNamedTupleMember | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSPrivateKeyword | TSProtectedKeyword | TSPublicKeyword | TSQualifiedName | TSReadonlyKeyword | TSRestType | TSStaticKeyword | TSStringKeyword | TSSymbolKeyword | TSTemplateLiteralType | TSThisType | TSTupleType | TSTypeLiteral | TSTypeOperator | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword;
declare interface UnaryExpression extends UnaryExpressionBase {
    type: AST_NODE_TYPES.UnaryExpression;
    operator: '!' | '+' | '~' | '-' | 'delete' | 'typeof' | 'void';
}
declare interface UnaryExpressionBase extends BaseNode {
    argument: Expression;
    operator: string;
    prefix: boolean;
}
declare interface UpdateExpression extends UnaryExpressionBase {
    type: AST_NODE_TYPES.UpdateExpression;
    operator: '++' | '--';
}
declare type UsingDeclaration = UsingInForOfDeclaration | UsingInNormalContextDeclaration;
declare interface UsingDeclarationBase extends BaseNode {
    type: AST_NODE_TYPES.VariableDeclaration;
    /**
     * This value will always be `false`
     * because 'declare' modifier cannot appear on a 'using' declaration.
     */
    declare: false;
    /**
     * The keyword used to declare the variable(s)
     * @example
     * ```ts
     * using x = 1;
     * await using y = 2;
     * ```
     */
    kind: 'await using' | 'using';
}
declare type UsingDeclarator = UsingInForOfDeclarator | UsingInNormalContextDeclarator;
declare interface UsingInForOfDeclaration extends UsingDeclarationBase {
    /**
     * The variables declared by this declaration.
     * Always has exactly one element.
     * @example
     * ```ts
     * for (using x of y) {}
     * ```
     */
    declarations: [UsingInForOfDeclarator];
}
declare interface UsingInForOfDeclarator extends VariableDeclaratorBase {
    definite: false;
    id: Identifier;
    init: null;
}
declare interface UsingInNormalContextDeclaration extends UsingDeclarationBase {
    /**
     * The variables declared by this declaration.
     * Always non-empty.
     * @example
     * ```ts
     * using x = 1;
     * using y = 1, z = 2;
     * ```
     */
    declarations: UsingInNormalContextDeclarator[];
}
declare interface UsingInNormalContextDeclarator extends VariableDeclaratorBase {
    definite: false;
    id: Identifier;
    init: Expression;
}
declare type ValueOf<T> = T[keyof T];
declare type VariableDeclaration = LetOrConstOrVarDeclaration | UsingDeclaration;
declare type VariableDeclarator = LetOrConstOrVarDeclarator | UsingDeclarator;
declare interface VariableDeclaratorBase extends BaseNode {
    type: AST_NODE_TYPES.VariableDeclarator;
    /**
     * Whether there's definite assignment assertion (`let x!: number`).
     * If `true`, then: `id` must be an identifier with a type annotation,
     * `init` must be `null`, and the declarator must be a `var`/`let` declarator.
     */
    definite: boolean;
    /**
     * The name(s) of the variable(s).
     */
    id: BindingName;
    /**
     * The initializer expression of the variable. Must be present for `const` unless
     * in a `declare const`.
     */
    init: Expression | null;
}
declare interface VariableDeclaratorDefiniteAssignment extends VariableDeclaratorBase {
    definite: true;
    /**
     * The name of the variable. Must have a type annotation.
     */
    id: Identifier;
    init: null;
}
declare interface VariableDeclaratorMaybeInit extends VariableDeclaratorBase {
    definite: false;
}
declare interface VariableDeclaratorNoInit extends VariableDeclaratorBase {
    definite: false;
    init: null;
}
declare interface WhileStatement extends BaseNode {
    type: AST_NODE_TYPES.WhileStatement;
    body: Statement;
    test: Expression;
}
declare interface WithStatement extends BaseNode {
    type: AST_NODE_TYPES.WithStatement;
    body: Statement;
    object: Expression;
}
declare interface YieldExpression extends BaseNode {
    type: AST_NODE_TYPES.YieldExpression;
    argument: Expression | undefined;
    delegate: boolean;
}

/**
 * Get all nested call expressions in a expression like node
 * @param node The node to get the nested call expressions from
 * @returns All nested call expressions
 */
declare const getNestedCallExpressions: (node: Node) => CallExpression[];

/**
 * Get all nested identifiers in a expression like node
 * @param node The node to get the nested identifiers from
 * @returns All nested identifiers
 */
declare function getNestedIdentifiers(node: TSESTree$1.Node): readonly TSESTree$1.Identifier[];

/**
 * Get all nested new expressions in an expression like node
 * @param node The node to get the nested new expressions from
 * @returns All nested new expressions
 */
declare const getNestedNewExpressions: (node: Node) => NewExpression[];

/**
 * Gets the nested return statements in the node that are within the same function
 * @param node The AST node
 * @returns The nested return statements in the node
 */
declare function getNestedReturnStatements(node: TSESTree$1.Node): readonly TSESTree$1.ReturnStatement[];

declare function getTopLevelIdentifier(node: TSESTree$1.Node): O.Option<TSESTree$1.Identifier>;

declare const is: <NodeType extends AST_NODE_TYPES$1>(nodeType: NodeType) => (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: NodeType;
}>;
declare const isOneOf: <NodeTypes extends readonly AST_NODE_TYPES$1[]>(nodeTypes: NodeTypes) => (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: NodeTypes[number];
}>;
declare const isFunction: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrowFunctionExpression | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName | TSESTree.FunctionExpression;
declare const isFunctionType: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrowFunctionExpression | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName | TSESTree.FunctionExpression | TSESTree.TSCallSignatureDeclaration | TSESTree.TSConstructSignatureDeclaration | TSESTree.TSDeclareFunctionNoDeclare | TSESTree.TSDeclareFunctionWithDeclare | TSESTree.TSEmptyBodyFunctionExpression | TSESTree.TSFunctionType | TSESTree.TSMethodSignatureComputedName | TSESTree.TSMethodSignatureNonComputedName;
declare const isClass: (node: TSESTree.Node | null | undefined) => node is TSESTree.ClassDeclarationWithName | TSESTree.ClassDeclarationWithOptionalName | TSESTree.ClassExpression;
declare const isLoop: (node: TSESTree.Node | null | undefined) => node is TSESTree.DoWhileStatement | TSESTree.ForInStatement | TSESTree.ForOfStatement | TSESTree.ForStatement | TSESTree.WhileStatement;
declare const isControlFlow: effect_Predicate.Refinement<TSESTree.Node | null | undefined, TSESTree.DoWhileStatement | TSESTree.ForInStatement | TSESTree.ForOfStatement | TSESTree.ForStatement | TSESTree.WhileStatement | TSESTree.IfStatement | TSESTree.SwitchStatement>;
declare const isConditional: effect_Predicate.Refinement<TSESTree.Node | null | undefined, TSESTree.DoWhileStatement | TSESTree.ForInStatement | TSESTree.ForOfStatement | TSESTree.ForStatement | TSESTree.WhileStatement | TSESTree.ConditionalExpression | TSESTree.IfStatement | TSESTree.LogicalExpression | TSESTree.SwitchStatement>;
declare const isArrayTupleType: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSArrayType | TSESTree.TSTupleType;
declare const isProperty: (node: TSESTree.Node | null | undefined) => node is TSESTree.PropertyDefinitionComputedName | TSESTree.PropertyDefinitionNonComputedName | TSESTree.TSIndexSignature | TSESTree.TSParameterProperty | TSESTree.TSPropertySignatureComputedName | TSESTree.TSPropertySignatureNonComputedName;
declare const isJSXElement: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXElement;
declare const isJSXFragment: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXFragment;
declare const isJSX: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXAttribute | TSESTree.JSXElement | TSESTree.JSXExpressionContainer | TSESTree.JSXSpreadChild | TSESTree.JSXFragment | TSESTree.JSXText | TSESTree.JSXClosingElement | TSESTree.JSXClosingFragment | TSESTree.JSXEmptyExpression | TSESTree.JSXIdentifier | TSESTree.JSXMemberExpression | TSESTree.JSXNamespacedName | TSESTree.JSXOpeningElement | TSESTree.JSXOpeningFragment | TSESTree.JSXSpreadAttribute;
declare const isJSXTagNameExpression: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXIdentifier | TSESTree.JSXMemberExpression | TSESTree.JSXNamespacedName;
declare const isDestructuringPattern: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrayPattern | TSESTree.AssignmentPattern | TSESTree.ObjectPattern | TSESTree.RestElement;
declare const isTypeDeclaration: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSInterfaceDeclaration | TSESTree.TSTypeAliasDeclaration;
declare const isLeftHandSideExpression: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrowFunctionExpression | TSESTree.FunctionExpression | TSESTree.ClassExpression | TSESTree.JSXElement | TSESTree.JSXFragment | TSESTree.ArrayPattern | TSESTree.ObjectPattern | TSESTree.CallExpression | TSESTree.ObjectExpression | TSESTree.ArrayExpression | TSESTree.Identifier | TSESTree.BigIntLiteral | TSESTree.BooleanLiteral | TSESTree.NullLiteral | TSESTree.NumberLiteral | TSESTree.RegExpLiteral | TSESTree.StringLiteral | TSESTree.MemberExpressionComputedName | TSESTree.MemberExpressionNonComputedName | TSESTree.MetaProperty | TSESTree.SequenceExpression | TSESTree.Super | TSESTree.TaggedTemplateExpression | TSESTree.TemplateLiteral | TSESTree.ThisExpression;
declare const isLeftHandSideExpressionType: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrowFunctionExpression | TSESTree.FunctionExpression | TSESTree.ClassExpression | TSESTree.JSXElement | TSESTree.JSXFragment | TSESTree.ArrayPattern | TSESTree.ObjectPattern | TSESTree.CallExpression | TSESTree.ObjectExpression | TSESTree.ArrayExpression | TSESTree.Identifier | TSESTree.BigIntLiteral | TSESTree.BooleanLiteral | TSESTree.NullLiteral | TSESTree.NumberLiteral | TSESTree.RegExpLiteral | TSESTree.StringLiteral | TSESTree.MemberExpressionComputedName | TSESTree.MemberExpressionNonComputedName | TSESTree.MetaProperty | TSESTree.SequenceExpression | TSESTree.Super | TSESTree.TaggedTemplateExpression | TSESTree.TemplateLiteral | TSESTree.ThisExpression | TSESTree.TSAsExpression | TSESTree.TSNonNullExpression | TSESTree.TSTypeAssertion;

declare function isEmptyFunction(node: TSESTreeFunction): boolean;

/**
 * Checks if the given node is a function expression or arrow function expression of a class method.
 * @param node The node to check.
 * @returns `true` if the node is a function expression or arrow function expression of a class method, `false` otherwise.
 */
declare const isFunctionOfClassMethod: (node: TSESTree$1.Node) => boolean;

/**
 * Checks if the given node is a function expression or arrow function expression of a class property.
 * @param node The node to check.
 * @returns `true` if the node is a function expression or arrow function expression of a class property, `false` otherwise.
 */
declare const isFunctionOfClassProperty: (node: TSESTree$1.Node) => boolean;

declare function isFunctionOfImmediatelyInvoked(node: TSESTreeFunction): boolean;

/**
 * Checks if the given node is a function expression or arrow function expression of a object method.
 * @param node The node to check.
 * @returns `true` if the node is a function expression or arrow function expression of a object method, `false` otherwise.
 */
declare const isFunctionOfObjectMethod: (node: TSESTree$1.Node) => boolean;

declare function isKeyLiteralLike(node: TSESTree$1.MemberExpression | TSESTree$1.MethodDefinition | TSESTree$1.Property | TSESTree$1.PropertyDefinition, property: TSESTree$1.Node): boolean;

declare function isMapCallLoose(node: TSESTree$1.Node): node is TSESTree$1.CallExpression;

/**
 * Check if a node is multiline
 * @param node The AST node to check
 * @returns  `true` if the node is multiline
 */
declare function isMultiLine(node: TSESTree$1.Node): boolean;

/**
 * Determines whether node equals to another node
 * @param a node to compare
 * @param b node to compare
 * @returns `true` if node equal
 * @see https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/src/util/isNodeEqual.ts
 */
declare const isNodeEqual: {
    (a: TSESTree$1.Node): (b: TSESTree$1.Node) => boolean;
    (a: TSESTree$1.Node, b: TSESTree$1.Node): boolean;
};

declare function isRegExpLiteral(node: TSESTree$1.Node): node is TSESTree$1.RegExpLiteral;

declare function isStringLiteral(node: TSESTree$1.Node): node is TSESTree$1.StringLiteral;

declare function isThisExpression(node: TSESTree$1.Expression): boolean;

/**
 * Returns human readable node name for given AST node
 * @param node AST node
 * @param getText A function that returns the text of the node in the source code
 * @returns Human readable node name
 */
declare function toReadableNodeName(node: TSESTree$1.Node, getText: (node: TSESTree$1.Node) => string): string;

/**
 * Returns human readable node type for given AST node
 * @param node AST node
 * @returns Human readable node type
 */
declare function toReadableNodeType(node: TSESTree$1.Node): "property" | "RegExp literal" | "Null literal" | "Boolean literal" | "Number literal" | "String literal" | "BigInt literal" | "Symbol literal" | "identifier" | "member expression" | "JSX attribute" | "JSX element" | "JSX fragment" | "JSX identifier" | "JSX text" | "JSX closing element" | "JSX closing fragment" | "JSX empty expression" | "JSX expression container" | "JSX member expression" | "JSX namespaced name" | "JSX opening element" | "JSX opening fragment" | "JSX spread attribute" | "JSX spread child" | "decorator" | "program" | "super" | "accessor property" | "array expression" | "array pattern" | "function expression" | "arrow function expression" | "assignment expression" | "assignment pattern" | "await expression" | "binary expression" | "block statement" | "break statement" | "call expression" | "catch clause" | "chain expression" | "class body" | "class declaration" | "class expression" | "conditional expression" | "continue statement" | "debugger statement" | "while statement" | "do while statement" | "empty statement" | "export all declaration" | "export default declaration" | "export named declaration" | "export specifier" | "expression statement" | "for in statement" | "for of statement" | "for statement" | "function declaration" | "if statement" | "import attribute" | "import declaration" | "import default specifier" | "import expression" | "import namespace specifier" | "import specifier" | "labeled statement" | "logical expression" | "meta property" | "method definition" | "new expression" | "object expression" | "object pattern" | "private identifier" | "property definition" | "rest element" | "return statement" | "sequence expression" | "spread element" | "static block" | "switch case" | "switch statement" | "tagged template expression" | "template element" | "template literal" | "this expression" | "throw statement" | "try statement" | "unary expression" | "update expression" | "variable declaration" | "variable declarator" | "with statement" | "yield expression" | "ts abstract accessor property" | "ts abstract keyword" | "ts abstract method definition" | "ts abstract property definition" | "ts any keyword" | "ts array type" | "ts as expression" | "ts async keyword" | "ts big int keyword" | "ts boolean keyword" | "ts call signature declaration" | "ts class implements" | "ts conditional type" | "ts constructor type" | "ts construct signature declaration" | "ts declare function" | "ts declare keyword" | "ts empty body function expression" | "ts enum body" | "ts enum declaration" | "ts enum member" | "ts export assignment" | "ts export keyword" | "ts external module reference" | "ts function type" | "ts import equals declaration" | "ts import type" | "ts indexed access type" | "ts index signature" | "ts infer type" | "ts instantiation expression" | "ts interface body" | "ts interface declaration" | "ts interface heritage" | "ts intersection type" | "ts intrinsic keyword" | "ts literal type" | "ts mapped type" | "ts method signature" | "ts module block" | "ts module declaration" | "ts named tuple member" | "ts namespace export declaration" | "ts never keyword" | "ts non null expression" | "ts null keyword" | "ts number keyword" | "ts object keyword" | "ts optional type" | "ts parameter property" | "ts private keyword" | "ts property signature" | "ts protected keyword" | "ts public keyword" | "ts qualified name" | "ts readonly keyword" | "ts rest type" | "ts satisfies expression" | "ts static keyword" | "ts string keyword" | "ts symbol keyword" | "ts template literal type" | "ts this type" | "ts tuple type" | "ts type alias declaration" | "ts type annotation" | "ts type assertion" | "ts type literal" | "ts type operator" | "ts type parameter" | "ts type parameter declaration" | "ts type parameter instantiation" | "ts type predicate" | "ts type query" | "ts type reference" | "ts undefined keyword" | "ts union type" | "ts unknown keyword" | "ts void keyword";
type ReadableNodeType = ReturnType<typeof toReadableNodeType>;

/**
 * Traverses up the AST tree until the predicate returns `true` or the root node is reached
 * @param node The AST node to start traversing from
 * @param predicate The predicate to check each node
 * @returns The first node that matches the predicate or `null` if no node matches
 */
declare const traverseUp: {
    (node: TSESTree$1.Node, predicate: (node: TSESTree$1.Node) => boolean): O.Option<TSESTree$1.Node>;
    (predicate: (node: TSESTree$1.Node) => boolean): (node: TSESTree$1.Node) => O.Option<TSESTree$1.Node>;
};

/**
 * Traverses up the AST tree until the predicate returns `true` or the root node is reached
 * @template T
 * @param node The AST node to start traversing from
 * @param predicate The predicate to check each node. **must be a type guard**
 * @returns The first node that matches the predicate or `null` if no node matches
 */
declare const traverseUpGuard: {
    <T extends TSESTree$1.Node>(node: TSESTree$1.Node, predicate: (node: TSESTree$1.Node) => node is T): O.Option<T>;
    <T extends TSESTree$1.Node>(predicate: (node: TSESTree$1.Node) => node is T): (node: TSESTree$1.Node) => O.Option<T>;
};

export { type FunctionInitPath, type ReadableNodeType, type TSESTreeArrayTupleType, type TSESTreeClass, type TSESTreeDestructuringPattern, type TSESTreeFunction, type TSESTreeFunctionType, type TSESTreeJSX, type TSESTreeLoop, type TSESTreeProperty, type TSESTreeTypeDeclaration, getClassIdentifier, getFunctionIdentifier, getFunctionInitPath, getIdentifiersFromBinaryExpression, getLiteralValueType, getNestedCallExpressions, getNestedIdentifiers, getNestedNewExpressions, getNestedReturnStatements, getTopLevelIdentifier, hasCallInFunctionInitPath, is, isArrayTupleType, isClass, isConditional, isControlFlow, isDestructuringPattern, isEmptyFunction, isFunction, isFunctionOfClassMethod, isFunctionOfClassProperty, isFunctionOfImmediatelyInvoked, isFunctionOfObjectMethod, isFunctionType, isJSX, isJSXElement, isJSXFragment, isJSXTagNameExpression, isKeyLiteralLike, isLeftHandSideExpression, isLeftHandSideExpressionType, isLoop, isMapCallLoose, isMultiLine, isNodeEqual, isOneOf, isProperty, isRegExpLiteral, isStringLiteral, isThisExpression, isTypeDeclaration, toReadableNodeName, toReadableNodeType, traverseUp, traverseUpGuard };
